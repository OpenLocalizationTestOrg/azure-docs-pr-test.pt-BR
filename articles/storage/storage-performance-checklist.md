---
title: "Lista de verificação de desempenho e escalabilidade do Armazenamento do Azure | Microsoft Docs"
description: "Uma lista de verificação de práticas comprovadas para uso com o Armazenamento do Azure no desenvolvimento de aplicativos de alto desempenho."
services: storage
documentationcenter: 
author: robinsh
manager: timlt
editor: tysonn
ms.assetid: 959d831b-a4fd-4634-a646-0d2c0c462ef8
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 12/08/2016
ms.author: robinsh
ms.openlocfilehash: c12f98b069689e335d308d8f8edba2dece21d806
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 07/11/2017
---
# <a name="microsoft-azure-storage-performance-and-scalability-checklist"></a><span data-ttu-id="a0d34-103">Lista de verificação de desempenho e escalabilidade do armazenamento do Microsoft Azure</span><span class="sxs-lookup"><span data-stu-id="a0d34-103">Microsoft Azure Storage Performance and Scalability Checklist</span></span>
## <a name="overview"></a><span data-ttu-id="a0d34-104">Visão geral</span><span class="sxs-lookup"><span data-stu-id="a0d34-104">Overview</span></span>
<span data-ttu-id="a0d34-105">Desde os serviços de armazenamento do Microsoft Azure, a Microsoft desenvolveu diversas práticas comprovadas para usar esses serviços de modo a obter muito rendimento. Este artigo consolida as práticas mais importantes na forma de uma lista estilo lista de verificação.</span><span class="sxs-lookup"><span data-stu-id="a0d34-105">Since the release of the Microsoft Azure Storage services, Microsoft has developed a number of proven practices for using these services in a performant manner, and this article serves to consolidate the most important of them into a checklist-style list.</span></span> <span data-ttu-id="a0d34-106">A finalidade deste artigo é ajudar os desenvolvedores de aplicativos a verificar se eles estão usando as práticas comprovadas com o armazenamento do Azure, bem como ajudá-lo a identificar outras práticas comprovadas que eles podem adotar.</span><span class="sxs-lookup"><span data-stu-id="a0d34-106">The intention of this article is to help application developers verify they are using proven practices with Azure Storage and to help them identify other proven practices they should consider adopting.</span></span> <span data-ttu-id="a0d34-107">Este artigo não tem como objetivo cobrir todas as possibilidades de otimização de desempenho e escalabilidade. Aqui, não abordamos as práticas que apresentam pouco impacto ou que não se aplicam em larga escala.</span><span class="sxs-lookup"><span data-stu-id="a0d34-107">This article does not attempt to cover every possible performance and scalability optimization — it excludes those that are small in their impact or not broadly applicable.</span></span> <span data-ttu-id="a0d34-108">Na medida em que é possível prever o comportamento do aplicativo durante a criação, é útil seguir essas práticas desde o início para evitar problemas de desempenho.</span><span class="sxs-lookup"><span data-stu-id="a0d34-108">To the extent that the application's behavior can be predicted during design, it's useful to keep these in mind early on to avoid designs that will run into performance problems.</span></span>  

<span data-ttu-id="a0d34-109">Todos os desenvolvedores de aplicativos que usam o armazenamento do Azure devem ler este artigo e verificar se seu aplicativo segue as práticas comprovadas listadas abaixo.</span><span class="sxs-lookup"><span data-stu-id="a0d34-109">Every application developer using Azure Storage should take the time to read this article, and check that his or her application follows each of the proven practices listed below.</span></span>  

## <a name="checklist"></a><span data-ttu-id="a0d34-110">Lista de verificação</span><span class="sxs-lookup"><span data-stu-id="a0d34-110">Checklist</span></span>
<span data-ttu-id="a0d34-111">Este artigo organiza as práticas comprovadas nos grupos a seguir.</span><span class="sxs-lookup"><span data-stu-id="a0d34-111">This article organizes the proven practices into the following groups.</span></span> <span data-ttu-id="a0d34-112">As práticas comprovadas aplicam-se a:</span><span class="sxs-lookup"><span data-stu-id="a0d34-112">Proven practices applicable to:</span></span>  

* <span data-ttu-id="a0d34-113">Todos os serviços de armazenamento do Azure (blobs, tabelas, filas e arquivos)</span><span class="sxs-lookup"><span data-stu-id="a0d34-113">All Azure Storage services (blobs, tables, queues, and files)</span></span>
* <span data-ttu-id="a0d34-114">Blobs</span><span class="sxs-lookup"><span data-stu-id="a0d34-114">Blobs</span></span>
* <span data-ttu-id="a0d34-115">Tabelas</span><span class="sxs-lookup"><span data-stu-id="a0d34-115">Tables</span></span>
* <span data-ttu-id="a0d34-116">Filas</span><span class="sxs-lookup"><span data-stu-id="a0d34-116">Queues</span></span>  

| <span data-ttu-id="a0d34-117">Concluído</span><span class="sxs-lookup"><span data-stu-id="a0d34-117">Done</span></span> | <span data-ttu-id="a0d34-118">Área</span><span class="sxs-lookup"><span data-stu-id="a0d34-118">Area</span></span> | <span data-ttu-id="a0d34-119">Categoria</span><span class="sxs-lookup"><span data-stu-id="a0d34-119">Category</span></span> | <span data-ttu-id="a0d34-120">Pergunta</span><span class="sxs-lookup"><span data-stu-id="a0d34-120">Question</span></span> |
| --- | --- | --- | --- |
| &nbsp; | <span data-ttu-id="a0d34-121">Todos os serviços</span><span class="sxs-lookup"><span data-stu-id="a0d34-121">All Services</span></span> |<span data-ttu-id="a0d34-122">Metas de escalabilidade</span><span class="sxs-lookup"><span data-stu-id="a0d34-122">Scalability Targets</span></span> |[<span data-ttu-id="a0d34-123">Seu aplicativo foi criado para evitar a abordagem de metas de escalabilidade?</span><span class="sxs-lookup"><span data-stu-id="a0d34-123">Is your application designed to avoid approaching the scalability targets?</span></span>](#subheading1) |
| &nbsp; | <span data-ttu-id="a0d34-124">Todos os serviços</span><span class="sxs-lookup"><span data-stu-id="a0d34-124">All Services</span></span> |<span data-ttu-id="a0d34-125">Metas de escalabilidade</span><span class="sxs-lookup"><span data-stu-id="a0d34-125">Scalability Targets</span></span> |[<span data-ttu-id="a0d34-126">A convenção de nomenclatura foi projetada para permitir melhor balanceamento de carga?</span><span class="sxs-lookup"><span data-stu-id="a0d34-126">Is your naming convention designed to enable better load-balancing?</span></span>](#subheading47) |
| &nbsp; | <span data-ttu-id="a0d34-127">Todos os serviços</span><span class="sxs-lookup"><span data-stu-id="a0d34-127">All Services</span></span> |<span data-ttu-id="a0d34-128">Rede</span><span class="sxs-lookup"><span data-stu-id="a0d34-128">Networking</span></span> |[<span data-ttu-id="a0d34-129">Os dispositivos cliente têm largura de banda suficiente e baixa latência para alcançar o desempenho necessário?</span><span class="sxs-lookup"><span data-stu-id="a0d34-129">Do client side devices have sufficiently high bandwidth and low latency to achieve the performance needed?</span></span>](#subheading2) |
| &nbsp; | <span data-ttu-id="a0d34-130">Todos os serviços</span><span class="sxs-lookup"><span data-stu-id="a0d34-130">All Services</span></span> |<span data-ttu-id="a0d34-131">Rede</span><span class="sxs-lookup"><span data-stu-id="a0d34-131">Networking</span></span> |[<span data-ttu-id="a0d34-132">Os dispositivos cliente têm um link de alta qualidade?</span><span class="sxs-lookup"><span data-stu-id="a0d34-132">Do client side devices have a high enough quality link?</span></span>](#subheading3) |
| &nbsp; | <span data-ttu-id="a0d34-133">Todos os serviços</span><span class="sxs-lookup"><span data-stu-id="a0d34-133">All Services</span></span> |<span data-ttu-id="a0d34-134">Rede</span><span class="sxs-lookup"><span data-stu-id="a0d34-134">Networking</span></span> |[<span data-ttu-id="a0d34-135">O aplicativo cliente está "próximo" à conta de armazenamento?</span><span class="sxs-lookup"><span data-stu-id="a0d34-135">Is the client application located "near" the storage account?</span></span>](#subheading4) |
| &nbsp; | <span data-ttu-id="a0d34-136">Todos os serviços</span><span class="sxs-lookup"><span data-stu-id="a0d34-136">All Services</span></span> |<span data-ttu-id="a0d34-137">Distribuição de conteúdo</span><span class="sxs-lookup"><span data-stu-id="a0d34-137">Content Distribution</span></span> |[<span data-ttu-id="a0d34-138">Você usa um CDN para distribuir conteúdo?</span><span class="sxs-lookup"><span data-stu-id="a0d34-138">Are you using a CDN for content distribution?</span></span>](#subheading5) |
| &nbsp; | <span data-ttu-id="a0d34-139">Todos os serviços</span><span class="sxs-lookup"><span data-stu-id="a0d34-139">All Services</span></span> |<span data-ttu-id="a0d34-140">Acesso direto do cliente</span><span class="sxs-lookup"><span data-stu-id="a0d34-140">Direct Client Access</span></span> |[<span data-ttu-id="a0d34-141">Você usa SAS e CORS para permitir o acesso direto ao armazenamento, em vez de usar um proxy?</span><span class="sxs-lookup"><span data-stu-id="a0d34-141">Are you using SAS and CORS to allow direct access to storage instead of proxy?</span></span>](#subheading6) |
| &nbsp; | <span data-ttu-id="a0d34-142">Todos os serviços</span><span class="sxs-lookup"><span data-stu-id="a0d34-142">All Services</span></span> |<span data-ttu-id="a0d34-143">Cache</span><span class="sxs-lookup"><span data-stu-id="a0d34-143">Caching</span></span> |[<span data-ttu-id="a0d34-144">Seu aplicativo armazena em cache os dados que são usados com frequência e que raramente mudam?</span><span class="sxs-lookup"><span data-stu-id="a0d34-144">Is your application caching data that is repeatedly used and changes rarely?</span></span>](#subheading7) |
| &nbsp; | <span data-ttu-id="a0d34-145">Todos os serviços</span><span class="sxs-lookup"><span data-stu-id="a0d34-145">All Services</span></span> |<span data-ttu-id="a0d34-146">Cache</span><span class="sxs-lookup"><span data-stu-id="a0d34-146">Caching</span></span> |[<span data-ttu-id="a0d34-147">Seu aplicativo compila atualizações, armazenando-as em cache no cliente e carregando-as em grandes conjuntos?</span><span class="sxs-lookup"><span data-stu-id="a0d34-147">Is your application batching updates (caching them client side and then uploading in larger sets)?</span></span>](#subheading8) |
| &nbsp; | <span data-ttu-id="a0d34-148">Todos os serviços</span><span class="sxs-lookup"><span data-stu-id="a0d34-148">All Services</span></span> |<span data-ttu-id="a0d34-149">Configuração .NET</span><span class="sxs-lookup"><span data-stu-id="a0d34-149">.NET Configuration</span></span> |[<span data-ttu-id="a0d34-150">Você configurou seu cliente para usar uma quantidade suficiente de conexões simultâneas?</span><span class="sxs-lookup"><span data-stu-id="a0d34-150">Have you configured your client to use a sufficient number of concurrent connections?</span></span>](#subheading9) |
| &nbsp; | <span data-ttu-id="a0d34-151">Todos os serviços</span><span class="sxs-lookup"><span data-stu-id="a0d34-151">All Services</span></span> |<span data-ttu-id="a0d34-152">Configuração .NET</span><span class="sxs-lookup"><span data-stu-id="a0d34-152">.NET Configuration</span></span> |[<span data-ttu-id="a0d34-153">Você configurou o .NET para usar uma quantidade suficiente de threads?</span><span class="sxs-lookup"><span data-stu-id="a0d34-153">Have you configured .NET to use a sufficient number of threads?</span></span>](#subheading10) |
| &nbsp; | <span data-ttu-id="a0d34-154">Todos os serviços</span><span class="sxs-lookup"><span data-stu-id="a0d34-154">All Services</span></span> |<span data-ttu-id="a0d34-155">Configuração .NET</span><span class="sxs-lookup"><span data-stu-id="a0d34-155">.NET Configuration</span></span> |[<span data-ttu-id="a0d34-156">Você usa o .NET 4.5 ou posterior, versões com recurso aprimorado de coleta de lixo?</span><span class="sxs-lookup"><span data-stu-id="a0d34-156">Are you using .NET 4.5 or later, which has improved garbage collection?</span></span>](#subheading11) |
| &nbsp; | <span data-ttu-id="a0d34-157">Todos os serviços</span><span class="sxs-lookup"><span data-stu-id="a0d34-157">All Services</span></span> |<span data-ttu-id="a0d34-158">Paralelismo</span><span class="sxs-lookup"><span data-stu-id="a0d34-158">Parallelism</span></span> |[<span data-ttu-id="a0d34-159">Você garantiu a associação adequada do paralelismo para não carregar as funcionalidades do cliente nem as metas de escalabilidade?</span><span class="sxs-lookup"><span data-stu-id="a0d34-159">Have you ensured that parallelism is bounded appropriately so that you don't overload either your client capabilities or the scalability targets?</span></span>](#subheading12) |
| &nbsp; | <span data-ttu-id="a0d34-160">Todos os serviços</span><span class="sxs-lookup"><span data-stu-id="a0d34-160">All Services</span></span> |<span data-ttu-id="a0d34-161">Ferramentas</span><span class="sxs-lookup"><span data-stu-id="a0d34-161">Tools</span></span> |[<span data-ttu-id="a0d34-162">Você está usando a última versão das bibliotecas e ferramentas fornecidas pela Microsoft?</span><span class="sxs-lookup"><span data-stu-id="a0d34-162">Are you using the latest version of Microsoft provided client libraries and tools?</span></span>](#subheading13) |
| &nbsp; | <span data-ttu-id="a0d34-163">Todos os serviços</span><span class="sxs-lookup"><span data-stu-id="a0d34-163">All Services</span></span> |<span data-ttu-id="a0d34-164">Novas tentativas</span><span class="sxs-lookup"><span data-stu-id="a0d34-164">Retries</span></span> |[<span data-ttu-id="a0d34-165">Você usa uma política de nova tentativa de retirada exponencial para diminuir os erros e a ocorrência de tempos limite?</span><span class="sxs-lookup"><span data-stu-id="a0d34-165">Are you using an exponential backoff retry policy for throttling errors and timeouts?</span></span>](#subheading14) |
| &nbsp; | <span data-ttu-id="a0d34-166">Todos os serviços</span><span class="sxs-lookup"><span data-stu-id="a0d34-166">All Services</span></span> |<span data-ttu-id="a0d34-167">Novas tentativas</span><span class="sxs-lookup"><span data-stu-id="a0d34-167">Retries</span></span> |[<span data-ttu-id="a0d34-168">Seu aplicativo evita novas tentativas para erros que não admitem novas tentativas?</span><span class="sxs-lookup"><span data-stu-id="a0d34-168">Is your application avoiding retries for non-retryable errors?</span></span>](#subheading15) |
| &nbsp; | <span data-ttu-id="a0d34-169">Blobs</span><span class="sxs-lookup"><span data-stu-id="a0d34-169">Blobs</span></span> |<span data-ttu-id="a0d34-170">Metas de escalabilidade</span><span class="sxs-lookup"><span data-stu-id="a0d34-170">Scalability Targets</span></span> |[<span data-ttu-id="a0d34-171">Você tem um grande número de clientes que acessam um único objeto simultaneamente?</span><span class="sxs-lookup"><span data-stu-id="a0d34-171">Do you have a large number of clients accessing a single object concurrently?</span></span>](#subheading46) |
| &nbsp; | <span data-ttu-id="a0d34-172">Blobs</span><span class="sxs-lookup"><span data-stu-id="a0d34-172">Blobs</span></span> |<span data-ttu-id="a0d34-173">Metas de escalabilidade</span><span class="sxs-lookup"><span data-stu-id="a0d34-173">Scalability Targets</span></span> |[<span data-ttu-id="a0d34-174">Seu aplicativo segue a meta de largura de banda ou escalabilidade operacional para um único blob?</span><span class="sxs-lookup"><span data-stu-id="a0d34-174">Is your application staying within the bandwidth or operations scalability target for a single blob?</span></span>](#subheading16) |
| &nbsp; | <span data-ttu-id="a0d34-175">Blobs</span><span class="sxs-lookup"><span data-stu-id="a0d34-175">Blobs</span></span> |<span data-ttu-id="a0d34-176">Cópia de blobs</span><span class="sxs-lookup"><span data-stu-id="a0d34-176">Copying Blobs</span></span> |[<span data-ttu-id="a0d34-177">Seu método de cópia de blobs é eficiente?</span><span class="sxs-lookup"><span data-stu-id="a0d34-177">Are you copying blobs in an efficient manner?</span></span>](#subheading17) |
| &nbsp; | <span data-ttu-id="a0d34-178">Blobs</span><span class="sxs-lookup"><span data-stu-id="a0d34-178">Blobs</span></span> |<span data-ttu-id="a0d34-179">Cópia de blobs</span><span class="sxs-lookup"><span data-stu-id="a0d34-179">Copying Blobs</span></span> |[<span data-ttu-id="a0d34-180">Você usa o AzCopy para copiar blobs em massa?</span><span class="sxs-lookup"><span data-stu-id="a0d34-180">Are you using AzCopy for bulk copies of blobs?</span></span>](#subheading18) |
| &nbsp; | <span data-ttu-id="a0d34-181">Blobs</span><span class="sxs-lookup"><span data-stu-id="a0d34-181">Blobs</span></span> |<span data-ttu-id="a0d34-182">Cópia de blobs</span><span class="sxs-lookup"><span data-stu-id="a0d34-182">Copying Blobs</span></span> |[<span data-ttu-id="a0d34-183">Você usa a função de importação/exportação do Azure para transferir grandes volumes de dados?</span><span class="sxs-lookup"><span data-stu-id="a0d34-183">Are you using Azure Import/Export to transfer very large volumes of data?</span></span>](#subheading19) |
| &nbsp; | <span data-ttu-id="a0d34-184">Blobs</span><span class="sxs-lookup"><span data-stu-id="a0d34-184">Blobs</span></span> |<span data-ttu-id="a0d34-185">Uso de metadados</span><span class="sxs-lookup"><span data-stu-id="a0d34-185">Use Metadata</span></span> |[<span data-ttu-id="a0d34-186">Você armazena os metadados sobre blobs usados com frequência?</span><span class="sxs-lookup"><span data-stu-id="a0d34-186">Are you storing frequently used metadata about blobs in their metadata?</span></span>](#subheading20) |
| &nbsp; | <span data-ttu-id="a0d34-187">Blobs</span><span class="sxs-lookup"><span data-stu-id="a0d34-187">Blobs</span></span> |<span data-ttu-id="a0d34-188">Carregamento rápido</span><span class="sxs-lookup"><span data-stu-id="a0d34-188">Uploading Fast</span></span> |[<span data-ttu-id="a0d34-189">Ao tentar carregar um blob rapidamente, você carrega blocos paralelamente?</span><span class="sxs-lookup"><span data-stu-id="a0d34-189">When trying to upload one blob quickly, are you uploading blocks in parallel?</span></span>](#subheading21) |
| &nbsp; | <span data-ttu-id="a0d34-190">Blobs</span><span class="sxs-lookup"><span data-stu-id="a0d34-190">Blobs</span></span> |<span data-ttu-id="a0d34-191">Carregamento rápido</span><span class="sxs-lookup"><span data-stu-id="a0d34-191">Uploading Fast</span></span> |[<span data-ttu-id="a0d34-192">Ao tentar carregar muitos blobs rapidamente, você carrega blocos paralelamente?</span><span class="sxs-lookup"><span data-stu-id="a0d34-192">When trying to upload many blobs quickly, are you uploading blobs in parallel?</span></span>](#subheading22) |
| &nbsp; | <span data-ttu-id="a0d34-193">Blobs</span><span class="sxs-lookup"><span data-stu-id="a0d34-193">Blobs</span></span> |<span data-ttu-id="a0d34-194">Tipo de blob correto</span><span class="sxs-lookup"><span data-stu-id="a0d34-194">Correct Blob Type</span></span> |[<span data-ttu-id="a0d34-195">Você usa blobs de página ou de bloco quando necessário?</span><span class="sxs-lookup"><span data-stu-id="a0d34-195">Are you using page blobs or block blobs when appropriate?</span></span>](#subheading23) |
| &nbsp; | <span data-ttu-id="a0d34-196">Tabelas</span><span class="sxs-lookup"><span data-stu-id="a0d34-196">Tables</span></span> |<span data-ttu-id="a0d34-197">Metas de escalabilidade</span><span class="sxs-lookup"><span data-stu-id="a0d34-197">Scalability Targets</span></span> |[<span data-ttu-id="a0d34-198">Você leva as metas de escalabilidade em consideração para entidades por segundo?</span><span class="sxs-lookup"><span data-stu-id="a0d34-198">Are you approaching the scalability targets for entities per second?</span></span>](#subheading24) |
| &nbsp; | <span data-ttu-id="a0d34-199">Tabelas</span><span class="sxs-lookup"><span data-stu-id="a0d34-199">Tables</span></span> |<span data-ttu-id="a0d34-200">Configuração</span><span class="sxs-lookup"><span data-stu-id="a0d34-200">Configuration</span></span> |[<span data-ttu-id="a0d34-201">Você usa JSON para suas solicitações de tabela?</span><span class="sxs-lookup"><span data-stu-id="a0d34-201">Are you using JSON for your table requests?</span></span>](#subheading25) |
| &nbsp; | <span data-ttu-id="a0d34-202">Tabelas</span><span class="sxs-lookup"><span data-stu-id="a0d34-202">Tables</span></span> |<span data-ttu-id="a0d34-203">Configuração</span><span class="sxs-lookup"><span data-stu-id="a0d34-203">Configuration</span></span> |[<span data-ttu-id="a0d34-204">Você desativou o Nagle para melhorar o desempenho de pequenas solicitações?</span><span class="sxs-lookup"><span data-stu-id="a0d34-204">Have you turned Nagle off to improve the performance of small requests?</span></span>](#subheading26) |
| &nbsp; | <span data-ttu-id="a0d34-205">Tabelas</span><span class="sxs-lookup"><span data-stu-id="a0d34-205">Tables</span></span> |<span data-ttu-id="a0d34-206">Tabelas e partições</span><span class="sxs-lookup"><span data-stu-id="a0d34-206">Tables and Partitions</span></span> |[<span data-ttu-id="a0d34-207">Você particionou seus dados corretamente?</span><span class="sxs-lookup"><span data-stu-id="a0d34-207">Have you properly partitioned your data?</span></span>](#subheading27) |
| &nbsp; | <span data-ttu-id="a0d34-208">Tabelas</span><span class="sxs-lookup"><span data-stu-id="a0d34-208">Tables</span></span> |<span data-ttu-id="a0d34-209">Partições mais acessadas</span><span class="sxs-lookup"><span data-stu-id="a0d34-209">Hot Partitions</span></span> |[<span data-ttu-id="a0d34-210">Você evita padrões do tipo "somente anexar" e "somente incluir"?</span><span class="sxs-lookup"><span data-stu-id="a0d34-210">Are you avoiding append-only and prepend-only patterns?</span></span>](#subheading28) |
| &nbsp; | <span data-ttu-id="a0d34-211">Tabelas</span><span class="sxs-lookup"><span data-stu-id="a0d34-211">Tables</span></span> |<span data-ttu-id="a0d34-212">Partições mais acessadas</span><span class="sxs-lookup"><span data-stu-id="a0d34-212">Hot Partitions</span></span> |[<span data-ttu-id="a0d34-213">Suas inserções/atualizações valem para diversas partições?</span><span class="sxs-lookup"><span data-stu-id="a0d34-213">Are your inserts/updates spread across many partitions?</span></span>](#subheading29) |
| &nbsp; | <span data-ttu-id="a0d34-214">Tabelas</span><span class="sxs-lookup"><span data-stu-id="a0d34-214">Tables</span></span> |<span data-ttu-id="a0d34-215">Escopo da consulta</span><span class="sxs-lookup"><span data-stu-id="a0d34-215">Query Scope</span></span> |[<span data-ttu-id="a0d34-216">Você criou seu esquema para permitir o uso de consultas pontuais na maioria dos casos e de consultas de tabelas raramente?</span><span class="sxs-lookup"><span data-stu-id="a0d34-216">Have you designed your schema to allow for point queries to be used in most cases, and table queries to be used sparingly?</span></span>](#subheading30) |
| &nbsp; | <span data-ttu-id="a0d34-217">Tabelas</span><span class="sxs-lookup"><span data-stu-id="a0d34-217">Tables</span></span> |<span data-ttu-id="a0d34-218">Densidade da consulta</span><span class="sxs-lookup"><span data-stu-id="a0d34-218">Query Density</span></span> |[<span data-ttu-id="a0d34-219">As suas consultas geralmente verificam e indicam quais linhas o aplicativo usará?</span><span class="sxs-lookup"><span data-stu-id="a0d34-219">Do your queries typically only scan and return rows that your application will use?</span></span>](#subheading31) |
| &nbsp; | <span data-ttu-id="a0d34-220">Tabelas</span><span class="sxs-lookup"><span data-stu-id="a0d34-220">Tables</span></span> |<span data-ttu-id="a0d34-221">Limitação dos dados retornados</span><span class="sxs-lookup"><span data-stu-id="a0d34-221">Limiting Returned Data</span></span> |[<span data-ttu-id="a0d34-222">Você usa a filtragem para evitar o retorno de entidades que não são necessárias?</span><span class="sxs-lookup"><span data-stu-id="a0d34-222">Are you using filtering to avoid returning entities that are not needed?</span></span>](#subheading32) |
| &nbsp; | <span data-ttu-id="a0d34-223">Tabelas</span><span class="sxs-lookup"><span data-stu-id="a0d34-223">Tables</span></span> |<span data-ttu-id="a0d34-224">Limitação dos dados retornados</span><span class="sxs-lookup"><span data-stu-id="a0d34-224">Limiting Returned Data</span></span> |[<span data-ttu-id="a0d34-225">Você usa a projeção para evitar o retorno de propriedades que não são necessárias?</span><span class="sxs-lookup"><span data-stu-id="a0d34-225">Are you using projection to avoid returning properties that are not needed?</span></span>](#subheading33) |
| &nbsp; | <span data-ttu-id="a0d34-226">Tabelas</span><span class="sxs-lookup"><span data-stu-id="a0d34-226">Tables</span></span> |<span data-ttu-id="a0d34-227">Desnormalização</span><span class="sxs-lookup"><span data-stu-id="a0d34-227">Denormalization</span></span> |[<span data-ttu-id="a0d34-228">Você desnormalizou seus dados a fim de evitar consultas ineficientes sou diversas solicitações de leitura ao tentar obter dados?</span><span class="sxs-lookup"><span data-stu-id="a0d34-228">Have you denormalized your data such that you avoid inefficient queries or multiple read requests when trying to get data?</span></span>](#subheading34) |
| &nbsp; | <span data-ttu-id="a0d34-229">Tabelas</span><span class="sxs-lookup"><span data-stu-id="a0d34-229">Tables</span></span> |<span data-ttu-id="a0d34-230">Inserção/atualização/exclusão</span><span class="sxs-lookup"><span data-stu-id="a0d34-230">Insert/Update/Delete</span></span> |[<span data-ttu-id="a0d34-231">Você compila as solicitações que devem ser transacionais ou que podem ser executadas ao mesmo tempo para diminuir a quantidade de viagens de ida e volta?</span><span class="sxs-lookup"><span data-stu-id="a0d34-231">Are you batching requests that need to be transactional or can be done at the same time to reduce round-trips?</span></span>](#subheading35) |
| &nbsp; | <span data-ttu-id="a0d34-232">Tabelas</span><span class="sxs-lookup"><span data-stu-id="a0d34-232">Tables</span></span> |<span data-ttu-id="a0d34-233">Inserção/atualização/exclusão</span><span class="sxs-lookup"><span data-stu-id="a0d34-233">Insert/Update/Delete</span></span> |[<span data-ttu-id="a0d34-234">Você evita novas tentativas nas entidades apenas para determinar se a chamada deve ser inserida ou atualizada?</span><span class="sxs-lookup"><span data-stu-id="a0d34-234">Are you avoiding retrieving an entity just to determine whether to call insert or update?</span></span>](#subheading36) |
| &nbsp; | <span data-ttu-id="a0d34-235">Tabelas</span><span class="sxs-lookup"><span data-stu-id="a0d34-235">Tables</span></span> |<span data-ttu-id="a0d34-236">Inserção/atualização/exclusão</span><span class="sxs-lookup"><span data-stu-id="a0d34-236">Insert/Update/Delete</span></span> |[<span data-ttu-id="a0d34-237">Você já pensou em armazenar séries de dados que serão recuperados em conjunto frequentemente, em uma única entidade e como propriedades, em vez de serem recuperados como diversas entidades?</span><span class="sxs-lookup"><span data-stu-id="a0d34-237">Have you considered storing series of data that will frequently be retrieved together in a single entity as properties instead of multiple entities?</span></span>](#subheading37) |
| &nbsp; | <span data-ttu-id="a0d34-238">Tabelas</span><span class="sxs-lookup"><span data-stu-id="a0d34-238">Tables</span></span> |<span data-ttu-id="a0d34-239">Inserção/atualização/exclusão</span><span class="sxs-lookup"><span data-stu-id="a0d34-239">Insert/Update/Delete</span></span> |[<span data-ttu-id="a0d34-240">Você já pensou em usar blobs no lugar das tabelas para as entidades que serão recuperadas em conjunto e que podem ser escritas em lotes (por exemplo, dados de séries temporais)?</span><span class="sxs-lookup"><span data-stu-id="a0d34-240">For entities that will always be retrieved together and can be written in batches (e.g. time series data), have you considered using blobs instead of tables?</span></span>](#subheading38) |
| &nbsp; | <span data-ttu-id="a0d34-241">Filas</span><span class="sxs-lookup"><span data-stu-id="a0d34-241">Queues</span></span> |<span data-ttu-id="a0d34-242">Metas de escalabilidade</span><span class="sxs-lookup"><span data-stu-id="a0d34-242">Scalability Targets</span></span> |[<span data-ttu-id="a0d34-243">Você leva as metas de escalabilidade em consideração para mensagens por segundo?</span><span class="sxs-lookup"><span data-stu-id="a0d34-243">Are you approaching the scalability targets for messages per second?</span></span>](#subheading39) |
| &nbsp; | <span data-ttu-id="a0d34-244">Filas</span><span class="sxs-lookup"><span data-stu-id="a0d34-244">Queues</span></span> |<span data-ttu-id="a0d34-245">Configuração</span><span class="sxs-lookup"><span data-stu-id="a0d34-245">Configuration</span></span> |[<span data-ttu-id="a0d34-246">Você desativou o Nagle para melhorar o desempenho de pequenas solicitações?</span><span class="sxs-lookup"><span data-stu-id="a0d34-246">Have you turned Nagle off to improve the performance of small requests?</span></span>](#subheading40) |
| &nbsp; | <span data-ttu-id="a0d34-247">Filas</span><span class="sxs-lookup"><span data-stu-id="a0d34-247">Queues</span></span> |<span data-ttu-id="a0d34-248">Tamanho da mensagem</span><span class="sxs-lookup"><span data-stu-id="a0d34-248">Message Size</span></span> |[<span data-ttu-id="a0d34-249">Suas mensagens são compactas para melhorar o desempenho da fila?</span><span class="sxs-lookup"><span data-stu-id="a0d34-249">Are your messages compact to improve the performance of the queue?</span></span>](#subheading41) |
| &nbsp; | <span data-ttu-id="a0d34-250">Filas</span><span class="sxs-lookup"><span data-stu-id="a0d34-250">Queues</span></span> |<span data-ttu-id="a0d34-251">Recuperação em massa</span><span class="sxs-lookup"><span data-stu-id="a0d34-251">Bulk Retrieve</span></span> |[<span data-ttu-id="a0d34-252">Você recupera diversas mensagens com uma única operação "Obter"?</span><span class="sxs-lookup"><span data-stu-id="a0d34-252">Are you retrieving multiple messages in a single "Get" operation?</span></span>](#subheading42) |
| &nbsp; | <span data-ttu-id="a0d34-253">Filas</span><span class="sxs-lookup"><span data-stu-id="a0d34-253">Queues</span></span> |<span data-ttu-id="a0d34-254">Frequência de votação</span><span class="sxs-lookup"><span data-stu-id="a0d34-254">Polling Frequency</span></span> |[<span data-ttu-id="a0d34-255">As votações ocorrem com frequência suficiente para reduzir a latência notável do aplicativo?</span><span class="sxs-lookup"><span data-stu-id="a0d34-255">Are you polling frequently enough to reduce the perceived latency of your application?</span></span>](#subheading43) |
| &nbsp; | <span data-ttu-id="a0d34-256">Filas</span><span class="sxs-lookup"><span data-stu-id="a0d34-256">Queues</span></span> |<span data-ttu-id="a0d34-257">Atualização de mensagem</span><span class="sxs-lookup"><span data-stu-id="a0d34-257">Update Message</span></span> |[<span data-ttu-id="a0d34-258">Você usa a função de atualização de mensagem para armazenar o progresso do processamento de mensagens, evitando a necessidade de reprocessar toda a mensagem em caso de erro?</span><span class="sxs-lookup"><span data-stu-id="a0d34-258">Are you using UpdateMessage to store progress in processing messages, avoiding having to reprocess the entire message if an error occurs?</span></span>](#subheading44) |
| &nbsp; | <span data-ttu-id="a0d34-259">Filas</span><span class="sxs-lookup"><span data-stu-id="a0d34-259">Queues</span></span> |<span data-ttu-id="a0d34-260">Arquitetura</span><span class="sxs-lookup"><span data-stu-id="a0d34-260">Architecture</span></span> |[<span data-ttu-id="a0d34-261">Você usa filas para melhorar a escalabilidade de todo o aplicativo ao manter cargas de trabalho demoradas fora do caminho crítico e escalá-las independentemente?</span><span class="sxs-lookup"><span data-stu-id="a0d34-261">Are you using queues to make your entire application more scalable by keeping long-running workloads out of the critical path and scale then independently?</span></span>](#subheading45) |

## <span data-ttu-id="a0d34-262"><a name="allservices"></a>Todos os serviços</span><span class="sxs-lookup"><span data-stu-id="a0d34-262"><a name="allservices"></a>All Services</span></span>
<span data-ttu-id="a0d34-263">Esta seção apresenta as práticas comprovadas aplicáveis ao uso dos serviços de armazenamento do Azure (blobs, tabelas, filas ou arquivos).</span><span class="sxs-lookup"><span data-stu-id="a0d34-263">This section lists proven practices that are applicable to the use of any of the Azure Storage services (blobs, tables, queues, or files).</span></span>  

### <span data-ttu-id="a0d34-264"><a name="subheading1"></a>Metas de escalabilidade</span><span class="sxs-lookup"><span data-stu-id="a0d34-264"><a name="subheading1"></a>Scalability Targets</span></span>
<span data-ttu-id="a0d34-265">Cada serviço de armazenamento do Azure tem metas de escalabilidade para capacidade (GB), taxa de transações e largura de banda.</span><span class="sxs-lookup"><span data-stu-id="a0d34-265">Each of the Azure Storage services has scalability targets for capacity (GB), transaction rate, and bandwidth.</span></span> <span data-ttu-id="a0d34-266">Se o seu aplicativo se aproximar ou ultrapassar alguma das metas de escalabilidade, pode haver aumento da latência e restrição das transações.</span><span class="sxs-lookup"><span data-stu-id="a0d34-266">If your application approaches or exceeds any of the scalability targets, it may encounter increased transaction latencies or throttling.</span></span> <span data-ttu-id="a0d34-267">Quando um serviço de armazenamento restringe seu aplicativo, o serviço começa a apresentar os códigos de erro "503 Server busy" (Servidor ocupado) e "500 Operation timeout" (Tempo limite da operação) para algumas das transações de armazenamento.</span><span class="sxs-lookup"><span data-stu-id="a0d34-267">When a Storage service throttles your application, the service begins to return "503 Server busy" or "500 Operation timeout" error codes for some storage transactions.</span></span> <span data-ttu-id="a0d34-268">Esta seção trata da abordagem geral para lidar com as metas de escalabilidade e as metas de escalabilidade da largura de banda.</span><span class="sxs-lookup"><span data-stu-id="a0d34-268">This section discusses both the general approach to dealing with scalability targets and bandwidth scalability targets in particular.</span></span> <span data-ttu-id="a0d34-269">As outras seções que tratam de cada serviço de armazenamento tratam das metas de escalabilidade no contexto de cada serviço:</span><span class="sxs-lookup"><span data-stu-id="a0d34-269">Later sections that deal with individual storage services discuss scalability targets in the context of that specific service:</span></span>  

* [<span data-ttu-id="a0d34-270">Largura de banda do blob e solicitações por segundo</span><span class="sxs-lookup"><span data-stu-id="a0d34-270">Blob bandwidth and requests per second</span></span>](#subheading16)
* [<span data-ttu-id="a0d34-271">Entidades de tabela por segundo</span><span class="sxs-lookup"><span data-stu-id="a0d34-271">Table entities per second</span></span>](#subheading24)
* [<span data-ttu-id="a0d34-272">Fila de mensagens por segundo</span><span class="sxs-lookup"><span data-stu-id="a0d34-272">Queue messages per second</span></span>](#subheading39)  

#### <span data-ttu-id="a0d34-273"><a name="sub1bandwidth"></a>Meta de escalabilidade de largura de banda para todos os serviços</span><span class="sxs-lookup"><span data-stu-id="a0d34-273"><a name="sub1bandwidth"></a>Bandwidth Scalability Target for All Services</span></span>
<span data-ttu-id="a0d34-274">No momento da edição, as metas de largura de banda nos EUA para uma conta de GRS (armazenamento com redundância geográfica) são de 10 gigabits por segundo (Gbps) para entrada (dados enviados à conta de armazenamento) e 20 Gbps para saída (dados enviados pela conta de armazenamento).</span><span class="sxs-lookup"><span data-stu-id="a0d34-274">At the time of writing, the bandwidth targets in the US for a geo-redundant storage (GRS) account are 10 gigabits per second (Gbps) for ingress (data sent to the storage account) and 20 Gbps for egress (data sent from the storage account).</span></span> <span data-ttu-id="a0d34-275">Os limites das contas de LRS (armazenamento com redundância local) são mais altos — 20 Gbps para entrada e 30 Gbps para saída.</span><span class="sxs-lookup"><span data-stu-id="a0d34-275">For a locally redundant storage (LRS) account, the limits are higher – 20 Gbps for ingress and 30 Gbps for egress.</span></span>  <span data-ttu-id="a0d34-276">Os limites de largura de banda internacional podem ser menores e constam na nossa [página de metas de escalabilidade](http://msdn.microsoft.com/library/azure/dn249410.aspx).</span><span class="sxs-lookup"><span data-stu-id="a0d34-276">International bandwidth limits may be lower and can be found on our [scalability targets page](http://msdn.microsoft.com/library/azure/dn249410.aspx).</span></span>  <span data-ttu-id="a0d34-277">Para obter mais informações sobre as opções de redundância em armazenamento, confira a seção [Recursos úteis](#sub1useful) abaixo.</span><span class="sxs-lookup"><span data-stu-id="a0d34-277">For more information on the storage redundancy options, see the links in [Useful Resources](#sub1useful) below.</span></span>  

#### <a name="what-to-do-when-approaching-a-scalability-target"></a><span data-ttu-id="a0d34-278">O que fazer ao lidar com uma meta de escalabilidade</span><span class="sxs-lookup"><span data-stu-id="a0d34-278">What to do when approaching a scalability target</span></span>
<span data-ttu-id="a0d34-279">Se seu aplicativo estiver lidando com metas de escalabilidade de uma única conta de armazenamento, você pode adotar uma destas abordagens:</span><span class="sxs-lookup"><span data-stu-id="a0d34-279">If your application is approaching the scalability targets for a single storage account, consider adopting one of the following approaches:</span></span>  

* <span data-ttu-id="a0d34-280">Repensar a carga de trabalho que faz com que o aplicativo se aproxime da meta de escalabilidade ou a ultrapasse.</span><span class="sxs-lookup"><span data-stu-id="a0d34-280">Reconsider the workload that causes your application to approach or exceed the scalability target.</span></span> <span data-ttu-id="a0d34-281">Você pode alterar o aplicativo para que ele use menos largura de banda, menos capacidade ou menos transações?</span><span class="sxs-lookup"><span data-stu-id="a0d34-281">Can you design it differently to use less bandwidth or capacity, or fewer transactions?</span></span>
* <span data-ttu-id="a0d34-282">Se o aplicativo ultrapassar uma das metas de escalabilidade propositalmente, você deve criar diversas contas de armazenamento e particionar os dados do seu aplicativo nessas contas.</span><span class="sxs-lookup"><span data-stu-id="a0d34-282">If an application must exceed one of the scalability targets, you should create multiple storage accounts and partition your application data across those multiple storage accounts.</span></span> <span data-ttu-id="a0d34-283">Se você usar esse padrão, crie o aplicativo de forma que seja possível adicionar mais contas de armazenamento posteriormente, para balancear a carga.</span><span class="sxs-lookup"><span data-stu-id="a0d34-283">If you use this pattern, then be sure to design your application so that you can add more storage accounts in the future for load balancing.</span></span> <span data-ttu-id="a0d34-284">No momento da edição, cada assinatura do Azure pode ter até 100 contas de armazenamento.</span><span class="sxs-lookup"><span data-stu-id="a0d34-284">At time of writing, each Azure subscription can have up to 100 storage accounts.</span></span>  <span data-ttu-id="a0d34-285">O único custo das contas de armazenamento é o uso dos dados armazenados, das transações feitas ou dos dados transferidos.</span><span class="sxs-lookup"><span data-stu-id="a0d34-285">Storage accounts also have no cost other than your usage in terms of data stored, transactions made, or data transferred.</span></span>
* <span data-ttu-id="a0d34-286">Se o aplicativo alcançar as metas de largura de banda, você pode compactar os dados no cliente para reduzir a largura de banda necessária para enviar os dados ao serviço de armazenamento.</span><span class="sxs-lookup"><span data-stu-id="a0d34-286">If your application hits the bandwidth targets, consider compressing data in the client to reduce the bandwidth required to send the data to the storage service.</span></span>  <span data-ttu-id="a0d34-287">Apesar de economizar a largura de banda e melhorar o desempenho da rede, isso também pode ter impactos negativos.</span><span class="sxs-lookup"><span data-stu-id="a0d34-287">Note that while this may save bandwidth and improve network performance, it can also have some negative impacts.</span></span>  <span data-ttu-id="a0d34-288">Você deve avaliar o impacto no desempenho causado por essa alteração, devido aos requisitos de processamento adicionais para compactar e descompactar dados no cliente.</span><span class="sxs-lookup"><span data-stu-id="a0d34-288">You should evaluate the performance impact of this due to the additional processing requirements for compressing and decompressing data in the client.</span></span> <span data-ttu-id="a0d34-289">Além disso, o armazenamento de dados compactados pode dificultar a solução de problemas, pois pode ser mais difícil visualizar os dados armazenados por meio de ferramentas padrão.</span><span class="sxs-lookup"><span data-stu-id="a0d34-289">In addition, storing compressed data can make it more difficult to troubleshoot issues since it could be more difficult to view stored data using standard tools.</span></span>
* <span data-ttu-id="a0d34-290">Se seu aplicativo alcançar as metas de escalabilidade, você deve usar a retirada exponencial para novas tentativas (confira [Novas tentativas](#subheading14)).</span><span class="sxs-lookup"><span data-stu-id="a0d34-290">If your application hits the scalability targets, then ensure that you are using an exponential backoff for retries (see [Retries](#subheading14)).</span></span>  <span data-ttu-id="a0d34-291">O mais recomendado é nunca alcançar as metas de escalabilidade, o que é possível garantir por meio de um dos métodos acima. Porém, isso garante que o aplicativo não faça novas tentativas rapidamente, piorando o problema de limitação.</span><span class="sxs-lookup"><span data-stu-id="a0d34-291">It's better to make sure you never approach the scalability targets (by using one of the above methods), but this will ensure your application won't just keep retrying rapidly, making the throttling worse.</span></span>  

#### <a name="useful-resources"></a><span data-ttu-id="a0d34-292">Recursos úteis</span><span class="sxs-lookup"><span data-stu-id="a0d34-292">Useful Resources</span></span>
<span data-ttu-id="a0d34-293">Os links a seguir apresentam mais detalhes sobre as metas de escalabilidade:</span><span class="sxs-lookup"><span data-stu-id="a0d34-293">The following links provide additional detail on scalability targets:</span></span>

* <span data-ttu-id="a0d34-294">Confira [Metas de desempenho e escalabilidade do Armazenamento do Azure](storage-scalability-targets.md) para saber mais sobre metas de escalabilidade.</span><span class="sxs-lookup"><span data-stu-id="a0d34-294">See [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md) for information about scalability targets.</span></span>
* <span data-ttu-id="a0d34-295">Confira [Replicação de Armazenamento do Azure](storage-redundancy.md) e a postagem de blog [Azure Storage Redundancy Options and Read Access Geo Redundant Storage](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/11/introducing-read-access-geo-replicated-storage-ra-grs-for-windows-azure-storage.aspx) (Opções de redundância do Armazenamento do Azure e armazenamento com redundância geográfica com acesso de leitura) para saber mais sobre as opções de redundância de armazenamento.</span><span class="sxs-lookup"><span data-stu-id="a0d34-295">See [Azure Storage replication](storage-redundancy.md) and the blog post [Azure Storage Redundancy Options and Read Access Geo Redundant Storage](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/11/introducing-read-access-geo-replicated-storage-ra-grs-for-windows-azure-storage.aspx) for information about storage redundancy options.</span></span>
* <span data-ttu-id="a0d34-296">Para obter informações atualizadas sobre os preços dos serviços Azure, confira [Preços do Azure](https://azure.microsoft.com/pricing/overview/).</span><span class="sxs-lookup"><span data-stu-id="a0d34-296">For current information about pricing for Azure services, see [Azure pricing](https://azure.microsoft.com/pricing/overview/).</span></span>  

### <span data-ttu-id="a0d34-297"><a name="subheading47"></a>Convenção de nomenclatura de partição</span><span class="sxs-lookup"><span data-stu-id="a0d34-297"><a name="subheading47"></a>Partition Naming Convention</span></span>
<span data-ttu-id="a0d34-298">O Armazenamento do Azure usa um esquema de particionamento baseado em intervalo para dimensionar e balancear a carga do sistema.</span><span class="sxs-lookup"><span data-stu-id="a0d34-298">Azure Storage uses a range-based partitioning scheme to scale and load balance the system.</span></span> <span data-ttu-id="a0d34-299">A chave de partição é usada para particionar dados em intervalos e esses intervalos têm balanceamento de carga em todo o sistema.</span><span class="sxs-lookup"><span data-stu-id="a0d34-299">The partition key is used to partition data into ranges and these ranges are load-balanced across the system.</span></span> <span data-ttu-id="a0d34-300">Isso significa que as convenções de nomenclatura, como a ordem léxica (por exemplo, msftpayroll, msftperformance, msftemployees etc.) ou o uso dos carimbos de data/hora (log20160101, log20160102, log20160102 etc.) se prestarão às partições potencialmente co-localizadas no mesmo servidor de partição, até que uma operação de balanceamento de carga as divida em intervalos menores.</span><span class="sxs-lookup"><span data-stu-id="a0d34-300">This means naming conventions such as lexical ordering (e.g. msftpayroll, msftperformance, msftemployees, etc) or using time-stamps (log20160101, log20160102, log20160102, etc) will lend itself to the partitions being potentially co-located on the same partition server, until a load balancing operation splits them out into smaller ranges.</span></span> <span data-ttu-id="a0d34-301">Por exemplo, todos os blobs em um contêiner podem ser servidos por um único servidor até que a carga nesses blobs exija mais rebalanceamento dos intervalos de partição.</span><span class="sxs-lookup"><span data-stu-id="a0d34-301">For example, all blobs within a container can be served by a single server until the load on these blobs requires further rebalancing of the partition ranges.</span></span> <span data-ttu-id="a0d34-302">Da mesma forma, um grupo de contas pouco carregados com seus nomes organizados em ordem léxica pode ser atendido por um único servidor até que a carga em uma ou em todas essas contas exija a ser dividida em vários servidores de partições.</span><span class="sxs-lookup"><span data-stu-id="a0d34-302">Similarly, a group of lightly loaded accounts with their names arranged in lexical order may be served by a single server until the load on one or all of these accounts require them to be split across multiple partitions servers.</span></span> <span data-ttu-id="a0d34-303">Cada operação de balanceamento de carga pode afetar a latência das chamadas de armazenamento durante a operação.</span><span class="sxs-lookup"><span data-stu-id="a0d34-303">Each load balancing operation may impact the latency of storage calls during the operation.</span></span> <span data-ttu-id="a0d34-304">A capacidade do sistema de lidar com um aumento repentino de tráfego para uma partição é limitada pela escalabilidade de um servidor de partição única até que a operação de balanceamento de carga seja ativada e reequilibre o intervalo de chaves de partição.</span><span class="sxs-lookup"><span data-stu-id="a0d34-304">The system's ability to handle a sudden burst of traffic to a partition is limited by the scalability of a single partition server until the load balancing operation kicks-in and rebalances the partition key range.</span></span>  

<span data-ttu-id="a0d34-305">Você pode seguir algumas práticas recomendadas para reduzir a frequência de tais operações.</span><span class="sxs-lookup"><span data-stu-id="a0d34-305">You can follow some best practices to reduce the frequency of such operations.</span></span>  

* <span data-ttu-id="a0d34-306">Examine detalhadamente a convenção de nomenclatura usada para contas, contêineres, blobs, tabelas e filas.</span><span class="sxs-lookup"><span data-stu-id="a0d34-306">Examine the naming convention you use for accounts, containers, blobs, tables and queues, closely.</span></span> <span data-ttu-id="a0d34-307">Considere prefixar os nomes de conta com um hash de três dígitos usando uma função de hash que melhor atenda às suas necessidades.</span><span class="sxs-lookup"><span data-stu-id="a0d34-307">Consider prefixing account names with a 3-digit hash using a hashing function that best suits your needs.</span></span>  
* <span data-ttu-id="a0d34-308">Se você organizar os dados usando carimbos de data/hora ou identificadores numéricos, precisará garantir que não está usando padrões de tráfego somente acrescentar (ou somente preceder).</span><span class="sxs-lookup"><span data-stu-id="a0d34-308">If you organize your data using timestamps or numerical identifiers, you have to ensure you are not using an append-only (or prepend-only) traffic patterns.</span></span> <span data-ttu-id="a0d34-309">Esses padrões não são adequados a um sistema de particionamento baseado em intervalo e pode fazer com que todo tráfego vá para uma única partição, limitando a eficácia do sistema no balanceamento de carga.</span><span class="sxs-lookup"><span data-stu-id="a0d34-309">These patterns are not suitable for a range -based partitioning system, and could lead to all the traffic going to a single partition and limiting the system from effectively load balancing.</span></span> <span data-ttu-id="a0d34-310">Por exemplo, se você tiver operações diárias que usam um objeto de blob com um carimbo de data/hora, como aaammdd, todo o tráfego para essa operação diária será direcionado para um único objeto, que é atendido por um servidor de partição única.</span><span class="sxs-lookup"><span data-stu-id="a0d34-310">For instance, if you have daily operations that use a blob object with a timestamp such as yyyymmdd, then all the traffic for that daily operation is directed to a single object which is served by a single partition server.</span></span> <span data-ttu-id="a0d34-311">Veja se os limites por blob e os limites por partição atendem às suas necessidades e considere a divisão dessa operação em vários blobs, se necessário.</span><span class="sxs-lookup"><span data-stu-id="a0d34-311">Look at whether the per blob limits and per partition limits meet your needs, and consider breaking this operation into multiple blobs if needed.</span></span> <span data-ttu-id="a0d34-312">Da mesma forma, se você armazenar os dados de série temporal em suas tabelas, todo o tráfego poderá ser direcionado para a última parte do namespace chave.</span><span class="sxs-lookup"><span data-stu-id="a0d34-312">Similarly, if you store time series data in your tables, all the traffic could be directed to the last part of the key namespace.</span></span> <span data-ttu-id="a0d34-313">Se você precisar usar carimbos de data/hora ou IDs numéricas, adicione um prefixo com um hash de três dígitos à ID ou, no caso de carimbos de data/hora, use um prefixo da parte de segundos da hora como ssaaaammdd.</span><span class="sxs-lookup"><span data-stu-id="a0d34-313">If you must use timestamps or numerical IDs, prefix the id with a 3-digit hash, or in the case of timestamps prefix the seconds part of the time such as ssyyyymmdd.</span></span> <span data-ttu-id="a0d34-314">Se as operações de listagem e de consulta forem executadas rotineiramente, escolha uma função de hash que limite o número de consultas.</span><span class="sxs-lookup"><span data-stu-id="a0d34-314">If listing and querying operations are routinely performed, choose a hashing function that will limit your number of queries.</span></span> <span data-ttu-id="a0d34-315">Em outros casos, um prefixo aleatório pode ser suficiente.</span><span class="sxs-lookup"><span data-stu-id="a0d34-315">In other cases, a random prefix may be sufficient.</span></span>  
* <span data-ttu-id="a0d34-316">Para obter informações adicionais sobre o esquema de particionamento usado no Armazenamento do Azure, leia o artigo SOSP [aqui](http://sigops.org/sosp/sosp11/current/2011-Cascais/printable/11-calder.pdf).</span><span class="sxs-lookup"><span data-stu-id="a0d34-316">For additional information on the partitioning scheme used in Azure Storage, read the SOSP paper [here](http://sigops.org/sosp/sosp11/current/2011-Cascais/printable/11-calder.pdf).</span></span>

### <a name="networking"></a><span data-ttu-id="a0d34-317">Rede</span><span class="sxs-lookup"><span data-stu-id="a0d34-317">Networking</span></span>
<span data-ttu-id="a0d34-318">Embora as chamadas de API sejam importantes, muitas vezes as limitações físicas da rede do aplicativo têm impacto considerável no desempenho.</span><span class="sxs-lookup"><span data-stu-id="a0d34-318">While the API calls matter, often the physical network constraints of the application have a significant impact on performance.</span></span> <span data-ttu-id="a0d34-319">A seção a seguir descreve algumas das limitações que os usuários podem enfrentar.</span><span class="sxs-lookup"><span data-stu-id="a0d34-319">The following describe some of limitations users may encounter.</span></span>  

#### <a name="client-network-capability"></a><span data-ttu-id="a0d34-320">Funcionalidade da rede do cliente</span><span class="sxs-lookup"><span data-stu-id="a0d34-320">Client Network Capability</span></span>
##### <span data-ttu-id="a0d34-321"><a name="subheading2"></a>Produtividade</span><span class="sxs-lookup"><span data-stu-id="a0d34-321"><a name="subheading2"></a>Throughput</span></span>
<span data-ttu-id="a0d34-322">No caso da largura de banda, muitas vezes o problema está relacionado às funcionalidades do cliente.</span><span class="sxs-lookup"><span data-stu-id="a0d34-322">For bandwidth, the problem is often the capabilities of the client.</span></span> <span data-ttu-id="a0d34-323">Por exemplo, embora uma única conta de armazenamento possa receber um fluxo de 10 Gbps ou mais (confira as [metas de escalabilidade da largura de banda](#sub1bandwidth)), a velocidade da rede em uma instância de função de trabalho "pequena" do Azure só consegue lidar com cerca de 100 Mbps.</span><span class="sxs-lookup"><span data-stu-id="a0d34-323">For example, while a single storage account can handle 10 Gbps or more of ingress (see [bandwidth scalability targets](#sub1bandwidth)), the network speed in a "Small" Azure Worker Role instance is only capable of approximately 100 Mbps.</span></span> <span data-ttu-id="a0d34-324">As instâncias maiores do Azure têm NICs com mais capacidade. Por isso, você pode usar uma instância maior ou mais VMs se precisar de limites de rede mais altos em um único computador.</span><span class="sxs-lookup"><span data-stu-id="a0d34-324">Larger Azure instances have NICs with greater capacity, so you should consider using a larger instance or more VM's if you need higher network limits from a single machine.</span></span> <span data-ttu-id="a0d34-325">Se você estiver acessando um serviço de armazenamento de um aplicativo no local, a mesma regra se aplica: compreender os recursos de rede do dispositivo do cliente e a conectividade de rede para o local de armazenamento do Azure e o aperfeiçoá-los conforme necessário ou projetar seu aplicativo para trabalhar dentro dos seus recursos.</span><span class="sxs-lookup"><span data-stu-id="a0d34-325">If you are accessing a Storage service from an on premises application, then the same rule applies: understand the network capabilities of the client device and the network connectivity to the Azure Storage location and either improve them as needed or design your application to work within their capabilities.</span></span>  

##### <span data-ttu-id="a0d34-326"><a name="subheading3"></a>Qualidade do vínculo</span><span class="sxs-lookup"><span data-stu-id="a0d34-326"><a name="subheading3"></a>Link Quality</span></span>
<span data-ttu-id="a0d34-327">Como é necessário com qualquer uso de rede, as condições de rede que resultam em erros e na perda de pacote desaceleram a taxa de transferência.</span><span class="sxs-lookup"><span data-stu-id="a0d34-327">As with any network usage, be aware that network conditions resulting in errors and packet loss will slow effective throughput.</span></span>  <span data-ttu-id="a0d34-328">Usar WireShark ou NetMon pode ajudar a identificar esse problema.</span><span class="sxs-lookup"><span data-stu-id="a0d34-328">Using WireShark or NetMon may help in diagnosing this issue.</span></span>  

##### <a name="useful-resources"></a><span data-ttu-id="a0d34-329">Recursos úteis</span><span class="sxs-lookup"><span data-stu-id="a0d34-329">Useful Resources</span></span>
<span data-ttu-id="a0d34-330">Para saber mais sobre os tamanhos de máquina virtual e sobre a largura de banda alocada, veja [Tamanhos de VM do Windows](../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) ou [Tamanhos de VM do Linux](../virtual-machines/linux/sizes.md?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).</span><span class="sxs-lookup"><span data-stu-id="a0d34-330">For more information about virtual machine sizes and allocated bandwidth, see [Windows VM sizes](../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) or [Linux VM sizes](../virtual-machines/linux/sizes.md?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).</span></span>  

#### <span data-ttu-id="a0d34-331"><a name="subheading4"></a>Local</span><span class="sxs-lookup"><span data-stu-id="a0d34-331"><a name="subheading4"></a>Location</span></span>
<span data-ttu-id="a0d34-332">Em todos os ambientes, colocar o cliente próximo ao servidor proporciona o melhor desempenho.</span><span class="sxs-lookup"><span data-stu-id="a0d34-332">In any distributed environment, placing the client near to the server delivers in the best performance.</span></span> <span data-ttu-id="a0d34-333">Para acessar o armazenamento do Azure com o mínimo de latência, o melhor local para o cliente é a região na qual o Azure se encontra.</span><span class="sxs-lookup"><span data-stu-id="a0d34-333">For accessing Azure Storage with the lowest latency, the best location for your client is within the same Azure region.</span></span> <span data-ttu-id="a0d34-334">Por exemplo, se você tem um site do Azure que usa o armazenamento do Azure, ambos devem estar na mesma região (por exemplo, no oeste dos EUA ou no sudeste asiático).</span><span class="sxs-lookup"><span data-stu-id="a0d34-334">For example, if you have an Azure Web Site that uses Azure Storage, you should locate them both within a single region (for example, US West or Asia Southeast).</span></span> <span data-ttu-id="a0d34-335">Isso diminui a latência e o custo. No momento da edição, o uso da largura de banda em uma única região é gratuito.</span><span class="sxs-lookup"><span data-stu-id="a0d34-335">This reduces the latency and the cost — at the time of writing, bandwidth usage within a single region is free.</span></span>  

<span data-ttu-id="a0d34-336">Se os aplicativos do seu cliente não estiverem hospedados no Azure (como no caso de aplicativos para dispositivos móveis ou serviços corporativos), colocar a conta de armazenamento próximo aos dispositivos que a conta acessará geralmente diminui a latência.</span><span class="sxs-lookup"><span data-stu-id="a0d34-336">If your client applications are not hosted within Azure (such as mobile device apps or on premises enterprise services), then again placing the storage account in a region near to the devices that will access it, will generally reduce latency.</span></span> <span data-ttu-id="a0d34-337">Se seus clientes estiverem amplamente distribuídos (por exemplo, alguns na América do Norte e alguns na Europa), você deve considerar o uso de várias contas de armazenamento: uma localizada em uma região na América do Norte e outra em uma região na Europa.</span><span class="sxs-lookup"><span data-stu-id="a0d34-337">If your clients are broadly distributed (for example, some in North America, and some in Europe), then you should consider using multiple storage accounts: one located in a North American region and one in a European region.</span></span> <span data-ttu-id="a0d34-338">Isso ajuda a diminuir a latência nas duas regiões.</span><span class="sxs-lookup"><span data-stu-id="a0d34-338">This will help to reduce latency for users in both regions.</span></span> <span data-ttu-id="a0d34-339">A implementação dessa solução geralmente é mais fácil se os dados armazenados pelo aplicativo são específicos aos usuários e se não é necessário replicar os dados entre as contas de armazenamento.</span><span class="sxs-lookup"><span data-stu-id="a0d34-339">This approach is usually easier to implement if the data the application stores is specific to individual users, and does not require replicating data between storage accounts.</span></span>  <span data-ttu-id="a0d34-340">Para uma ampla distribuição de conteúdo, recomendamos o uso de uma CDN. Confira a seção a seguir para saber mais detalhes.</span><span class="sxs-lookup"><span data-stu-id="a0d34-340">For broad content distribution, a CDN is recommended – see the next section for more details.</span></span>  

### <span data-ttu-id="a0d34-341"><a name="subheading5"></a>Distribuição de conteúdo</span><span class="sxs-lookup"><span data-stu-id="a0d34-341"><a name="subheading5"></a>Content Distribution</span></span>
<span data-ttu-id="a0d34-342">É possível que um aplicativo precise apresentar o mesmo conteúdo a muitos usuários (por exemplo, um vídeo para demonstrar um produto, apresentado na página inicial de um site) espalhados na mesma região ou em diversas regiões.</span><span class="sxs-lookup"><span data-stu-id="a0d34-342">Sometimes, an application needs to serve the same content to many users (e.g. a product demo video used in the home page of a website), located in either the same or multiple regions.</span></span> <span data-ttu-id="a0d34-343">Nesse cenário, você deve usar uma CDN (rede de distribuição de conteúdo), como o Azure CDN. Por sua vez, o CDN deve usar o armazenamento do Azure como fonte dos dados.</span><span class="sxs-lookup"><span data-stu-id="a0d34-343">In this scenario, you should use a Content Delivery Network (CDN) such as Azure CDN, and the CDN would use Azure storage as the origin of the data.</span></span> <span data-ttu-id="a0d34-344">Diferente das contas de armazenamento do Azure que existem em uma única região e não podem fornecer conteúdos com baixa latência a outras regiões, a CDN do Azure usa servidores em diversos data centers pelo mundo.</span><span class="sxs-lookup"><span data-stu-id="a0d34-344">Unlike an Azure Storage account that exists in a single region and that cannot deliver content with low latency to other regions, Azure CDN uses servers in multiple data centers around the world.</span></span> <span data-ttu-id="a0d34-345">Além disso, uma CDN geralmente tem limites de saída muito maiores do que as contas de armazenamento individuais.</span><span class="sxs-lookup"><span data-stu-id="a0d34-345">Additionally, a CDN can typically support much higher egress limits than a single storage account.</span></span>  

<span data-ttu-id="a0d34-346">Para obter mais informações, confira [CDN do Azure](https://azure.microsoft.com/services/cdn/).</span><span class="sxs-lookup"><span data-stu-id="a0d34-346">For more information about Azure CDN, see [Azure CDN](https://azure.microsoft.com/services/cdn/).</span></span>  

### <span data-ttu-id="a0d34-347"><a name="subheading6"></a>Usando SAS e CORS</span><span class="sxs-lookup"><span data-stu-id="a0d34-347"><a name="subheading6"></a>Using SAS and CORS</span></span>
<span data-ttu-id="a0d34-348">Quando você precisar autorizar o código como JavaScript no navegador da Web de um usuário ou um aplicativo de telefone celular para acessar dados no armazenamento do Azure, uma abordagem é usar um aplicativo em função Web como um proxy: autentica o dispositivo do usuário com a função Web, que por sua vez é autenticado com o serviço de armazenamento.</span><span class="sxs-lookup"><span data-stu-id="a0d34-348">When you need to authorize code such as JavaScript in a user's web browser or a mobile phone app to access data in Azure Storage, one approach is to use an application in web role as a proxy: the user's device authenticates with the web role, which in turn authenticates with the storage service.</span></span> <span data-ttu-id="a0d34-349">Dessa forma, você pode evitar a exposição das chaves de conta de armazenamento em dispositivos que não são seguros.</span><span class="sxs-lookup"><span data-stu-id="a0d34-349">In this way, you can avoid exposing your storage account keys on insecure devices.</span></span> <span data-ttu-id="a0d34-350">No entanto, isso gera uma grande sobrecarga na função Web porque todos os dados transferidos entre os dispositivos do usuário e o serviço de armazenamento devem ser transmitidos por meio de uma função Web.</span><span class="sxs-lookup"><span data-stu-id="a0d34-350">However, this places a big overhead on the web role because all the data transferred between the user's device and the storage service must pass through the web role.</span></span> <span data-ttu-id="a0d34-351">Você pode evitar o uso da função web como um proxy para o serviço de armazenamento. Para isso, use SAS (assinaturas de acesso compartilhado), que podem ser combinadas a cabeçalhos de CORS (compartilhamento de recursos entre origens).</span><span class="sxs-lookup"><span data-stu-id="a0d34-351">You can avoid using a web role as a proxy for the storage service by using Shared Access Signatures (SAS), sometimes in conjunction with Cross-Origin Resource Sharing headers (CORS).</span></span> <span data-ttu-id="a0d34-352">Por meio das SAS, você pode permitir que o dispositivo do usuário faça solicitações diretamente a um serviço de armazenamento por meio de um token de acesso limitado.</span><span class="sxs-lookup"><span data-stu-id="a0d34-352">Using SAS, you can allow your user's device to make requests directly to a storage service by means of a limited access token.</span></span> <span data-ttu-id="a0d34-353">Por exemplo, se o usuário quiser carregar uma foto no seu aplicativo, sua função Web poderá gerar e enviar um token SAS que conceda permissão de edição a um blob ou contêiner específico pelos próximos 30 minutos ao dispositivo do usuário (após esse período, o token expira).</span><span class="sxs-lookup"><span data-stu-id="a0d34-353">For example, if a user wants to upload a photo to your application, your web role can generate and send to the user's device a SAS token that grants permission to write to a specific blob or container for the next 30 minutes (after which the SAS token expires).</span></span>

<span data-ttu-id="a0d34-354">Normalmente, o navegador não permite o uso de JavaScript em páginas hospedadas por um site em um domínio para executar operações especificas, como um "PUT" em outro domínio.</span><span class="sxs-lookup"><span data-stu-id="a0d34-354">Normally, a browser will not allow JavaScript in a page hosted by a website on one domain to perform specific operations such as a "PUT" to another domain.</span></span> <span data-ttu-id="a0d34-355">Por exemplo, se você hospedar uma função Web em "contosomarketing.cloudapp.net" e quiser usar o JavaScript do cliente para carregar um blob em sua conta de armazenamento em "contosoproducts.blob.core.windows.net", a "política de mesma origem" proibirá essa operação.</span><span class="sxs-lookup"><span data-stu-id="a0d34-355">For example, if you host a web role at "contosomarketing.cloudapp.net," and want to use client side JavaScript to upload a blob to your storage account at "contosoproducts.blob.core.windows.net," the browser's "same origin policy" will forbid this operation.</span></span> <span data-ttu-id="a0d34-356">O CORS é um recurso do navegador que permite que o domínio alvo (neste caso, a conta de armazenamento) comunique-se com o navegador ao qual confia as solicitações que se originam no domínio de origem (neste caso, a função web).</span><span class="sxs-lookup"><span data-stu-id="a0d34-356">CORS is a browser feature that allows the target domain (in this case the storage account) to communicate to the browser that it trusts requests originating in the source domain (in this case the web role).</span></span>  

<span data-ttu-id="a0d34-357">As duas tecnologias podem ajudar você a evitar cargas e gargalos desnecessários no seu aplicativo Web.</span><span class="sxs-lookup"><span data-stu-id="a0d34-357">Both of these technologies can help you avoid unnecessary load (and bottlenecks) on your web application.</span></span>  

#### <a name="useful-resources"></a><span data-ttu-id="a0d34-358">Recursos úteis</span><span class="sxs-lookup"><span data-stu-id="a0d34-358">Useful Resources</span></span>
<span data-ttu-id="a0d34-359">Para obter mais informações sobre SAS, consulte [Assinaturas de acesso compartilhado, parte 1: entendendo o modelo SAS](storage-dotnet-shared-access-signature-part-1.md).</span><span class="sxs-lookup"><span data-stu-id="a0d34-359">For more information about SAS, see [Shared Access Signatures, Part 1: Understanding the SAS Model](storage-dotnet-shared-access-signature-part-1.md).</span></span>  

<span data-ttu-id="a0d34-360">Para saber mais sobre o CORS, consulte [Suporte a CORS (Compartilhamento de Recursos entre Origens) para os serviços de Armazenamento do Azure](http://msdn.microsoft.com/library/azure/dn535601.aspx).</span><span class="sxs-lookup"><span data-stu-id="a0d34-360">For more information about CORS, see [Cross-Origin Resource Sharing (CORS) Support for the Azure Storage Services](http://msdn.microsoft.com/library/azure/dn535601.aspx).</span></span>  

### <a name="caching"></a><span data-ttu-id="a0d34-361">Cache</span><span class="sxs-lookup"><span data-stu-id="a0d34-361">Caching</span></span>
#### <span data-ttu-id="a0d34-362"><a name="subheading7"></a>Obtenção de dados</span><span class="sxs-lookup"><span data-stu-id="a0d34-362"><a name="subheading7"></a>Getting Data</span></span>
<span data-ttu-id="a0d34-363">Em geral, obter os dados de um serviço uma única vez é melhor do que obtê-los duas vezes.</span><span class="sxs-lookup"><span data-stu-id="a0d34-363">In general, getting data from a service once is better than getting it twice.</span></span> <span data-ttu-id="a0d34-364">Tome como exemplo um aplicativo Web MVC em execução em uma função web que já recuperou um blob de 50 MB do serviço de armazenamento para apresentar ao usuário como conteúdo.</span><span class="sxs-lookup"><span data-stu-id="a0d34-364">Consider the example of an MVC web application running in a web role that has already retrieved a 50MB blob from the storage service to serve as content to a user.</span></span> <span data-ttu-id="a0d34-365">O aplicativo pode recuperar esse mesmo blob sempre que o usuário o solicitar, ou pode armazená-lo em cache localmente e reutilizar esse conteúdo em outras solicitações dos usuários.</span><span class="sxs-lookup"><span data-stu-id="a0d34-365">The application could then retrieve that same blob every time a user requests it, or it could cache it locally to disk and reuse the cached version for subsequent user requests.</span></span> <span data-ttu-id="a0d34-366">Além disso, sempre que um usuário solicitar os dados, o aplicativo pode emitir um GET com um cabeçalho condicional para tempo de modificação, o que evita obter todo o blob se ele não foi modificado.</span><span class="sxs-lookup"><span data-stu-id="a0d34-366">Furthermore, whenever a user requests the data, the application could issue GET with a conditional header for modification time, which would avoid getting the entire blob if it hasn't been modified.</span></span> <span data-ttu-id="a0d34-367">Você pode aplicar esse mesmo padrão ao trabalho com entidades em tabela.</span><span class="sxs-lookup"><span data-stu-id="a0d34-367">You can apply this same pattern to working with table entities.</span></span>  

<span data-ttu-id="a0d34-368">Em alguns casos, você pode determinar que seu aplicativo parta do pressuposto de que o blob permanece válido por um curto período após a recuperação e que, durante esse período, o aplicativo não precisa verificar se o blob foi modificado.</span><span class="sxs-lookup"><span data-stu-id="a0d34-368">In some cases, you may decide that your application can assume that the blob remains valid for a short period after retrieving it, and that during this period the application does not need to check if the blob was modified.</span></span>

<span data-ttu-id="a0d34-369">O armazenamento em cache é ótimo para configurações, pesquisas e outros dados que são sempre usados pelo aplicativo.</span><span class="sxs-lookup"><span data-stu-id="a0d34-369">Configuration, lookup, and other data that are always used by the application are great candidates for caching.</span></span>  

<span data-ttu-id="a0d34-370">Para saber como obter as propriedades de um blob e descobrir a data da última modificação usando o .NET, consulte [Definir e recuperar as propriedades e os metadados](storage-properties-metadata.md).</span><span class="sxs-lookup"><span data-stu-id="a0d34-370">For an example of how to get a blob's properties to discover the last modified date using .NET, see [Set and Retrieve Properties and Metadata](storage-properties-metadata.md).</span></span> <span data-ttu-id="a0d34-371">Para saber mais sobre downloads condicionais, consulte [Atualização condicional de uma cópia local de um blob](http://msdn.microsoft.com/library/azure/dd179371.aspx).</span><span class="sxs-lookup"><span data-stu-id="a0d34-371">For more information about conditional downloads, see [Conditionally Refresh a Local Copy of a Blob](http://msdn.microsoft.com/library/azure/dd179371.aspx).</span></span>  

#### <span data-ttu-id="a0d34-372"><a name="subheading8"></a>Carregamento de dados em lotes</span><span class="sxs-lookup"><span data-stu-id="a0d34-372"><a name="subheading8"></a>Uploading Data in Batches</span></span>
<span data-ttu-id="a0d34-373">Em algumas situações nos aplicativos, é possível agregar dados localmente e carregá-los em lotes em vez de carregar cada dado imediatamente.</span><span class="sxs-lookup"><span data-stu-id="a0d34-373">In some application scenarios, you can aggregate data locally, and then periodically upload it in a batch instead of uploading each piece of data immediately.</span></span> <span data-ttu-id="a0d34-374">Por exemplo, um aplicativo Web deve manter um arquivo de registro de atividades: o aplicativo pode enviar os detalhes de cada atividade assim que elas acontecem, como uma entidade de tabela (que requer muitas operações de armazenamento), ou pode salvar os detalhes da atividade em um arquivo de log local para carregar os detalhes de todas as atividades periodicamente, como um arquivo delimitado, em um blob.</span><span class="sxs-lookup"><span data-stu-id="a0d34-374">For example, a web application might keep a log file of activities: the application could either upload details of every activity as it happens as a table entity (which requires many storage operations), or it could save activity details to a local log file, and then periodically upload all activity details as a delimited file to a blob.</span></span> <span data-ttu-id="a0d34-375">Se cada entrada de log tiver 1 KB, você poderá carregar milhares de transações de um "blob de put" (é possível carregar um blob para transações individuais com até 64 MB).</span><span class="sxs-lookup"><span data-stu-id="a0d34-375">If each log entry is 1KB in size, you can upload thousands in a single "Put Blob" transaction (you can upload a blob of up to 64MB in size in a single transaction).</span></span> <span data-ttu-id="a0d34-376">É claro que, se o computador local falhar antes do carregamento, potencialmente perderá alguns dados de log: o desenvolvedor do aplicativo deve criar a possibilidade de dispositivo cliente ou falhas de carregamento.</span><span class="sxs-lookup"><span data-stu-id="a0d34-376">Of course, if the local machine crashes prior to the upload, you will potentially lose some log data: the application developer must design for the possibility of client device or upload failures.</span></span>  <span data-ttu-id="a0d34-377">Se for necessário carregar os dados das atividades para timespans (não apenas por atividade), os blobs são mais indicados do que as tabelas.</span><span class="sxs-lookup"><span data-stu-id="a0d34-377">If the activity data needs to be downloaded for timespans (not just single activity), then blobs are recommended over tables.</span></span>

### <a name="net-configuration"></a><span data-ttu-id="a0d34-378">Configuração .NET</span><span class="sxs-lookup"><span data-stu-id="a0d34-378">.NET Configuration</span></span>
<span data-ttu-id="a0d34-379">Esta seção é útil para quem usa o .NET Framework, pois lista diversas configurações rápidas que você pode usar para fazer melhorias significativas no desempenho.</span><span class="sxs-lookup"><span data-stu-id="a0d34-379">If using the .NET Framework, this section lists several quick configuration settings that you can use to make significant performance improvements.</span></span>  <span data-ttu-id="a0d34-380">Se estiver usando outras linguagens, verifique se conceitos parecidos aplicam-se à linguagem escolhida.</span><span class="sxs-lookup"><span data-stu-id="a0d34-380">If using other languages, check to see if similar concepts apply in your chosen language.</span></span>  

#### <span data-ttu-id="a0d34-381"><a name="subheading9"></a>Aumentar o limite de conexão padrão</span><span class="sxs-lookup"><span data-stu-id="a0d34-381"><a name="subheading9"></a>Increase default connection limit</span></span>
<span data-ttu-id="a0d34-382">No .NET, o código a seguir aumenta o limite de conexão de padrão (que geralmente é 2 em um ambiente de cliente ou 10 em um ambiente de servidor) a 100.</span><span class="sxs-lookup"><span data-stu-id="a0d34-382">In .NET, the following code increases the default connection limit (which is usually 2 in a client environment or 10 in a server environment) to 100.</span></span> <span data-ttu-id="a0d34-383">Normalmente, você deve definir o valor para aproximadamente igual ao número de threads utilizados pelo seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="a0d34-383">Typically, you should set the value to approximately the number of threads used by your application.</span></span>  

```csharp
ServicePointManager.DefaultConnectionLimit = 100; //(Or More)  
```

<span data-ttu-id="a0d34-384">Você deve definir o limite da conexão antes de abrir as conexões.</span><span class="sxs-lookup"><span data-stu-id="a0d34-384">You must set the connection limit before opening any connections.</span></span>  

<span data-ttu-id="a0d34-385">No caso de outras linguagens de programação, confira a documentação da linguagem para verificar como definir o limite da conexão.</span><span class="sxs-lookup"><span data-stu-id="a0d34-385">For other programming languages, see that language's documentation to determine how to set the connection limit.</span></span>  

<span data-ttu-id="a0d34-386">Para saber mais, consulte a postagem no blog [Serviços Web: conexões simultâneas](http://blogs.msdn.com/b/darrenj/archive/2005/03/07/386655.aspx).</span><span class="sxs-lookup"><span data-stu-id="a0d34-386">For additional information, see the blog post [Web Services: Concurrent Connections](http://blogs.msdn.com/b/darrenj/archive/2005/03/07/386655.aspx).</span></span>  

#### <span data-ttu-id="a0d34-387"><a name="subheading10"></a>Aumentar o mínimo dos Threads de ThreadPool, caso esteja usando código síncrono com tarefas assíncronas</span><span class="sxs-lookup"><span data-stu-id="a0d34-387"><a name="subheading10"></a>Increase ThreadPool Min Threads if using synchronous code with Async Tasks</span></span>
<span data-ttu-id="a0d34-388">Este código aumenta o mínimo de threads do pool de threads:</span><span class="sxs-lookup"><span data-stu-id="a0d34-388">This code will increase the thread pool min threads:</span></span>  

```csharp
ThreadPool.SetMinThreads(100,100); //(Determine the right number for your application)  
```

<span data-ttu-id="a0d34-389">Para saber mais, veja [Método ThreadPool.SetMinThreads](http://msdn.microsoft.com/library/system.threading.threadpool.setminthreads%28v=vs.110%29.aspx).</span><span class="sxs-lookup"><span data-stu-id="a0d34-389">For more information, see [ThreadPool.SetMinThreads Method](http://msdn.microsoft.com/library/system.threading.threadpool.setminthreads%28v=vs.110%29.aspx).</span></span>  

#### <span data-ttu-id="a0d34-390"><a name="subheading11"></a>Aproveitar a coleta de lixo do .NET 4.5</span><span class="sxs-lookup"><span data-stu-id="a0d34-390"><a name="subheading11"></a>Take advantage of .NET 4.5 Garbage Collection</span></span>
<span data-ttu-id="a0d34-391">Use a versão 4.5 ou posterior do .NET para que o aplicativo cliente aproveite as melhorias de desempenho na coleta de lixo do servidor.</span><span class="sxs-lookup"><span data-stu-id="a0d34-391">Use .NET 4.5 or later for the client application to take advantage of performance improvements in server garbage collection.</span></span>

<span data-ttu-id="a0d34-392">Para saber mais, consulte o artigo [Uma visão geral dos aprimoramentos de desempenho no .NET 4.5](http://msdn.microsoft.com/magazine/hh882452.aspx).</span><span class="sxs-lookup"><span data-stu-id="a0d34-392">For more information, see the article [An Overview of Performance Improvements in .NET 4.5](http://msdn.microsoft.com/magazine/hh882452.aspx).</span></span>  

### <span data-ttu-id="a0d34-393"><a name="subheading12"></a>Paralelismo não associado</span><span class="sxs-lookup"><span data-stu-id="a0d34-393"><a name="subheading12"></a>Unbounded Parallelism</span></span>
<span data-ttu-id="a0d34-394">Embora o paralelismo possa ser ótimo para o desempenho, tenha cuidado ao usar o paralelismo não associado (no qual não há limites para a quantidade de threads e/ou de solicitações paralelas) para carregar ou baixar dados, usando diversas funções de trabalho para acessar diversas partições (contêineres, filas ou tabelas) na mesma conta de armazenamento ou para acessar diversos itens na mesma partição.</span><span class="sxs-lookup"><span data-stu-id="a0d34-394">While parallelism can be great for performance, be careful about using unbounded parallelism (no limit on the number of threads and/or parallel requests) to upload or download data, using multiple workers to access multiple partitions (containers, queues, or table partitions) in the same storage account or to access multiple items in the same partition.</span></span> <span data-ttu-id="a0d34-395">Se o paralelismo não estiver associado, o aplicativo poderá ultrapassar as funcionalidades do dispositivo cliente ou as metas de escalabilidade da conta de armazenamento, o que resultará em limitação e latências mais longas.</span><span class="sxs-lookup"><span data-stu-id="a0d34-395">If the parallelism is unbounded, your application can exceed the client device's capabilities or the storage account's scalability targets resulting in longer latencies and throttling.</span></span>  

### <span data-ttu-id="a0d34-396"><a name="subheading13"></a>Ferramentas e bibliotecas cliente para armazenamento</span><span class="sxs-lookup"><span data-stu-id="a0d34-396"><a name="subheading13"></a>Storage Client Libraries and Tools</span></span>
<span data-ttu-id="a0d34-397">Sempre use a última versão das bibliotecas e ferramentas fornecidas pela Microsoft.</span><span class="sxs-lookup"><span data-stu-id="a0d34-397">Always use the latest Microsoft provided client libraries and tools.</span></span> <span data-ttu-id="a0d34-398">No momento da gravação, há bibliotecas cliente disponíveis para .NET, Windows Phone, Tempo de Execução do Windows, Java e C++, além de bibliotecas de visualização em outras linguagens.</span><span class="sxs-lookup"><span data-stu-id="a0d34-398">At the time of writing, there are client libraries available for .NET, Windows Phone, Windows Runtime, Java, and C++, as well as preview libraries for other languages.</span></span> <span data-ttu-id="a0d34-399">Além disso, a Microsoft liberou cmdlets do PowerShell e os comandos da CLI do Azure para trabalhar com o Armazenamento do Azure.</span><span class="sxs-lookup"><span data-stu-id="a0d34-399">In addition, Microsoft has released PowerShell cmdlets and Azure CLI commands for working with Azure Storage.</span></span> <span data-ttu-id="a0d34-400">A Microsoft desenvolve essas ferramentas pesando no desempenho, além de mantê-las atualizadas com as últimas versões do serviço e garantir que elas gerenciem muitas das práticas de desempenho comprovadas internamente.</span><span class="sxs-lookup"><span data-stu-id="a0d34-400">Microsoft actively develops these tools with performance in mind, keeps them up to date with the latest service versions, and ensures they handle many of the proven performance practices internally.</span></span>  

### <a name="retries"></a><span data-ttu-id="a0d34-401">Novas tentativas</span><span class="sxs-lookup"><span data-stu-id="a0d34-401">Retries</span></span>
#### <span data-ttu-id="a0d34-402"><a name="subheading14"></a>Limitação/Servidor ocupado</span><span class="sxs-lookup"><span data-stu-id="a0d34-402"><a name="subheading14"></a>Throttling/ServerBusy</span></span>
<span data-ttu-id="a0d34-403">Em alguns casos, o serviço de armazenamento pode restringir seu aplicativo ou simplesmente não conseguir atender uma solicitação devido a alguma condição transitória, retornando uma mensagem "503 Server busy" ou "500 Timeout".</span><span class="sxs-lookup"><span data-stu-id="a0d34-403">In some cases, the storage service may throttle your application or may simply be unable to serve the request due to some transient condition and return a "503 Server busy" message or "500 Timeout".</span></span>  <span data-ttu-id="a0d34-404">Isso pode acontecer se o aplicativo estiver alcançando alguma das metas de escalabilidade ou se o sistema estiver balanceando os dados particionados a fim de aumentar a taxa de transferência.</span><span class="sxs-lookup"><span data-stu-id="a0d34-404">This can happen if your application is approaching any of the scalability targets, or if the system is rebalancing your partitioned data to allow for higher throughput.</span></span>  <span data-ttu-id="a0d34-405">O aplicativo cliente normalmente deve tentar novamente a operação que gera um erro: a tentativa da mesma solicitação pode ser bem-sucedida mais tarde.</span><span class="sxs-lookup"><span data-stu-id="a0d34-405">The client application should typically retry the operation that causes such an error: attempting the same request later can succeed.</span></span> <span data-ttu-id="a0d34-406">No entanto, se o serviço de armazenamento estiver restringindo o aplicativo porque ele ultrapassou as metas de escalabilidade ou porque o serviço não pôde atender a solicitação por algum motivo, novas tentativas geralmente piorarão o problema.</span><span class="sxs-lookup"><span data-stu-id="a0d34-406">However, if the storage service is throttling your application because it is exceeding scalability targets, or even if the service was unable to serve the request for some other reason, aggressive retries usually make the problem worse.</span></span> <span data-ttu-id="a0d34-407">Por esse motivo, você deve usar uma retirada exponencial (as bibliotecas cliente são o padrão para esse comportamento).</span><span class="sxs-lookup"><span data-stu-id="a0d34-407">For this reason, you should use an exponential back off (the client libraries default to this behavior).</span></span> <span data-ttu-id="a0d34-408">Por exemplo, o aplicativo pode fazer uma nova tentativa em 2 segundos, 4 segundos, 10 segundos e 30 segundos para então abandonar o processo.</span><span class="sxs-lookup"><span data-stu-id="a0d34-408">For example, your application may retry after 2 seconds, then 4 seconds, then 10 seconds, then 30 seconds, and then give up completely.</span></span> <span data-ttu-id="a0d34-409">Esse comportamento faz com que o aplicativo diminua consideravelmente a sua carga no serviço, em vez de agravar qualquer problema.</span><span class="sxs-lookup"><span data-stu-id="a0d34-409">This behavior results in your application significantly reducing its load on the service rather than exacerbating any problems.</span></span>  

<span data-ttu-id="a0d34-410">Pode haver novas tentativas imediatas em caso de erros de conectividade porque esses erros não são resultado de restrições e devem ser temporários.</span><span class="sxs-lookup"><span data-stu-id="a0d34-410">Note that connectivity errors can be retried immediately, because they are not the result of throttling and are expected to be transient.</span></span>  

#### <span data-ttu-id="a0d34-411"><a name="subheading15"></a>Erros sem nova tentativa</span><span class="sxs-lookup"><span data-stu-id="a0d34-411"><a name="subheading15"></a>Non-Retryable Errors</span></span>
<span data-ttu-id="a0d34-412">As bibliotecas cliente sabem quais erros admitem novas tentativas ou não.</span><span class="sxs-lookup"><span data-stu-id="a0d34-412">The client libraries are aware of which errors are retry-able and which are not.</span></span> <span data-ttu-id="a0d34-413">No entanto, se você estiver escrevendo seu próprio código contra a API REST de armazenamento, lembre-se há alguns erros que você não deve tentar novamente: por exemplo, uma resposta 400 (solicitação incorreta) indica que o aplicativo cliente enviou uma solicitação que não pôde ser processada porque não estava no formato esperado.</span><span class="sxs-lookup"><span data-stu-id="a0d34-413">However, if you are writing your own code against the storage REST API, remember there are some errors that you should not retry: for example, a 400 (Bad Request) response indicates that the client application sent a request that could not be processed because it was not in an expected form.</span></span> <span data-ttu-id="a0d34-414">O reenvio dessa solicitação sempre resultará na mesma resposta, por isso as novas tentativas não são úteis.</span><span class="sxs-lookup"><span data-stu-id="a0d34-414">Resending this request will result the same response every time, so there is no point in retrying it.</span></span> <span data-ttu-id="a0d34-415">Se você está escrevendo o seu próprio código com base na API REST de armazenamento, conheça o significado de alguns erros e saiba o método adequado de fazer uma nova tentativa ou não para cada um deles.</span><span class="sxs-lookup"><span data-stu-id="a0d34-415">If you are writing your own code against the storage REST API, be aware of what the error codes mean and the proper way to retry (or not) for each of them.</span></span>  

#### <a name="useful-resources"></a><span data-ttu-id="a0d34-416">Recursos úteis</span><span class="sxs-lookup"><span data-stu-id="a0d34-416">Useful Resources</span></span>
<span data-ttu-id="a0d34-417">Para obter mais informações sobre os códigos de erro de armazenamento, confira [Status e códigos de erro](http://msdn.microsoft.com/library/azure/dd179382.aspx) no site do Microsoft Azure.</span><span class="sxs-lookup"><span data-stu-id="a0d34-417">For more information about storage error codes, see [Status and Error Codes](http://msdn.microsoft.com/library/azure/dd179382.aspx) on the Microsoft Azure web site.</span></span>  

## <a name="blobs"></a><span data-ttu-id="a0d34-418">Blobs</span><span class="sxs-lookup"><span data-stu-id="a0d34-418">Blobs</span></span>
<span data-ttu-id="a0d34-419">Além das práticas comprovadas para [todos os serviços](#allservices) descritos, as práticas comprovadas a seguir aplicam-se especificamente ao serviço blob.</span><span class="sxs-lookup"><span data-stu-id="a0d34-419">In addition to the proven practices for [All Services](#allservices) described previously, the following proven practices apply specifically to the blob service.</span></span>  

### <a name="blob-specific-scalability-targets"></a><span data-ttu-id="a0d34-420">Metas de escalabilidade específicas do blob</span><span class="sxs-lookup"><span data-stu-id="a0d34-420">Blob-Specific Scalability Targets</span></span>
#### <span data-ttu-id="a0d34-421"><a name="subheading46"></a>Vários clientes que acessam um único objeto simultaneamente</span><span class="sxs-lookup"><span data-stu-id="a0d34-421"><a name="subheading46"></a>Multiple clients accessing a single object concurrently</span></span>
<span data-ttu-id="a0d34-422">Se você tiver um grande número de clientes que acessem um único objeto simultaneamente, será preciso considerar as metas de escalabilidade de acordo com o objeto e a conta de armazenamento.</span><span class="sxs-lookup"><span data-stu-id="a0d34-422">If you have a large number of clients accessing a single object concurrently you will need to consider per object and storage account scalability targets.</span></span> <span data-ttu-id="a0d34-423">O número exato de clientes que podem acessar um único objeto vai variar de acordo com fatores como o número de clientes que solicitam o objeto simultaneamente, o tamanho do objeto, as condições da rede etc.</span><span class="sxs-lookup"><span data-stu-id="a0d34-423">The exact number of clients that can access a single object will vary depending on factors such as the number of clients requesting the object simultaneously, the size of the object, network conditions etc.</span></span>

<span data-ttu-id="a0d34-424">Se o objeto puder ser distribuído por meio de uma CDN, como imagens ou vídeos disponibilizados em um site, você poderá usar uma CDN.</span><span class="sxs-lookup"><span data-stu-id="a0d34-424">If the object can be distributed through a CDN such as images or videos served from a website then you should use a CDN.</span></span> <span data-ttu-id="a0d34-425">Consulte [aqui](#subheading5).</span><span class="sxs-lookup"><span data-stu-id="a0d34-425">See [here](#subheading5).</span></span>

<span data-ttu-id="a0d34-426">Em outros cenários, como simulações científicas, em que os dados são confidenciais, você tem duas opções.</span><span class="sxs-lookup"><span data-stu-id="a0d34-426">In other scenarios such as scientific simulations where the data is confidential you have two options.</span></span> <span data-ttu-id="a0d34-427">A primeira é escalonar o acesso à carga de trabalho, de modo que o objeto seja acessado por um período em vez de ser acessado simultaneamente.</span><span class="sxs-lookup"><span data-stu-id="a0d34-427">The first is to stagger your workload's access such that the object is accessed over a period of time vs being accessed simultaneously.</span></span> <span data-ttu-id="a0d34-428">Como alternativa, você pode copiar temporariamente o objeto para várias contas de armazenamento, aumentando assim o IOPS total por objeto e entre as contas de armazenamento.</span><span class="sxs-lookup"><span data-stu-id="a0d34-428">Alternatively, you can temporarily copy the object to multiple storage accounts thus increasing the total IOPS per object and across storage accounts.</span></span> <span data-ttu-id="a0d34-429">Em testes limitados, descobrimos que cerca de 25 VMs podem baixar simultaneamente um blob de 100 GB em paralelo (cada VM estava executando o download em paralelo usando 32 threads).</span><span class="sxs-lookup"><span data-stu-id="a0d34-429">In limited testing we found that around 25 VMs could simultaneously download a 100GB blob in parallel (each VM was parallelizing the download using 32 threads).</span></span> <span data-ttu-id="a0d34-430">No caso de 100 clientes precisando acessar o objeto, primeiro você o copiaria para uma segunda conta de armazenamento e, assim, teria as 50 primeiras VMs acessando o primeiro blob e as próximas 50 VMs acessando o segundo blob.</span><span class="sxs-lookup"><span data-stu-id="a0d34-430">If you had 100 clients needing to access the object, first copy it to a second storage account and then have the first 50 VMs access the first blob and the second 50 VMs access the second blob.</span></span> <span data-ttu-id="a0d34-431">Os resultados variam de acordo com o comportamento dos seus aplicativos e, portanto, você deve fazer testes durante o design.</span><span class="sxs-lookup"><span data-stu-id="a0d34-431">Results will vary depending on your applications behavior so you should test this during design.</span></span> 

#### <span data-ttu-id="a0d34-432"><a name="subheading16"></a>Largura de banda e operações por blob</span><span class="sxs-lookup"><span data-stu-id="a0d34-432"><a name="subheading16"></a>Bandwidth and operations per Blob</span></span>
<span data-ttu-id="a0d34-433">Você pode ler ou editar um único blob a no máximo 60 MB/segundo, o que equivale a 480 Mbps e ultrapassa a capacidade de muitas redes dos clientes, inclusive do NIC físico no dispositivo do cliente.</span><span class="sxs-lookup"><span data-stu-id="a0d34-433">You can read or write to a single blob at up to a maximum of 60 MB/second (this is approximately 480 Mbps which exceeds the capabilities of many client side networks (including the physical NIC on the client device).</span></span> <span data-ttu-id="a0d34-434">Além disso, um único blob comporta 500 solicitações por segundo.</span><span class="sxs-lookup"><span data-stu-id="a0d34-434">In addition, a single blob supports up to 500 requests per second.</span></span> <span data-ttu-id="a0d34-435">Se vários dos seus clientes precisarem ler os mesmo blob e você talvez ultrapasse esses limites, é possível usar uma CDN para distribuir o blob.</span><span class="sxs-lookup"><span data-stu-id="a0d34-435">If you have multiple clients that need to read the same blob and you might exceed these limits, you should consider using a CDN for distributing the blob.</span></span>  

<span data-ttu-id="a0d34-436">Para saber mais sobre a taxa de transferência alvo para os blobs, consulte [Metas de desempenho e escalabilidade do Armazenamento do Azure](storage-scalability-targets.md).</span><span class="sxs-lookup"><span data-stu-id="a0d34-436">For more information about target throughput for blobs, see [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md).</span></span>  

### <a name="copying-and-moving-blobs"></a><span data-ttu-id="a0d34-437">Copiando e movendo blobs</span><span class="sxs-lookup"><span data-stu-id="a0d34-437">Copying and Moving Blobs</span></span>
#### <span data-ttu-id="a0d34-438"><a name="subheading17"></a>Copiar blob</span><span class="sxs-lookup"><span data-stu-id="a0d34-438"><a name="subheading17"></a>Copy Blob</span></span>
<span data-ttu-id="a0d34-439">A versão 2012-02-12 da API REST do armazenamento introduziu a capacidade útil para copiar blobs entre contas: um aplicativo cliente pode instruir o serviço de armazenamento para copiar um blob de outra origem (possivelmente em outra conta de armazenamento) e permitir que o serviço de realizar a cópia de forma assíncrona.</span><span class="sxs-lookup"><span data-stu-id="a0d34-439">The storage REST API version 2012-02-12 introduced the useful ability to copy blobs across accounts: a client application can instruct the storage service to copy a blob from another source (possibly in a different storage account), and then let the service perform the copy asynchronously.</span></span> <span data-ttu-id="a0d34-440">Isso pode diminuir consideravelmente a largura de banda necessária para o aplicativo quando você estiver migrando dados de outras contas de armazenamento, porque você não precisará baixar nem carregar dados.</span><span class="sxs-lookup"><span data-stu-id="a0d34-440">This can significantly reduce the bandwidth needed for the application when you are migrating data from other storage accounts because you do not need to download and upload the data.</span></span>  

<span data-ttu-id="a0d34-441">No entanto, não é possível garantir em quanto tempo a cópia será concluída, ao se realizar cópias entre contas de armazenamento.</span><span class="sxs-lookup"><span data-stu-id="a0d34-441">One consideration, however, is that, when copying between storage accounts, there is no time guarantee on when the copy will complete.</span></span> <span data-ttu-id="a0d34-442">Se o aplicativo precisar copiar um blob completo rapidamente com a sua supervisão, pode ser melhor baixar o blob para uma máquina virtual e carregá-lo no destino.</span><span class="sxs-lookup"><span data-stu-id="a0d34-442">If your application needs to complete a blob copy quickly under your control, it may be better to copy the blob by downloading it to a VM and then uploading it to the destination.</span></span>  <span data-ttu-id="a0d34-443">Para que seja possível prever toda a situação, a cópia deve ser feita por uma máquina virtual em execução na mesma região do Azure, ou as condições da rede podem (e provavelmente irão) afetar o desempenho da cópia.</span><span class="sxs-lookup"><span data-stu-id="a0d34-443">For full predictability in that situation, ensure that the copy is performed by a VM running in the same Azure region, or else network conditions may (and probably will) affect your copy performance.</span></span>  <span data-ttu-id="a0d34-444">Além disso, você pode monitorar o progresso de uma cópia assíncrona de modo programático.</span><span class="sxs-lookup"><span data-stu-id="a0d34-444">In addition, you can monitor the progress of an asynchronous copy programmatically.</span></span>  

<span data-ttu-id="a0d34-445">As cópias da mesma conta de armazenamento geralmente são rápidas.</span><span class="sxs-lookup"><span data-stu-id="a0d34-445">Note that copies within the same storage account itself are generally completed quickly.</span></span>  

<span data-ttu-id="a0d34-446">Para saber mais, consulte [Copiar Blob](http://msdn.microsoft.com/library/azure/dd894037.aspx).</span><span class="sxs-lookup"><span data-stu-id="a0d34-446">For more information, see [Copy Blob](http://msdn.microsoft.com/library/azure/dd894037.aspx).</span></span>  

#### <span data-ttu-id="a0d34-447"><a name="subheading18"></a>Usar AzCopy</span><span class="sxs-lookup"><span data-stu-id="a0d34-447"><a name="subheading18"></a>Use AzCopy</span></span>
<span data-ttu-id="a0d34-448">A equipe de Armazenamento do Azure lançou a ferramenta de linha de comando, "AzCopy", destinada a ajudar na transferência em massa de muitos blobs para dentro, para fora e entre as contas de armazenamento.</span><span class="sxs-lookup"><span data-stu-id="a0d34-448">The Azure Storage team has released a command-line tool "AzCopy" that is meant to help with bulk transferring many blobs to, from, and across storage accounts.</span></span>  <span data-ttu-id="a0d34-449">Essa ferramenta foi otimizada para esse cenário e pode alcançar altas taxas de transferência.</span><span class="sxs-lookup"><span data-stu-id="a0d34-449">This tool is optimized for this scenario, and can achieve high transfer rates.</span></span>  <span data-ttu-id="a0d34-450">Ela deve ser usada para baixar e carregar itens, bem como para copiar cenários, em massa.</span><span class="sxs-lookup"><span data-stu-id="a0d34-450">Its use is encouraged for bulk upload, download, and copy scenarios.</span></span> <span data-ttu-id="a0d34-451">Para saber mais sobre ela e sobre como baixá-la, confira [Transferir dados com o utilitário de linha de comando AzCopy](storage-use-azcopy.md).</span><span class="sxs-lookup"><span data-stu-id="a0d34-451">To learn more about it and download it, see [Transfer data with the AzCopy Command-Line Utility](storage-use-azcopy.md).</span></span>  

#### <span data-ttu-id="a0d34-452"><a name="subheading19"></a>Serviço de importação/exportação do Azure</span><span class="sxs-lookup"><span data-stu-id="a0d34-452"><a name="subheading19"></a>Azure Import/Export Service</span></span>
<span data-ttu-id="a0d34-453">Para grandes volumes de dados (superiores a 1 TB), o armazenamento do Azure oferece o serviço de Importação/Exportação, que permite o carregamento e o download do armazenamento do blob por meio de discos rígidos.</span><span class="sxs-lookup"><span data-stu-id="a0d34-453">For very large volumes of data (more than 1TB), the Azure Storage offers the Import/Export service, which allows for uploading and downloading from blob storage by shipping hard drives.</span></span>  <span data-ttu-id="a0d34-454">Você pode colocar os dados em um disco rígido e enviá-lo à Microsoft para que possamos carregar esses dados ou enviar um disco rígido vazio para que baixemos os dados.</span><span class="sxs-lookup"><span data-stu-id="a0d34-454">You can put your data on a hard drive and send it to Microsoft for upload, or send a blank hard drive to Microsoft to download data.</span></span>  <span data-ttu-id="a0d34-455">Para saber mais, veja [Usar o serviço de Importação/Exportação do Microsoft Azure para transferir dados ao armazenamento Blob](storage-import-export-service.md).</span><span class="sxs-lookup"><span data-stu-id="a0d34-455">For more information, see [Use the Microsoft Azure Import/Export Service to Transfer Data to Blob Storage](storage-import-export-service.md).</span></span>  <span data-ttu-id="a0d34-456">Essa ação pode ser muito mais eficiente do que o envio/carregamento desse volume de dados pela rede.</span><span class="sxs-lookup"><span data-stu-id="a0d34-456">This can be much more efficient than uploading/downloading this volume of data over the network.</span></span>  

### <span data-ttu-id="a0d34-457"><a name="subheading20"></a>Uso de metadados</span><span class="sxs-lookup"><span data-stu-id="a0d34-457"><a name="subheading20"></a>Use metadata</span></span>
<span data-ttu-id="a0d34-458">O serviço do blob oferece suporte às principais solicitações, o que pode incluir metadados sobre o blob.</span><span class="sxs-lookup"><span data-stu-id="a0d34-458">The blob service supports head requests, which can include metadata about the blob.</span></span> <span data-ttu-id="a0d34-459">Por exemplo, se o aplicativo precisar remover os dados EXIF de uma fotografia, é possível recuperá-la e extrair esses dados.</span><span class="sxs-lookup"><span data-stu-id="a0d34-459">For example, if your application needed the EXIF data out of a photo, it could retrieve the photo and extract it.</span></span> <span data-ttu-id="a0d34-460">Para economizar largura de banda e melhorar o desempenho, seu aplicativo pode armazenar os dados EXIF nos metadados do blob quando o aplicativo tiver carregado a foto: você pode então recuperar os dados EXIF nos metadados usando apenas uma solicitação HEAD, economizando o tempo de processamento e largura de banda significativa necessários para extrair os dados EXIF cada vez o blob for lido.</span><span class="sxs-lookup"><span data-stu-id="a0d34-460">To save bandwidth and improve performance, your application could store the EXIF data in the blob's metadata when the application uploaded the photo: you can then retrieve the EXIF data in metadata using only a HEAD request, saving significant bandwidth and the processing time needed to extract the EXIF data each time the blob is read.</span></span> <span data-ttu-id="a0d34-461">Isso é útil quando você precisa apenas dos metadados, não do conteúdo completo do blob.</span><span class="sxs-lookup"><span data-stu-id="a0d34-461">This would be useful in scenarios where you only need the metadata, and not the full content of a blob.</span></span>  <span data-ttu-id="a0d34-462">Observe que é possível armazenar apenas 8 KB de metadados por blob (o serviço não aceita solicitações para armazenar volumes maiores). Se esse tamanho não for suficiente, talvez não seja possível usar essa abordagem.</span><span class="sxs-lookup"><span data-stu-id="a0d34-462">Note that only 8 KB of metadata can be stored per blob (the service will not accept a request to store more than that), so if the data does not fit in that size, you may not be able to use this approach.</span></span>  

<span data-ttu-id="a0d34-463">Para ver como obter os metadados de um blob usando .NET, consulte [Definir e recuperar as propriedades e os metadados](storage-properties-metadata.md).</span><span class="sxs-lookup"><span data-stu-id="a0d34-463">For an example of how to get a blob's metadata using .NET, see [Set and Retrieve Properties and Metadata](storage-properties-metadata.md).</span></span>  

### <a name="uploading-fast"></a><span data-ttu-id="a0d34-464">Carregamento rápido</span><span class="sxs-lookup"><span data-stu-id="a0d34-464">Uploading Fast</span></span>
<span data-ttu-id="a0d34-465">Para carregar blobs de forma rápida, a primeira pergunta a responder é: você está carregando um blob ou muitos?</span><span class="sxs-lookup"><span data-stu-id="a0d34-465">To upload blobs fast, the first question to answer is: are you uploading one blob or many?</span></span>  <span data-ttu-id="a0d34-466">Use as informações abaixo para identificar o método de uso correto de acordo com o seu cenário.</span><span class="sxs-lookup"><span data-stu-id="a0d34-466">Use the below guidance to determine the correct method to use depending on your scenario.</span></span>  

#### <span data-ttu-id="a0d34-467"><a name="subheading21"></a>Carregamento rápido de um blob grande</span><span class="sxs-lookup"><span data-stu-id="a0d34-467"><a name="subheading21"></a>Uploading one large blob quickly</span></span>
<span data-ttu-id="a0d34-468">Para carregar um único blob grande com rapidez, seu aplicativo cliente deve carregar os blocos ou as páginas em paralelo, levando em consideração as metas de escalabilidade para cada blob e a conta de armazenamento como um todo.</span><span class="sxs-lookup"><span data-stu-id="a0d34-468">To upload a single large blob quickly, your client application should upload its blocks or pages in parallel (being mindful of the scalability targets for individual blobs and the storage account as a whole).</span></span>  <span data-ttu-id="a0d34-469">As bibliotecas de cliente de armazenamento RTM fornecidas pela Microsoft (.NET e Java) têm a capacidade de fazer isso.</span><span class="sxs-lookup"><span data-stu-id="a0d34-469">Note that the official Microsoft-provided RTM Storage Client libraries (.NET, Java) have the ability to do this.</span></span>  <span data-ttu-id="a0d34-470">Para cada uma das bibliotecas, use a propriedade/o objeto especificado abaixo para definir o nível de simultaneidade:</span><span class="sxs-lookup"><span data-stu-id="a0d34-470">For each of the libraries, use the below specified object/property to set the level of concurrency:</span></span>  

* <span data-ttu-id="a0d34-471">.NET: defina ParallelOperationThreadCount em um objeto BlobRequestOptions a ser usado.</span><span class="sxs-lookup"><span data-stu-id="a0d34-471">.NET: Set ParallelOperationThreadCount on a BlobRequestOptions object to be used.</span></span>
* <span data-ttu-id="a0d34-472">Java/Android: usar BlobRequestOptions.setConcurrentRequestCount()</span><span class="sxs-lookup"><span data-stu-id="a0d34-472">Java/Android: Use BlobRequestOptions.setConcurrentRequestCount()</span></span>
* <span data-ttu-id="a0d34-473">Node.js: use parallelOperationThreadCount nas opções da solicitação ou no serviço Blob.</span><span class="sxs-lookup"><span data-stu-id="a0d34-473">Node.js: Use parallelOperationThreadCount on either the request options or on the blob service.</span></span>
* <span data-ttu-id="a0d34-474">C++: use o método blob_request_options::set_parallelism_factor.</span><span class="sxs-lookup"><span data-stu-id="a0d34-474">C++: Use the blob_request_options::set_parallelism_factor method.</span></span>

#### <span data-ttu-id="a0d34-475"><a name="subheading22"></a>Carregamento rápido de diversos blobs</span><span class="sxs-lookup"><span data-stu-id="a0d34-475"><a name="subheading22"></a>Uploading many blobs quickly</span></span>
<span data-ttu-id="a0d34-476">Para carregar diversos blobs com rapidez, carregue-os paralelamente.</span><span class="sxs-lookup"><span data-stu-id="a0d34-476">To upload many blobs quickly, upload blobs in parallel.</span></span> <span data-ttu-id="a0d34-477">Esse tipo de carregamento é mais rápido do que o carregamento de um único blob por vez com carregamento paralelo de blocos porque a carga é dividida em diversas partições do serviço de armazenamento.</span><span class="sxs-lookup"><span data-stu-id="a0d34-477">This is faster than uploading single blobs at a time with parallel block uploads because it spreads the upload across multiple partitions of the storage service.</span></span> <span data-ttu-id="a0d34-478">Cada blob dá suporte a uma taxa de transferência de 60 MB/segundo (aproximadamente, 480 Mbps).</span><span class="sxs-lookup"><span data-stu-id="a0d34-478">A single blob only supports a throughput of 60 MB/second (approximately 480 Mbps).</span></span> <span data-ttu-id="a0d34-479">No momento em que este artigo estava sendo escrito, uma conta LRS baseada em US dava suporte a até 20 Gbps de entrada, valor muito superior à produtividade suportada por um único blob.</span><span class="sxs-lookup"><span data-stu-id="a0d34-479">At the time of writing, a US-based LRS account supports up to 20 Gbps ingress which is far more than the throughput supported by an individual blob.</span></span>  <span data-ttu-id="a0d34-480">[AzCopy](#subheading18) executa os carregamentos em paralelo por padrão e é a opção recomendada nesse caso.</span><span class="sxs-lookup"><span data-stu-id="a0d34-480">[AzCopy](#subheading18) performs uploads in parallel by default, and is recommended for this scenario.</span></span>  

### <span data-ttu-id="a0d34-481"><a name="subheading23"></a>Escolhendo o tipo de blob certo</span><span class="sxs-lookup"><span data-stu-id="a0d34-481"><a name="subheading23"></a>Choosing the correct type of blob</span></span>
<span data-ttu-id="a0d34-482">O armazenamento do Azure oferece suporte a dois tipos de blob: blobs de *página* e blobs de *blocos*.</span><span class="sxs-lookup"><span data-stu-id="a0d34-482">Azure Storage supports two types of blob: *page* blobs and *block* blobs.</span></span> <span data-ttu-id="a0d34-483">Em um determinado cenário de uso, o tipo de blob escolhido afeta o desempenho e a escalabilidade da solução.</span><span class="sxs-lookup"><span data-stu-id="a0d34-483">For a given usage scenario, your choice of blob type will affect the performance and scalability of your solution.</span></span> <span data-ttu-id="a0d34-484">Os Blobs de bloco são apropriados quando você deseja carregar grandes quantidades de dados com eficiência: por exemplo, um aplicativo cliente pode precisar carregar fotos ou vídeo no armazenamento de blob.</span><span class="sxs-lookup"><span data-stu-id="a0d34-484">Block blobs are appropriate when you want to upload large amounts of data efficiently: for example, a client application may need to upload photos or video to blob storage.</span></span> <span data-ttu-id="a0d34-485">Os Blobs de página são apropriados, se o aplicativo precisa executar gravações aleatórias em dados: por exemplo, os VHDs do Azure são armazenados como blobs de página.</span><span class="sxs-lookup"><span data-stu-id="a0d34-485">Page blobs are appropriate if the application needs to perform random writes on the data: for example, Azure VHDs are stored as page blobs.</span></span>  

<span data-ttu-id="a0d34-486">Para saber mais, confira [Noções básicas sobre Blobs de bloco, Blobs de acréscimo e Blobs de página](http://msdn.microsoft.com/library/azure/ee691964.aspx).</span><span class="sxs-lookup"><span data-stu-id="a0d34-486">For more information, see [Understanding Block Blobs, Append Blobs, and Page Blobs](http://msdn.microsoft.com/library/azure/ee691964.aspx).</span></span>  

## <a name="tables"></a><span data-ttu-id="a0d34-487">Tabelas</span><span class="sxs-lookup"><span data-stu-id="a0d34-487">Tables</span></span>
<span data-ttu-id="a0d34-488">Além das práticas comprovadas para [todos os serviços](#allservices) descritos, as práticas comprovadas a seguir aplicam-se especificamente ao serviço de tabela.</span><span class="sxs-lookup"><span data-stu-id="a0d34-488">In addition to the proven practices for [All Services](#allservices) described previously, the following proven practices apply specifically to the table service.</span></span>  

### <span data-ttu-id="a0d34-489"><a name="subheading24"></a>Metas de escalabilidade específicas da tabela</span><span class="sxs-lookup"><span data-stu-id="a0d34-489"><a name="subheading24"></a>Table-Specific Scalability Targets</span></span>
<span data-ttu-id="a0d34-490">Além das limitações da largura de banda de toda uma conta de armazenamento, as tabelas têm o limite de escalabilidade descrito a seguir.</span><span class="sxs-lookup"><span data-stu-id="a0d34-490">In addition to the bandwidth limitations of an entire storage account, tables have the following specific scalability limit.</span></span>  <span data-ttu-id="a0d34-491">Observe que o sistema balanceia a carga conforme o tráfego aumento, mas se houver um pico de tráfego repentino, é possível que você não obtenha esse volume de taxa de transferência imediatamente.</span><span class="sxs-lookup"><span data-stu-id="a0d34-491">Note that the system will load balance as your traffic increases, but if your traffic has sudden bursts, you may not be able to get this volume of throughput immediately.</span></span>  <span data-ttu-id="a0d34-492">Se você normalmente presencia esses picos, haverá restrições e/ou eventos de tempo limite durante esses picos, pois o serviço de armazenamento balanceia a carga da tabela automaticamente.</span><span class="sxs-lookup"><span data-stu-id="a0d34-492">If your pattern has bursts, you should expect to see throttling and/or timeouts during the burst as the storage service automatically load balances out your table.</span></span>  <span data-ttu-id="a0d34-493">Os aumentos graduais geralmente apresentam resultados melhores, pois permitem que o sistema tenha tempo para balancear a carga corretamente.</span><span class="sxs-lookup"><span data-stu-id="a0d34-493">Ramping up slowly generally has better results as it gives the system time to load balance appropriately.</span></span>  

#### <a name="entities-per-second-account"></a><span data-ttu-id="a0d34-494">Entidades por segundo (conta)</span><span class="sxs-lookup"><span data-stu-id="a0d34-494">Entities per Second (Account)</span></span>
<span data-ttu-id="a0d34-495">O limite de escalabilidade para o acesso às tabelas é de até 20 mil entidades (1 KB para cada) por segundo em cada conta.</span><span class="sxs-lookup"><span data-stu-id="a0d34-495">The scalability limit for accessing tables is up to 20,000 entities (1KB each) per second for an account.</span></span>  <span data-ttu-id="a0d34-496">Em geral, cada entidade inserida, atualizada, excluída ou verificada é computada nessa meta.</span><span class="sxs-lookup"><span data-stu-id="a0d34-496">In general, each entity that is inserted, updated, deleted, or scanned counts toward this target.</span></span>  <span data-ttu-id="a0d34-497">Assim, uma inserção em lote com 100 entidades é computada como 100 entidades.</span><span class="sxs-lookup"><span data-stu-id="a0d34-497">So a batch insert that contains 100 entities would count as 100 entities.</span></span>  <span data-ttu-id="a0d34-498">Uma consulta que verifica 1000 entidades e retorna apenas 5 é computada como 1000 entidades.</span><span class="sxs-lookup"><span data-stu-id="a0d34-498">A query that scans 1000 entities and returns 5 would count as 1000 entities.</span></span>  

#### <a name="entities-per-second-partition"></a><span data-ttu-id="a0d34-499">Entidades por segundo (partição)</span><span class="sxs-lookup"><span data-stu-id="a0d34-499">Entities per Second (Partition)</span></span>
<span data-ttu-id="a0d34-500">Em uma única partição, a meta de escalabilidade para o acesso às tabelas é de 2000 entidades (1 KB para cada) por segundo, usando a mesma contagem descrita na seção anterior.</span><span class="sxs-lookup"><span data-stu-id="a0d34-500">Within a single partition, the scalability target for accessing tables is 2,000 entities (1KB each) per second, using the same counting as described in the previous section.</span></span>  

### <a name="configuration"></a><span data-ttu-id="a0d34-501">Configuração</span><span class="sxs-lookup"><span data-stu-id="a0d34-501">Configuration</span></span>
<span data-ttu-id="a0d34-502">Esta seção lista diversas configurações rápidas que você pode usar para fazer melhorias significativas no desempenho do serviço de tabela:</span><span class="sxs-lookup"><span data-stu-id="a0d34-502">This section lists several quick configuration settings that you can use to make significant performance improvements in the table service:</span></span>  

#### <span data-ttu-id="a0d34-503"><a name="subheading25"></a>Usar JSON</span><span class="sxs-lookup"><span data-stu-id="a0d34-503"><a name="subheading25"></a>Use JSON</span></span>
<span data-ttu-id="a0d34-504">Começando na versão 2013-08-15 do serviço de armazenamento, o serviço Tabela dá suporte ao uso de JSON, em vez do formato AtomPub baseado em XML, para transferir dados de tabela.</span><span class="sxs-lookup"><span data-stu-id="a0d34-504">Beginning with storage service version 2013-08-15, the table service supports using JSON instead of the XML-based AtomPub format for transferring table data.</span></span> <span data-ttu-id="a0d34-505">Isso pode reduzir o tamanho da carga em até 75% e pode melhorar consideravelmente o desempenho do seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="a0d34-505">This can reduce payload sizes by as much as 75% and can significantly improve the performance of your application.</span></span>

<span data-ttu-id="a0d34-506">Para saber mais, veja a postagem [Tabelas do Microsoft Azure: introdução ao JSON](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/05/windows-azure-tables-introducing-json.aspx) e [Formato de carga para operações do serviço Tabela](http://msdn.microsoft.com/library/azure/dn535600.aspx).</span><span class="sxs-lookup"><span data-stu-id="a0d34-506">For more information, see the post [Microsoft Azure Tables: Introducing JSON](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/05/windows-azure-tables-introducing-json.aspx) and [Payload Format for Table Service Operations](http://msdn.microsoft.com/library/azure/dn535600.aspx).</span></span>

#### <span data-ttu-id="a0d34-507"><a name="subheading26"></a>Desativação do Nagle</span><span class="sxs-lookup"><span data-stu-id="a0d34-507"><a name="subheading26"></a>Nagle Off</span></span>
<span data-ttu-id="a0d34-508">O algoritmo de Nagle é implementado largamente em redes TCP/IP como meio de melhorar o desempenho das redes.</span><span class="sxs-lookup"><span data-stu-id="a0d34-508">Nagle's algorithm is widely implemented across TCP/IP networks as a means to improve network performance.</span></span> <span data-ttu-id="a0d34-509">No entanto, ele não é ideal em todas as circunstâncias (como em ambientes altamente interativos).</span><span class="sxs-lookup"><span data-stu-id="a0d34-509">However, it is not optimal in all circumstances (such as highly interactive environments).</span></span> <span data-ttu-id="a0d34-510">No caso do armazenamento do Azure, o algoritmo do Nagle tem um impacto negativo sobre o desempenho das solicitações para a tabela e os serviços de fila. Por isso, desabilite-o se possível.</span><span class="sxs-lookup"><span data-stu-id="a0d34-510">For Azure Storage, Nagle's algorithm has a negative impact on the performance of requests to the table and queue services, and you should disable it if possible.</span></span>  

<span data-ttu-id="a0d34-511">Para obter mais informações, confira a postagem [Nagle’s Algorithm is Not Friendly towards Small Requests](http://blogs.msdn.com/b/windowsazurestorage/archive/2010/06/25/nagle-s-algorithm-is-not-friendly-towards-small-requests.aspx) (O algoritmo de Nagle não é adequado para solicitações pequenas) no nosso blog, que explica por que esse algoritmo tem baixo desempenho na interação com solicitações de tabela e fila, além de mostrar como desabilitá-lo no seu aplicativo cliente.</span><span class="sxs-lookup"><span data-stu-id="a0d34-511">For more information, see our blog post [Nagle's Algorithm is Not Friendly towards Small Requests](http://blogs.msdn.com/b/windowsazurestorage/archive/2010/06/25/nagle-s-algorithm-is-not-friendly-towards-small-requests.aspx), which explains why Nagle's algorithm interacts poorly with table and queue requests, and shows how to disable it in your client application.</span></span>  

### <a name="schema"></a><span data-ttu-id="a0d34-512">Esquema</span><span class="sxs-lookup"><span data-stu-id="a0d34-512">Schema</span></span>
<span data-ttu-id="a0d34-513">Como você representa e consulta os seus dados é o maior fator único que afeta o desempenho do serviço de tabela.</span><span class="sxs-lookup"><span data-stu-id="a0d34-513">How you represent and query your data is the biggest single factor that affects the performance of the table service.</span></span> <span data-ttu-id="a0d34-514">Embora cada aplicativo seja único, esta seção descreve algumas práticas gerais comprovadas relacionadas:</span><span class="sxs-lookup"><span data-stu-id="a0d34-514">While every application is different, this section outlines some general proven practices that relate to:</span></span>  

* <span data-ttu-id="a0d34-515">Ao design da tabela</span><span class="sxs-lookup"><span data-stu-id="a0d34-515">Table design</span></span>
* <span data-ttu-id="a0d34-516">A consultas eficientes</span><span class="sxs-lookup"><span data-stu-id="a0d34-516">Efficient queries</span></span>
* <span data-ttu-id="a0d34-517">A atualizações de dados eficientes</span><span class="sxs-lookup"><span data-stu-id="a0d34-517">Efficient data updates</span></span>  

#### <span data-ttu-id="a0d34-518"><a name="subheading27"></a>Tabelas e partições</span><span class="sxs-lookup"><span data-stu-id="a0d34-518"><a name="subheading27"></a>Tables and partitions</span></span>
<span data-ttu-id="a0d34-519">As tabelas são divididas em partições.</span><span class="sxs-lookup"><span data-stu-id="a0d34-519">Tables are divided into partitions.</span></span> <span data-ttu-id="a0d34-520">Cada entidade armazenada em uma partição compartilha a mesma chave de partição e tem uma chave de linha exclusiva que a identifica dentro da partição em questão.</span><span class="sxs-lookup"><span data-stu-id="a0d34-520">Every entity stored in a partition shares the same partition key and has a unique row key to identify it within that partition.</span></span> <span data-ttu-id="a0d34-521">As partições trazem benefícios, mas também criam limites de escalabilidade.</span><span class="sxs-lookup"><span data-stu-id="a0d34-521">Partitions provide benefits but also introduce scalability limits.</span></span>  

* <span data-ttu-id="a0d34-522">Benefícios: você pode atualizar as entidades em uma única transação atômica e em lote que contenha até 100 operações de armazenamento independentes (limite total de 4 MB).</span><span class="sxs-lookup"><span data-stu-id="a0d34-522">Benefits: You can update entities in the same partition in a single, atomic, batch transaction that contains up to 100 separate storage operations (limit of 4MB total size).</span></span> <span data-ttu-id="a0d34-523">Partindo do pressuposto de que a mesma quantidade de entidades pode ser recuperada, você também pode consultar dados em uma única partição com mais eficiência do que a consulta a dados presentes em diversas partições (consulte as demais recomendações sobre consulta aos dados das tabelas).</span><span class="sxs-lookup"><span data-stu-id="a0d34-523">Assuming the same number of entities to be retrieved, you can also query data within a single partition more efficiently than data that spans partitions (though read on for further recommendations on querying table data).</span></span>
* <span data-ttu-id="a0d34-524">Limite de escalabilidade: o acesso às entidades armazenadas em uma única partição não pode passar por balanceamento de carga porque as partições dão suporte a transações atômicas em lote.</span><span class="sxs-lookup"><span data-stu-id="a0d34-524">Scalability limit: Access to entities stored in a single partition cannot be load-balanced because partitions support atomic batch transactions.</span></span> <span data-ttu-id="a0d34-525">Por esse motivo, a meta de escalabilidade de cada partição da tabela é menor do que a meta do serviço Tabela como um todo.</span><span class="sxs-lookup"><span data-stu-id="a0d34-525">For this reason, the scalability target for an individual table partition is lower than for the table service as a whole.</span></span>  

<span data-ttu-id="a0d34-526">Devido a essas características, você deve adotar estes princípios de design:</span><span class="sxs-lookup"><span data-stu-id="a0d34-526">Because of these characteristics of tables and partitions, you should adopt the following design principles:</span></span>  

* <span data-ttu-id="a0d34-527">Os dados atualizados ou consultados com frequência por seu aplicativo cliente na mesma unidade de trabalho lógica devem constar na mesma partição.</span><span class="sxs-lookup"><span data-stu-id="a0d34-527">Data that your client application frequently updated or queried in the same logical unit of work should be located in the same partition.</span></span>  <span data-ttu-id="a0d34-528">Isso pode acontecer porque seu aplicativo agrega edições ou porque você que aproveitar a vantagem das operações atômicas em lote.</span><span class="sxs-lookup"><span data-stu-id="a0d34-528">This may be because your application is aggregating writes, or because you want to take advantage of atomic batch operations.</span></span>  <span data-ttu-id="a0d34-529">Além disso, é possível consultar os dados em uma única partição com mais eficiência do que fazer a consulta em diversas partições.</span><span class="sxs-lookup"><span data-stu-id="a0d34-529">Also, data in a single partition can be more efficiently queried in a single query than data across partitions.</span></span>
* <span data-ttu-id="a0d34-530">Os dados não inseridos/atualizados ou consultados com frequência por seu aplicativo cliente na mesma unidade de trabalho lógica (consulta única ou atualização em lote) devem constar em partições diferentes.</span><span class="sxs-lookup"><span data-stu-id="a0d34-530">Data that your client application does not insert/update or query in the same logical unit of work (single query or batch update) should be located in separate partitions.</span></span>  <span data-ttu-id="a0d34-531">Uma observação importante é que não há limite de chaves de partição para uma única tabela. Por isso, ter milhões de chaves de partição não representa um problema e não influencia o desempenho.</span><span class="sxs-lookup"><span data-stu-id="a0d34-531">One important note is that there is no limit to the number of partition keys in a single table, so having millions of partition keys is not a problem and will not impact performance.</span></span>  <span data-ttu-id="a0d34-532">Por exemplo, se seu aplicativo é um site popular que requer o logon dos usuários, usar a ID do usuário como chave de partição pode ser uma boa opção.</span><span class="sxs-lookup"><span data-stu-id="a0d34-532">For example, if your application is a popular website with user login, using the User Id as the partition key could be a good choice.</span></span>  

#### <a name="hot-partitions"></a><span data-ttu-id="a0d34-533">Partições mais acessadas</span><span class="sxs-lookup"><span data-stu-id="a0d34-533">Hot Partitions</span></span>
<span data-ttu-id="a0d34-534">As partições mais acessadas são aquelas que recebem um porcentual desproporcional do tráfego de uma conta e não podem passar pelo balanceamento de carga porque se trata de uma única partição.</span><span class="sxs-lookup"><span data-stu-id="a0d34-534">A hot partition is one that is receiving a disproportionate percentage of the traffic to an account, and cannot be load balanced because it is a single partition.</span></span>  <span data-ttu-id="a0d34-535">Em geral, essas partições são criadas de duas formas:</span><span class="sxs-lookup"><span data-stu-id="a0d34-535">In general, hot partitions are created one of two ways:</span></span>  

##### <span data-ttu-id="a0d34-536"><a name="subheading28"></a>Padrões somente anexar e somente incluir</span><span class="sxs-lookup"><span data-stu-id="a0d34-536"><a name="subheading28"></a>Append Only and Prepend Only patterns</span></span>
<span data-ttu-id="a0d34-537">No padrão "somente anexar", todo (ou praticamente todo) o tráfego atribuído a um determinado PK aumenta e diminui de acordo com o momento.</span><span class="sxs-lookup"><span data-stu-id="a0d34-537">The "Append Only" pattern is one where all (or nearly all) of the traffic to a given PK increases and decreases according to the current time.</span></span>  <span data-ttu-id="a0d34-538">Um exemplo é se o aplicativo usado na data funciona como chave de partição para os dados do log.</span><span class="sxs-lookup"><span data-stu-id="a0d34-538">An example is if your application used the current date as a partition key for log data.</span></span>  <span data-ttu-id="a0d34-539">Isso faz com que todas as inserções vão para a última partição da sua tabela. O sistema não pode balancear a carga porque todas as edições vão em direção ao final da tabela.</span><span class="sxs-lookup"><span data-stu-id="a0d34-539">This results in all of the inserts going to the last partition in your table, and the system cannot load balance because all of the writes are going to the end of your table.</span></span>  <span data-ttu-id="a0d34-540">Se o volume do tráfego para a partição em questão ultrapassar a meta de escalabilidade na partição, teremos restrições como resultado.</span><span class="sxs-lookup"><span data-stu-id="a0d34-540">If the volume of traffic to that partition exceeds the partition-level scalability target, then it will result in throttling.</span></span>  <span data-ttu-id="a0d34-541">É melhor garantir que o tráfego seja enviado para diversas partições, a fim de garantir o balanceamento da carga das solicitações na tabela.</span><span class="sxs-lookup"><span data-stu-id="a0d34-541">It's better to ensure that traffic is sent to multiple partitions, to enable load balance the requests across your table.</span></span>  

##### <span data-ttu-id="a0d34-542"><a name="subheading29"></a>Dados de tráfego intenso</span><span class="sxs-lookup"><span data-stu-id="a0d34-542"><a name="subheading29"></a>High-Traffic Data</span></span>
<span data-ttu-id="a0d34-543">Se você estiver particionando resultados de esquemas em uma única partição que tem dados mais usados do os dados presentes nas demais partições, também pode haver restrições, pois a partição em questão aproxima-se da meta de escalabilidade de uma única partição.</span><span class="sxs-lookup"><span data-stu-id="a0d34-543">If your partitioning scheme results in a single partition that just has data that is far more used than other partitions, you may also see throttling as that partition approaches the scalability target for a single partition.</span></span>  <span data-ttu-id="a0d34-544">É melhor garantir que seu esquema de partição não faça com que nenhuma partição específica aproxime-se das metas de escalabilidade.</span><span class="sxs-lookup"><span data-stu-id="a0d34-544">It's better to make sure that your partition scheme results in no single partition approaching the scalability targets.</span></span>  

#### <a name="querying"></a><span data-ttu-id="a0d34-545">Consultas</span><span class="sxs-lookup"><span data-stu-id="a0d34-545">Querying</span></span>
<span data-ttu-id="a0d34-546">Esta seção descreve as práticas comprovadas de consulta do serviço Tabela.</span><span class="sxs-lookup"><span data-stu-id="a0d34-546">This section describes proven practices for querying the table service.</span></span>  

##### <span data-ttu-id="a0d34-547"><a name="subheading30"></a>Escopo de consulta</span><span class="sxs-lookup"><span data-stu-id="a0d34-547"><a name="subheading30"></a>Query Scope</span></span>
<span data-ttu-id="a0d34-548">Há diversas maneiras de especificar quais entidades devem ser consultadas.</span><span class="sxs-lookup"><span data-stu-id="a0d34-548">There are several ways to specify the range of entities to query.</span></span>  <span data-ttu-id="a0d34-549">A seguir, tratamos do uso de cada uma delas.</span><span class="sxs-lookup"><span data-stu-id="a0d34-549">The following is a discussion of the uses of each.</span></span>  

<span data-ttu-id="a0d34-550">Em geral, evite as verificações (consultas cujo escopo tem mais de uma entidade). No entanto, se a verificação for necessária, tente organizar os dados de modo que as verificações recuperem os dados necessários sem verificar ou retornar grandes quantidades de entidades desnecessárias.</span><span class="sxs-lookup"><span data-stu-id="a0d34-550">In general, avoid scans (queries larger than a single entity), but if you must scan, try to organize your data so that your scans retrieve the data you need without scanning or returning significant amounts of entities you don't need.</span></span>  

###### <a name="point-queries"></a><span data-ttu-id="a0d34-551">Consultas pontuais</span><span class="sxs-lookup"><span data-stu-id="a0d34-551">Point Queries</span></span>
<span data-ttu-id="a0d34-552">A consulta recupera exatamente uma entidade.</span><span class="sxs-lookup"><span data-stu-id="a0d34-552">A point query retrieves exactly one entity.</span></span> <span data-ttu-id="a0d34-553">Ela faz isso por meio da especificação da chave de partição e da chave de linha da entidade a ser recuperada.</span><span class="sxs-lookup"><span data-stu-id="a0d34-553">It does this by specifying both the partition key and row key of the entity to retrieve.</span></span> <span data-ttu-id="a0d34-554">Essas consultas são muito eficientes e você deve usá-las sempre que possível.</span><span class="sxs-lookup"><span data-stu-id="a0d34-554">These queries are very efficient, and you should use them wherever possible.</span></span>  

###### <a name="partition-queries"></a><span data-ttu-id="a0d34-555">Consultas às partições</span><span class="sxs-lookup"><span data-stu-id="a0d34-555">Partition Queries</span></span>
<span data-ttu-id="a0d34-556">Esse tipo de consulta recupera um conjunto de dados que tem uma chave de partição em comum.</span><span class="sxs-lookup"><span data-stu-id="a0d34-556">A partition query is a query that retrieves a set of data that shares a common partition key.</span></span> <span data-ttu-id="a0d34-557">Geralmente, a consulta especifica diversos valores de chave de linha ou valores de propriedade de entidade, além de uma chave de partição.</span><span class="sxs-lookup"><span data-stu-id="a0d34-557">Typically, the query specifies a range of row key values or a range of values for some entity property in addition to a partition key.</span></span> <span data-ttu-id="a0d34-558">Elas são menos eficientes do que as consultas pontuais e devem ser usados com critério.</span><span class="sxs-lookup"><span data-stu-id="a0d34-558">These are less efficient than point queries, and should be used sparingly.</span></span>  

###### <a name="table-queries"></a><span data-ttu-id="a0d34-559">Consultas às tabelas</span><span class="sxs-lookup"><span data-stu-id="a0d34-559">Table Queries</span></span>
<span data-ttu-id="a0d34-560">Esse tipo de consulta recupera um conjunto de entidades que não tem uma chave de partição em comum.</span><span class="sxs-lookup"><span data-stu-id="a0d34-560">A table query is a query that retrieves a set of entities that does not share a common partition key.</span></span> <span data-ttu-id="a0d34-561">Essas consultas não são eficientes e você deve evitá-las sempre que possível.</span><span class="sxs-lookup"><span data-stu-id="a0d34-561">These queries are not efficient and you should avoid them if possible.</span></span>  

##### <span data-ttu-id="a0d34-562"><a name="subheading31"></a>Densidade de consulta</span><span class="sxs-lookup"><span data-stu-id="a0d34-562"><a name="subheading31"></a>Query Density</span></span>
<span data-ttu-id="a0d34-563">Outro fator importante na eficiência da consulta é a quantidade de entidades retornadas, em comparação à quantidade de entidades verificadas para localizar o conjunto retornado.</span><span class="sxs-lookup"><span data-stu-id="a0d34-563">Another key factor in query efficiency is the number of entities returned as compared to the number of entities scanned to find the returned set.</span></span> <span data-ttu-id="a0d34-564">Se o aplicativo ficar uma consulta de tabela filtrando por um valor da propriedade comum a apenas 1% dos dados, a consulta verificará 100 entidades para cada entidade retornada.</span><span class="sxs-lookup"><span data-stu-id="a0d34-564">If your application performs a table query with a filter for a property value that only 1% of the data shares, the query will scan 100 entities for every one entity it returns.</span></span> <span data-ttu-id="a0d34-565">As metas de escalabilidade de tabela discutidas anteriormente se relacionam ao número de entidades verificado e não o número de entidades retornadas: uma densidade de consulta baixa pode facilmente fazer com que o serviço Tabela acelere seu aplicativo porque ele deve verificar muitas entidades para recuperar a entidade que você está procurando.</span><span class="sxs-lookup"><span data-stu-id="a0d34-565">The table scalability targets discussed previously all relate to the number of entities scanned, and not the number of entities returned: a low query density can easily cause the table service to throttle your application because it must scan so many entities to retrieve the entity you are looking for.</span></span>  <span data-ttu-id="a0d34-566">Confira a seção abaixo sobre [desnormalização](#subheading34) para obter mais informações sobre como evitar isso.</span><span class="sxs-lookup"><span data-stu-id="a0d34-566">See the section below on [denormalization](#subheading34) for more information on how to avoid this.</span></span>  

##### <a name="limiting-the-amount-of-data-returned"></a><span data-ttu-id="a0d34-567">Limitação da quantidade de dados retornados</span><span class="sxs-lookup"><span data-stu-id="a0d34-567">Limiting the Amount of Data Returned</span></span>
###### <span data-ttu-id="a0d34-568"><a name="subheading32"></a>Filtragem</span><span class="sxs-lookup"><span data-stu-id="a0d34-568"><a name="subheading32"></a>Filtering</span></span>
<span data-ttu-id="a0d34-569">Quando souber que uma consulta retornará entidades desnecessárias no aplicativo cliente, você poderá usar um filtro para diminuir a quantidade de entradas retornadas.</span><span class="sxs-lookup"><span data-stu-id="a0d34-569">Where you know that a query will return entities that you don't need in the client application, consider using a filter to reduce the size of the returned set.</span></span> <span data-ttu-id="a0d34-570">Embora as entidades não retornadas para o cliente ainda sejam computadas nos limites de escalabilidade, o desempenho do aplicativo melhora devido à redução no tamanho da carga da rede e na quantidade de entidades que seu aplicativo cliente deve processar.</span><span class="sxs-lookup"><span data-stu-id="a0d34-570">While the entities not returned to the client still count toward the scalability limits, your application performance will improve because of the reduced network payload size and the reduced number of entities that your client application must process.</span></span>  <span data-ttu-id="a0d34-571">Confira a observação acima sobre a [Densidade da Consulta](#subheading31), mas lembre-se de que as metas de escalabilidade estão relacionadas à quantidade de entidades verificadas. Por isso, as consultas que filtram muitas entidades podem resultar em restrições, mesmo se poucas entidades forem retornadas.</span><span class="sxs-lookup"><span data-stu-id="a0d34-571">See above note on [Query Density](#subheading31), however – the scalability targets relate to the number of entities scanned, so a query that filters out many entities may still result in throttling, even if few entities are returned.</span></span>  

###### <span data-ttu-id="a0d34-572"><a name="subheading33"></a>Projeção</span><span class="sxs-lookup"><span data-stu-id="a0d34-572"><a name="subheading33"></a>Projection</span></span>
<span data-ttu-id="a0d34-573">Se seu aplicativo clientes precisar apenas de um conjunto limitado de propriedades das entidades da sua tabela, você pode usar a projeção para limitar o tamanho do conjunto de dados retornado.</span><span class="sxs-lookup"><span data-stu-id="a0d34-573">If your client application needs only a limited set of properties from the entities in your table, you can use projection to limit the size of the returned data set.</span></span> <span data-ttu-id="a0d34-574">Como no caso da filtragem, isso ajuda a diminuir a carga da rede e o processamento do cliente.</span><span class="sxs-lookup"><span data-stu-id="a0d34-574">As with filtering, this helps to reduce network load and client processing.</span></span>  

##### <span data-ttu-id="a0d34-575"><a name="subheading34"></a>Desnormalização</span><span class="sxs-lookup"><span data-stu-id="a0d34-575"><a name="subheading34"></a>Denormalization</span></span>
<span data-ttu-id="a0d34-576">Diferente do que acontece com os bancos de dados relacionados, as práticas recomentadas para consultar os dados da tabela com eficiência causam a desnormalização dos dados.</span><span class="sxs-lookup"><span data-stu-id="a0d34-576">Unlike working with relational databases, the proven practices for efficiently querying table data lead to denormalizing your data.</span></span> <span data-ttu-id="a0d34-577">Ou seja, a duplicação dos mesmos dados em diversas entidades (uma para cada chave, que você pode usar para localizar os dados) para minimizar a quantidade de entidades a serem verificadas por uma consulta para localizar os dados necessários para o cliente, em vez de precisar verificar muitas entidades para localizar os dados necessários para o aplicativo.</span><span class="sxs-lookup"><span data-stu-id="a0d34-577">That is, duplicating the same data in multiple entities (one for each key you may use to find the data) to minimize the number of entities that a query must scan to find the data the client needs, rather than having to scan large numbers of entities to find the data your application needs.</span></span>  <span data-ttu-id="a0d34-578">Por exemplo, em um site de comércio eletrônico, você pode querer localizar um pedido pela ID do cliente (apresentar os pedidos de um determinado cliente) e por data (apresentar os pedidos de uma determinada data).</span><span class="sxs-lookup"><span data-stu-id="a0d34-578">For example, in an e-commerce website, you may want to find an order both by the customer ID (give me this customer's orders) and by the date (give me orders on a date).</span></span>  <span data-ttu-id="a0d34-579">No armazenamento de tabela, é melhor armazenar a entidade (ou fazer referência a ela) duas vezes, uma com o nome da tabela, PK e RK para facilitar a localização da ID do cliente e outra para facilitar a localização por data.</span><span class="sxs-lookup"><span data-stu-id="a0d34-579">In Table Storage, it is best to store the entity (or a reference to it) twice – once with Table Name, PK, and RK to facilitate finding by customer ID, once to facilitate finding it by the date.</span></span>  

#### <a name="insertupdatedelete"></a><span data-ttu-id="a0d34-580">Inserção/atualização/exclusão</span><span class="sxs-lookup"><span data-stu-id="a0d34-580">Insert/Update/Delete</span></span>
<span data-ttu-id="a0d34-581">Esta seção descreve as práticas comprovadas para modificar as entidades armazenadas no serviço Tabela.</span><span class="sxs-lookup"><span data-stu-id="a0d34-581">This section describes proven practices for modifying entities stored in the table service.</span></span>  

##### <span data-ttu-id="a0d34-582"><a name="subheading35"></a>Envio em lote</span><span class="sxs-lookup"><span data-stu-id="a0d34-582"><a name="subheading35"></a>Batching</span></span>
<span data-ttu-id="a0d34-583">As transações em lote são conhecidas como ETG (transações do grupo de entidades) no armazenamento do Azure. Todas as operações em uma ETG devem constar em uma única partição e em uma única tabela.</span><span class="sxs-lookup"><span data-stu-id="a0d34-583">Batch transactions are known as Entity Group Transactions (ETG) in Azure Storage; all the operations within an ETG must be on a single partition in a single table.</span></span> <span data-ttu-id="a0d34-584">Quando possível, use as ETGs para inserir, atualizar e excluir em lotes.</span><span class="sxs-lookup"><span data-stu-id="a0d34-584">Where possible, use ETGs to perform inserts, updates, and deletes in batches.</span></span> <span data-ttu-id="a0d34-585">Isso diminui a quantidade de viagens de ida e volta entre o aplicativo cliente e o servidor, diminui a quantidade de transações faturáveis (uma ETG conta como uma única transação para fins de cobrança e pode conter até 100 operações de armazenamento) e viabiliza atualizações atômicas (em uma ETG, todas as operações têm êxito ou falham).</span><span class="sxs-lookup"><span data-stu-id="a0d34-585">This reduces the number of round trips from your client application to the server, reduces the number of billable transactions (an ETG counts as a single transaction for billing purposes and can contain up to 100 storage operations), and enables atomic updates (all operations succeed or all fail within an ETG).</span></span> <span data-ttu-id="a0d34-586">Os ambientes com altos níveis de latência, como os dispositivos móveis, veem muitos benefícios no uso das ETGs.</span><span class="sxs-lookup"><span data-stu-id="a0d34-586">Environments with high latencies such as mobile devices will benefit greatly from using ETGs.</span></span>  

##### <span data-ttu-id="a0d34-587"><a name="subheading36"></a>Upsert</span><span class="sxs-lookup"><span data-stu-id="a0d34-587"><a name="subheading36"></a>Upsert</span></span>
<span data-ttu-id="a0d34-588">Use as operações de tabela **Upsert** sempre que possível.</span><span class="sxs-lookup"><span data-stu-id="a0d34-588">Use table **Upsert** operations wherever possible.</span></span> <span data-ttu-id="a0d34-589">Há dois tipos de **Upsert** e os dois podem ser mais eficientes do que as operações tradicionais **Insert** e **Update**:</span><span class="sxs-lookup"><span data-stu-id="a0d34-589">There are two types of **Upsert**, both of which can be more efficient than a traditional **Insert** and **Update** operations:</span></span>  

* <span data-ttu-id="a0d34-590">**InsertOrMerge**: use essa operação quando quiser carregar um subconjunto de propriedades da entidade, mas não souber se a entidade já existe.</span><span class="sxs-lookup"><span data-stu-id="a0d34-590">**InsertOrMerge**: Use this when you want to upload a subset of the entity's properties, but aren't sure whether the entity already exists.</span></span> <span data-ttu-id="a0d34-591">Se a entidade existir, essa chamada atualiza as propriedades incluídas na operação **Upsert** e deixa todas as propriedades existente como elas se encontram. Se a entidade não existir, a operação insere a nova entidade.</span><span class="sxs-lookup"><span data-stu-id="a0d34-591">If the entity exists, this call updates the properties included in the **Upsert** operation, and leaves all existing properties as they are, if the entity does not exist, it inserts the new entity.</span></span> <span data-ttu-id="a0d34-592">Isso se parece com o uso de projeção em uma consulta, pois você só precisa carregar as propriedades que estão mudando.</span><span class="sxs-lookup"><span data-stu-id="a0d34-592">This is similar to using projection in a query, in that you only need to upload the properties that are changing.</span></span>
* <span data-ttu-id="a0d34-593">**InsertOrReplace**: use essa operação quando quiser carregar uma entidade completamente nova, mas não souber se a entidade já existe.</span><span class="sxs-lookup"><span data-stu-id="a0d34-593">**InsertOrReplace**: Use this when you want to upload an entirely new entity, but you aren't sure whether it already exists.</span></span> <span data-ttu-id="a0d34-594">Você só deve usar essa opção quando souber que a entidade carregada está perfeita, pois ela substitui completamente a entidade anterior.</span><span class="sxs-lookup"><span data-stu-id="a0d34-594">You should only use this when you know that the newly uploaded entity is entirely correct because it completely overwrites the old entity.</span></span> <span data-ttu-id="a0d34-595">Por exemplo, você quer atualizar a entidade que armazena um local atual do usuário independente de o aplicativo já ter armazenado ou não os dados de local do usuário; a nova entidade de localização está completa e você não precisa de informações de nenhuma entidade anterior.</span><span class="sxs-lookup"><span data-stu-id="a0d34-595">For example, you want to update the entity that stores a user's current location regardless of whether or not the application has previously stored location data for the user; the new location entity is complete, and you do not need any information from any previous entity.</span></span>

##### <span data-ttu-id="a0d34-596"><a name="subheading37"></a>Armazenamento de séries de dados em uma única entidade</span><span class="sxs-lookup"><span data-stu-id="a0d34-596"><a name="subheading37"></a>Storing Data Series in a Single Entity</span></span>
<span data-ttu-id="a0d34-597">Às vezes, um aplicativo armazena uma série de dados que ele precisa recuperar uma só vez com frequência: por exemplo, um aplicativo pode controlar o uso da CPU ao longo do tempo para plotar um gráfico sem interrupção dos dados das últimas 24 horas.</span><span class="sxs-lookup"><span data-stu-id="a0d34-597">Sometimes, an application stores a series of data that it frequently needs to retrieve all at once: for example, an application might track CPU usage over time in order to plot a rolling chart of the data from the last 24 hours.</span></span> <span data-ttu-id="a0d34-598">Uma abordagem é ter uma entidade de tabela por hora, com cada uma delas representando uma hora específica e armazenando o uso da CPU para a hora em questão.</span><span class="sxs-lookup"><span data-stu-id="a0d34-598">One approach is to have one table entity per hour, with each entity representing a specific hour and storing the CPU usage for that hour.</span></span> <span data-ttu-id="a0d34-599">Para obter esses dados, o aplicativo precisa recuperar as entidades que contêm os dados das últimas 24 horas.</span><span class="sxs-lookup"><span data-stu-id="a0d34-599">To plot this data, the application needs to retrieve the entities holding the data from the 24 most recent hours.</span></span>  

<span data-ttu-id="a0d34-600">Como alternativa, o aplicativo pode armazenar o uso da CPU para cada hora como uma propriedade separada de uma única entidade: para atualizar a cada hora, seu aplicativo pode usar uma única chamada de **InsertOrMerge Upsert** para atualizar o valor para a hora mais recente.</span><span class="sxs-lookup"><span data-stu-id="a0d34-600">Alternatively, your application could store the CPU usage for each hour as a separate property of a single entity: to update each hour, your application can use a single **InsertOrMerge Upsert** call to update the value for the most recent hour.</span></span> <span data-ttu-id="a0d34-601">Para obter os dados, o aplicativo precisa recuperar apenas uma entidade, em vez de 24, resultando em uma consulta muito eficiente (confira acima a seção sobre o [escopo da consulta](#subheading30)).</span><span class="sxs-lookup"><span data-stu-id="a0d34-601">To plot the data, the application only needs to retrieve a single entity instead of 24, making for a very efficient query (see above discussion on [query scope](#subheading30)).</span></span>

##### <span data-ttu-id="a0d34-602"><a name="subheading38"></a>Armazenando dados estruturados em blobs</span><span class="sxs-lookup"><span data-stu-id="a0d34-602"><a name="subheading38"></a>Storing structured data in blobs</span></span>
<span data-ttu-id="a0d34-603">Às vezes parece que os dados estruturados devem ser dispostos em tabelas, mas os intervalos das entidades sempre são recuperados em conjunto e podem ser inseridos em lote.</span><span class="sxs-lookup"><span data-stu-id="a0d34-603">Sometimes structured data feels like it should go in tables, but ranges of entities are always retrieved together and can be batch inserted.</span></span>  <span data-ttu-id="a0d34-604">Um bom exemplo disso são os arquivos de log.</span><span class="sxs-lookup"><span data-stu-id="a0d34-604">A good example of this is a log file.</span></span>  <span data-ttu-id="a0d34-605">Nesse caso, você pode considerar diversos minutos de log como um lote, inseri-los e recuperar diversos minutos de uma só vez.</span><span class="sxs-lookup"><span data-stu-id="a0d34-605">In this case, you can batch several minutes of logs, insert them, and then you are always retrieving several minutes of logs at a time as well.</span></span>  <span data-ttu-id="a0d34-606">Nesse caso, para melhor desempenho, é melhor usar blobs do que tabelas, pois assim é possível diminuir consideravelmente a quantidade de objetos escritos/retornados, além de geralmente diminuir a quantidade de solicitações que devem ser feitas.</span><span class="sxs-lookup"><span data-stu-id="a0d34-606">In this case, for performance, it's better to use blobs instead of tables, since you can significantly reduce the number of objects written/returned, as well as usually the number of requests that need made.</span></span>  

## <a name="queues"></a><span data-ttu-id="a0d34-607">Filas</span><span class="sxs-lookup"><span data-stu-id="a0d34-607">Queues</span></span>
<span data-ttu-id="a0d34-608">Além das práticas comprovadas para [Todos os Serviços](#allservices) descritos anteriormente, as práticas comprovadas a seguir aplicam-se especificamente ao serviço Fila.</span><span class="sxs-lookup"><span data-stu-id="a0d34-608">In addition to the proven practices for [All Services](#allservices) described previously, the following proven practices apply specifically to the queue service.</span></span>  

### <span data-ttu-id="a0d34-609"><a name="subheading39"></a>Limites de escalabilidade</span><span class="sxs-lookup"><span data-stu-id="a0d34-609"><a name="subheading39"></a>Scalability Limits</span></span>
<span data-ttu-id="a0d34-610">Uma única fila pode processar aproximadamente 2.000 mensagens (1 KB cada) por segundo (cada contagem AddMessage, GetMessage e DeleteMessage como uma mensagem aqui).</span><span class="sxs-lookup"><span data-stu-id="a0d34-610">A single queue can process approximately 2,000 messages (1KB each) per second (each AddMessage, GetMessage, and DeleteMessage count as a message here).</span></span> <span data-ttu-id="a0d34-611">Se isso for insuficiente para seu aplicativo, você deve utilizar várias filas e distribuir as mensagens entre elas.</span><span class="sxs-lookup"><span data-stu-id="a0d34-611">If this is insufficient for your application, you should use multiple queues and spread the messages across them.</span></span>  

<span data-ttu-id="a0d34-612">Exiba as metas atuais de escalabilidade em [Metas de desempenho e escalabilidade do Armazenamento do Azure](storage-scalability-targets.md).</span><span class="sxs-lookup"><span data-stu-id="a0d34-612">View current scalability targets at [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md).</span></span>  

### <span data-ttu-id="a0d34-613"><a name="subheading40"></a>Desativação do Nagle</span><span class="sxs-lookup"><span data-stu-id="a0d34-613"><a name="subheading40"></a>Nagle Off</span></span>
<span data-ttu-id="a0d34-614">Consulte a seção de configuração da tabela que fala sobre o algoritmo de Nagle. O uso desse algoritmo geralmente não é uma boa opção para o desempenho das solicitações de fila, e você deve desabilitá-lo.</span><span class="sxs-lookup"><span data-stu-id="a0d34-614">See the section on table configuration that discusses the Nagle algorithm — the Nagle algorithm is generally bad for the performance of queue requests, and you should disable it.</span></span>  

### <span data-ttu-id="a0d34-615"><a name="subheading41"></a>Tamanho da mensagem</span><span class="sxs-lookup"><span data-stu-id="a0d34-615"><a name="subheading41"></a>Message Size</span></span>
<span data-ttu-id="a0d34-616">O desempenho e a escalabilidade da fila diminui quando o tamanho de mensagem aumenta.</span><span class="sxs-lookup"><span data-stu-id="a0d34-616">Queue performance and scalability decreases as message size increases.</span></span> <span data-ttu-id="a0d34-617">Você deve colocar somente as informações que o receptor precisa em uma mensagem.</span><span class="sxs-lookup"><span data-stu-id="a0d34-617">You should place only the information the receiver needs in a message.</span></span>  

### <span data-ttu-id="a0d34-618"><a name="subheading42"></a>Recuperação de lote</span><span class="sxs-lookup"><span data-stu-id="a0d34-618"><a name="subheading42"></a>Batch Retrieval</span></span>
<span data-ttu-id="a0d34-619">Você pode recuperar até 32 mensagens de uma fila em uma única operação.</span><span class="sxs-lookup"><span data-stu-id="a0d34-619">You can retrieve up to 32 messages from a queue in a single operation.</span></span> <span data-ttu-id="a0d34-620">Isso pode diminuir a quantidade de viagens de ida e volta de um aplicativo cliente, o que é útil principalmente para ambientes com alta latência, como os dispositivos móveis.</span><span class="sxs-lookup"><span data-stu-id="a0d34-620">This can reduce the number of roundtrips from the client application, which is especially useful for environments, such as mobile devices, with high latency.</span></span>  

### <span data-ttu-id="a0d34-621"><a name="subheading43"></a>Intervalo de sondagem de fila</span><span class="sxs-lookup"><span data-stu-id="a0d34-621"><a name="subheading43"></a>Queue Polling Interval</span></span>
<span data-ttu-id="a0d34-622">A maioria dos aplicativos de sondagem para mensagens de uma fila, pode ser uma das principais fontes de transações para o aplicativo.</span><span class="sxs-lookup"><span data-stu-id="a0d34-622">Most applications poll for messages from a queue, which can be one of the largest sources of transactions for that application.</span></span> <span data-ttu-id="a0d34-623">Selecione o intervalo de sondagem com sabedoria: a sondagem muito frequente pode fazer com que seu aplicativo se aproxime das metas de escalabilidade para a fila.</span><span class="sxs-lookup"><span data-stu-id="a0d34-623">Select your polling interval wisely: polling too frequently could cause your application to approach the scalability targets for the queue.</span></span> <span data-ttu-id="a0d34-624">No entanto, em 200.000 transações para US $0,01 (no momento da gravação), um único processador sondando uma vez por segundo em um mês custaria menos de 15 centavos, assim o custo de sondagem não é normalmente um fator que afeta sua opção de intervalo de sondagem.</span><span class="sxs-lookup"><span data-stu-id="a0d34-624">However, at 200,000 transactions for $0.01 (at the time of writing), a single processor polling once every second for a month would cost less than 15 cents so cost is not typically a factor that affects your choice of polling interval.</span></span>  

<span data-ttu-id="a0d34-625">Para obter informações atualizadas sobre custos, confira [Preços do Armazenamento do Azure](https://azure.microsoft.com/pricing/details/storage/).</span><span class="sxs-lookup"><span data-stu-id="a0d34-625">For up-to-date cost information, see [Azure Storage Pricing](https://azure.microsoft.com/pricing/details/storage/).</span></span>  

### <span data-ttu-id="a0d34-626"><a name="subheading44"></a>UpdateMessage</span><span class="sxs-lookup"><span data-stu-id="a0d34-626"><a name="subheading44"></a>UpdateMessage</span></span>
<span data-ttu-id="a0d34-627">Você pode usar **UpdateMessage** para aumentar o tempo limite da invisibilidade ou atualizar as informações de estado de uma mensagem.</span><span class="sxs-lookup"><span data-stu-id="a0d34-627">You can use **UpdateMessage** to increase the invisibility timeout or to update state information of a message.</span></span> <span data-ttu-id="a0d34-628">Embora isso seja útil, lembre-se de que a operação **UpdateMessage** é computada na meta de escalabilidade.</span><span class="sxs-lookup"><span data-stu-id="a0d34-628">While this is powerful, remember that each **UpdateMessage** operation counts towards the scalability target.</span></span> <span data-ttu-id="a0d34-629">No entanto, essa abordagem pode ser muito mais eficiente do que ter um fluxo de trabalho que transmite uma tarefa de uma fila para a outra, pois cada etapa da tarefa é concluída.</span><span class="sxs-lookup"><span data-stu-id="a0d34-629">However, this can be a much more efficient approach than having a workflow that passes a job from one queue to the next, as each step of the job is completed.</span></span> <span data-ttu-id="a0d34-630">O uso da operação **UpdateMessage** permite que o aplicativo salve o estado da tarefa na mensagem e continue trabalhando, em vez de colocar a mensagem na fila novamente para a próxima etapa a cada etapa concluída.</span><span class="sxs-lookup"><span data-stu-id="a0d34-630">Using the **UpdateMessage** operation allows your application to save the job state to the message and then continue working, instead of re-queuing the message for the next step of the job every time a step completes.</span></span>  

<span data-ttu-id="a0d34-631">Para obter mais informações, consulte o artigo [Como alterar o conteúdo de uma mensagem em fila](storage-dotnet-how-to-use-queues.md#change-the-contents-of-a-queued-message).</span><span class="sxs-lookup"><span data-stu-id="a0d34-631">For more information, see the article [How to: Change the contents of a queued message](storage-dotnet-how-to-use-queues.md#change-the-contents-of-a-queued-message).</span></span>  

### <span data-ttu-id="a0d34-632"><a name="subheading45"></a>Arquitetura do aplicativo</span><span class="sxs-lookup"><span data-stu-id="a0d34-632"><a name="subheading45"></a>Application architecture</span></span>
<span data-ttu-id="a0d34-633">Você deve usar filas para que a arquitetura do aplicativo seja escalonável.</span><span class="sxs-lookup"><span data-stu-id="a0d34-633">You should use queues to make your application architecture scalable.</span></span> <span data-ttu-id="a0d34-634">A seguir temos algumas maneiras de usar filas para que seu aplicativo seja mais escalonável:</span><span class="sxs-lookup"><span data-stu-id="a0d34-634">The following lists some ways you can use queues to make your application more scalable:</span></span>  

* <span data-ttu-id="a0d34-635">Você pode usar as filas para criar listas de pendências de trabalho para processamento e suavização das cargas de trabalho no seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="a0d34-635">You can use queues to create backlogs of work for processing and smooth out workloads in your application.</span></span> <span data-ttu-id="a0d34-636">Por exemplo, você pode colocar na fila as solicitações dos usuários para execução de trabalhos que requerem trabalho muito intenso do processador, como o redimensionamento das imagens carregadas.</span><span class="sxs-lookup"><span data-stu-id="a0d34-636">For example, you could queue up requests from users to perform processor intensive work such as resizing uploaded images.</span></span>
* <span data-ttu-id="a0d34-637">Você pode usar as filas para desassociar parte do aplicativo, a fim de poder escaloná-las de forma independente.</span><span class="sxs-lookup"><span data-stu-id="a0d34-637">You can use queues to decouple parts of your application so that you can scale them independently.</span></span> <span data-ttu-id="a0d34-638">Por exemplo, um front-end da Web pode colocar os resultados de pesquisa dos usuários em uma fila para análise posterior e armazenamento.</span><span class="sxs-lookup"><span data-stu-id="a0d34-638">For example, a web front-end could place survey results from users into a queue for later analysis and storage.</span></span> <span data-ttu-id="a0d34-639">Você pode adicionar mais instâncias de função de trabalho para processar os dados da fila conforme necessário.</span><span class="sxs-lookup"><span data-stu-id="a0d34-639">You could add more worker role instances to process the queue data as required.</span></span>  

## <a name="conclusion"></a><span data-ttu-id="a0d34-640">Conclusão</span><span class="sxs-lookup"><span data-stu-id="a0d34-640">Conclusion</span></span>
<span data-ttu-id="a0d34-641">Este artigo falou sobre algumas das práticas comprovadas mais comuns para otimizar o desempenho com o uso do armazenamento do Azure.</span><span class="sxs-lookup"><span data-stu-id="a0d34-641">This article discussed some of the most common, proven practices for optimizing performance when using Azure Storage.</span></span> <span data-ttu-id="a0d34-642">Nós recomendamos que cada desenvolvedor avalie seu aplicativo com base nas práticas descritas acima e considere seguir as recomendações para obter desempenho excelente para seus aplicativos que usam o Armazenamento do Azure.</span><span class="sxs-lookup"><span data-stu-id="a0d34-642">We encourage every application developer to assess their application against each of the above practices and consider acting on the recommendations to get great performance for their applications that use Azure Storage.</span></span>
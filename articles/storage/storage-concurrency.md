---
title: Gerenciando a simultaneidade no Armazenamento do Microsoft Azure
description: "Como gerenciar a simultaneidade para os serviços Blob, Fila, Tabela e Arquivo"
services: storage
documentationcenter: 
author: jasontang501
manager: tadb
editor: tysonn
ms.assetid: cc6429c4-23ee-46e3-b22d-50dd68bd4680
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: dotnet
ms.topic: article
ms.date: 05/11/2017
ms.author: jasontang501
ms.openlocfilehash: 8b894af2f15cd22f04701c545d8250e20b99a094
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 07/11/2017
---
# <a name="managing-concurrency-in-microsoft-azure-storage"></a><span data-ttu-id="0ef5a-103">Gerenciando a simultaneidade no Armazenamento do Microsoft Azure</span><span class="sxs-lookup"><span data-stu-id="0ef5a-103">Managing Concurrency in Microsoft Azure Storage</span></span>
## <a name="overview"></a><span data-ttu-id="0ef5a-104">Visão geral</span><span class="sxs-lookup"><span data-stu-id="0ef5a-104">Overview</span></span>
<span data-ttu-id="0ef5a-105">Os aplicativos baseados na Internet modernos consistem normalmente em vários usuários exibindo e atualizando dados de forma simultânea.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-105">Modern Internet based applications usually have multiple users viewing and updating data simultaneously.</span></span> <span data-ttu-id="0ef5a-106">Isso exige que os desenvolvedores de aplicativos pensem cuidadosamente sobre como fornecer uma experiência previsível para os usuários finais, especialmente para cenários em que vários usuários podem atualizar os mesmos dados.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-106">This requires application developers to think carefully about how to provide a predictable experience to their end users, particularly for scenarios where multiple users can update the same data.</span></span> <span data-ttu-id="0ef5a-107">Existem três estratégias de simultaneidade de dados principais que os desenvolvedores normalmente considerarão:</span><span class="sxs-lookup"><span data-stu-id="0ef5a-107">There are three main data concurrency strategies developers will typically consider:</span></span>  

1. <span data-ttu-id="0ef5a-108">Simultaneidade otimista: um aplicativo realizando uma atualização verificará, como parte da atualização, se os dados foram alterados desde a última vez que o aplicativo leu tais dados.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-108">Optimistic concurrency – An application performing an update will as part of its update verify if the data has changed since the application last read that data.</span></span> <span data-ttu-id="0ef5a-109">Por exemplo, se dois usuários visualizando uma página wiki fazem uma atualização na mesma página, a plataforma wiki deve garantir que a segunda atualização não substitua a primeira e que os dois usuários entendam se suas respectivas atualizações foram bem-sucedidas ou não.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-109">For example, if two users viewing a wiki page make an update to the same page then the wiki platform must ensure that the second update does not overwrite the first update – and that both users understand whether their update was successful or not.</span></span> <span data-ttu-id="0ef5a-110">Essa estratégia é usada com mais frequência em aplicativos Web.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-110">This strategy is most often used in web applications.</span></span>
2. <span data-ttu-id="0ef5a-111">Simultaneidade pessimista: um aplicativo procurando realizar uma atualização bloqueará um objeto, impedindo que outros usuários atualizem os dados até que o bloqueio seja liberado.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-111">Pessimistic concurrency – An application looking to perform an update will take a lock on an object preventing other users from updating the data until the lock is released.</span></span> <span data-ttu-id="0ef5a-112">Por exemplo, em um cenário de replicação de dados mestre/subordinado em que apenas o mestre realizará atualizações, normalmente o mestre manterá um bloqueio exclusivo por um período de tempo prolongado nos dados para garantir que nenhuma outra pessoa possa atualizá-los.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-112">For example, in a master/slave data replication scenario where only the master will perform updates the master will typically hold an exclusive lock for an extended period of time on the data to ensure no one else can update it.</span></span>
3. <span data-ttu-id="0ef5a-113">Último a gravar vence: uma abordagem que permite que quaisquer operações de atualização prossigam sem verificar se algum outro aplicativo atualizou os dados desde que o aplicativo leu os dados pela primeira vez.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-113">Last writer wins – An approach that allows any update operations to proceed without verifying if any other application has updated the data since the application first read the data.</span></span> <span data-ttu-id="0ef5a-114">Essa estratégia (ou falta de uma estratégia formal) normalmente é usada em locais em que os dados estão particionados de tal forma que não há probabilidade de vários usuários acessarem os mesmos dados.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-114">This strategy (or lack of a formal strategy) is usually used where data is partitioned in such a way that there is no likelihood that multiple users will access the same data.</span></span> <span data-ttu-id="0ef5a-115">Ela também pode ser útil em locais em que fluxos de dados de curta duração estão sendo processados.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-115">It can also be useful where short-lived data streams are being processed.</span></span>  

<span data-ttu-id="0ef5a-116">Este artigo fornece uma visão geral de como a plataforma de Armazenamento do Azure simplifica o desenvolvimento fornecendo suporte de primeira classe para essas três estratégias de simultaneidade.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-116">This article provides an overview of how the Azure Storage platform simplifies development by providing first class support for all three of these concurrency strategies.</span></span>  

## <a name="azure-storage--simplifies-cloud-development"></a><span data-ttu-id="0ef5a-117">Armazenamento do Azure: simplifica o desenvolvimento na nuvem</span><span class="sxs-lookup"><span data-stu-id="0ef5a-117">Azure Storage – Simplifies Cloud Development</span></span>
<span data-ttu-id="0ef5a-118">O serviço de Armazenamento do Azure oferece suporte para as três estratégias, embora seja distinto em sua capacidade de fornecer suporte completo para a simultaneidade otimista e pessimista, pois foi projetado para englobar um modelo de consistência sólido, o qual garante que quando o serviço de Armazenamento confirma uma operação de atualização ou inserção de dados, todos os acessos adicionais a tais dados possam ver a atualização mais recente.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-118">The Azure storage service supports all three strategies, although it is distinctive in its ability to provide full support for optimistic and pessimistic concurrency because it was designed to embrace a strong consistency model which guarantees that when the Storage service commits a data insert or update operation all further accesses to that data will see the latest update.</span></span> <span data-ttu-id="0ef5a-119">As plataformas de armazenamento que usam um modelo de consistência eventual apresentam um retardo entre o momento em que uma gravação é realizada por um usuário e o momento em que os dados atualizados podem ser visualizados por outros usuários, o que complica o desenvolvimento de aplicativos cliente para evitar que as inconsistências afetem os usuários finais.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-119">Storage platforms that use an eventual consistency model have a lag between when a write is performed by one user and when the updated data can be seen by other users thus complicating development of client applications in order to prevent inconsistencies from affecting end users.</span></span>  

<span data-ttu-id="0ef5a-120">Além de selecionar uma estratégia de simultaneidade adequada, os desenvolvedores também devem estar cientes de como uma plataforma de armazenamento isola as alterações, especialmente as alterações no mesmo objeto entre as transações.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-120">In addition to selecting an appropriate concurrency strategy developers should also be aware of how a storage platform isolates changes – particularly changes to the same object across transactions.</span></span> <span data-ttu-id="0ef5a-121">O serviço de Armazenamento do Azure usa o isolamento de instantâneo para permitir que as operações de leitura ocorram simultaneamente às operações de gravação em uma única partição.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-121">The Azure storage service uses snapshot isolation to allow read operations to happen concurrently with write operations within a single partition.</span></span> <span data-ttu-id="0ef5a-122">Diferente de outros níveis de isolamento, o isolamento de instantâneo garante que todas as leituras vejam um instantâneo consistente dos dados mesmo durante atualizações, retornando basicamente os últimos valores confirmados enquanto uma transação de atualização é processada.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-122">Unlike other isolation levels, snapshot isolation guarantees that all reads see a consistent snapshot of the data even while updates are occurring – essentially by returning the last committed values while an update transaction is being processed.</span></span>  

## <a name="managing-concurrency-in-blob-storage"></a><span data-ttu-id="0ef5a-123">Gerenciando Simultaneidade em Armazenamento de Blobs</span><span class="sxs-lookup"><span data-stu-id="0ef5a-123">Managing Concurrency in Blob storage</span></span>
<span data-ttu-id="0ef5a-124">Você pode optar por usar os modelos de simultaneidade otimista ou pessimista para gerenciar o acesso a blobs e contêineres no serviço Blob.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-124">You can opt to use either optimistic or pessimistic concurrency models to manage access to blobs and containers in the blob service.</span></span> <span data-ttu-id="0ef5a-125">Se você não especificar explicitamente uma estratégia, o padrão será último a gravar vence.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-125">If you do not explicitly specify a strategy last writes wins is the default.</span></span>  

### <a name="optimistic-concurrency-for-blobs-and-containers"></a><span data-ttu-id="0ef5a-126">Simultaneidade otimista para blobs e contêineres</span><span class="sxs-lookup"><span data-stu-id="0ef5a-126">Optimistic concurrency for blobs and containers</span></span>
<span data-ttu-id="0ef5a-127">O serviço de Armazenamento atribui um identificador a todo objeto armazenado.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-127">The Storage service assigns an identifier to every object stored.</span></span> <span data-ttu-id="0ef5a-128">Esse identificador é atualizado sempre que uma operação de atualização é realizada em um objeto.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-128">This identifier is updated every time an update operation is performed on an object.</span></span> <span data-ttu-id="0ef5a-129">O identificador é retornado para o cliente como parte de uma resposta de HTTP GET usando o cabeçalho ETag (marca de entidade) que está definido no protocolo HTTP.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-129">The identifier is returned to the client as part of an HTTP GET response using the ETag (entity tag) header that is defined within the HTTP protocol.</span></span> <span data-ttu-id="0ef5a-130">Um usuário realizando uma atualização em tal objeto pode enviar a Etag original juntamente com um cabeçalho condicional para garantir que a atualização ocorra apenas se uma determinada condição for atendida; nesse caso, a condição é um cabeçalho "If-Match", o qual exige que o serviço de Armazenamento garanta que o valor de Etag especificado na solicitação de atualização seja igual ao armazenado no serviço de Armazenamento.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-130">A user performing an update on such an object can send in the original ETag along with a conditional header to ensure that an update will only occur if a certain condition has been met – in this case the condition is an "If-Match" header which requires the Storage Service to ensure the value of the ETag specified in the update request is the same as that stored in the Storage Service.</span></span>  

<span data-ttu-id="0ef5a-131">A estrutura desse processo é a seguinte:</span><span class="sxs-lookup"><span data-stu-id="0ef5a-131">The outline of this process is as follows:</span></span>  

1. <span data-ttu-id="0ef5a-132">Recupere um blob do serviço de Armazenamento, a resposta inclui um valor de cabeçalho HTTP ETag que identifica a versão atual do objeto no serviço de Armazenamento.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-132">Retrieve a blob from the storage service, the response includes an HTTP ETag Header value that identifies the current version of the object in the storage service.</span></span>
2. <span data-ttu-id="0ef5a-133">Ao atualizar o blob, inclua o valor de ETag recebido na etapa 1 no cabeçalho condicional **If-Match** da solicitação enviada para o serviço.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-133">When you update the blob, include the ETag value you received in step 1 in the **If-Match** conditional header of the request you send to the service.</span></span>
3. <span data-ttu-id="0ef5a-134">O serviço compara o valor da ETag na solicitação com o valor da ETag atual do blob.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-134">The service compares the ETag value in the request with the current ETag value of the blob.</span></span>
4. <span data-ttu-id="0ef5a-135">Se o valor da ETag atual do blob for uma versão diferente da ETag no cabeçalho condicional **If-Match** na solicitação, o serviço retornará um erro 412 para o cliente.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-135">If the current ETag value of the blob is a different version than the ETag in the **If-Match** conditional header in the request, the service returns a 412 error to the client.</span></span> <span data-ttu-id="0ef5a-136">Isso indica para o cliente que outro processo atualizou o blob desde que ele o recuperou.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-136">This indicates to the client that another process has updated the blob since the client retrieved it.</span></span>
5. <span data-ttu-id="0ef5a-137">Se o valor atual de ETag do blob for a mesma versão de ETag no cabeçalho condicional **If-Match** na solicitação, o serviço realizará a operação solicitada e atualizará o valor da ETag atual do blob para mostrar que foi criada uma nova versão.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-137">If the current ETag value of the blob is the same version as the ETag in the **If-Match** conditional header in the request, the service performs the requested operation and updates the current ETag value of the blob to show that it has created a new version.</span></span>  

<span data-ttu-id="0ef5a-138">O trecho de C# a seguir (usando a Client Storage Library 4.2.0) mostra um exemplo simples de como criar um **If-Match AccessCondition** com base no valor da ETag acessado nas propriedades de um blob que foi recuperado ou inserido anteriormente.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-138">The following C# snippet (using the Client Storage Library 4.2.0) shows a simple example of how to construct an **If-Match AccessCondition** based on the ETag value that is accessed from the properties of a blob that was previously either retrieved or inserted.</span></span> <span data-ttu-id="0ef5a-139">Ele usa então o objeto **AccessCondition** quando está atualizando o blob: o objeto **AccessCondition** adiciona o cabeçalho **If-Match** à solicitação.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-139">It then uses the **AccessCondition** object when it updating the blob: the **AccessCondition** object adds the **If-Match** header to the request.</span></span> <span data-ttu-id="0ef5a-140">Se outro processo atualizou o blob, o serviço Blob retorna uma mensagem de status HTTP 412 (Falha de precondição).</span><span class="sxs-lookup"><span data-stu-id="0ef5a-140">If another process has updated the blob, the blob service returns an HTTP 412 (Precondition Failed) status message.</span></span> <span data-ttu-id="0ef5a-141">Você pode baixar o exemplo completo aqui: [Gerenciando a Simultaneidade usando o Armazenamento do Azure](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).</span><span class="sxs-lookup"><span data-stu-id="0ef5a-141">You can download the full sample here: [Managing Concurrency using Azure Storage](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).</span></span>  

```csharp
// Retrieve the ETag from the newly created blob
// Etag is already populated as UploadText should cause a PUT Blob call
// to storage blob service which returns the etag in response.
string orignalETag = blockBlob.Properties.ETag;

// This code simulates an update by a third party.
string helloText = "Blob updated by a third party.";

// No etag, provided so orignal blob is overwritten (thus generating a new etag)
blockBlob.UploadText(helloText);
Console.WriteLine("Blob updated. Updated ETag = {0}",
blockBlob.Properties.ETag);

// Now try to update the blob using the orignal ETag provided when the blob was created
try
{
    Console.WriteLine("Trying to update blob using orignal etag to generate if-match access condition");
    blockBlob.UploadText(helloText,accessCondition:
    AccessCondition.GenerateIfMatchCondition(orignalETag));
}
catch (StorageException ex)
{
    if (ex.RequestInformation.HttpStatusCode == (int)HttpStatusCode.PreconditionFailed)
    {
        Console.WriteLine("Precondition failure as expected. Blob's orignal etag no longer matches");
        // TODO: client can decide on how it wants to handle the 3rd party updated content.
    }
    else
        throw;
}  
```

<span data-ttu-id="0ef5a-142">O serviço de Armazenamento também inclui suporte para cabeçalhos condicionais adicionais, como **If-Modified-Since**, **If-Unmodified-Since** e **If-None-Match**, bem como combinações deles.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-142">The Storage Service also includes support for additional conditional headers such as **If-Modified-Since**, **If-Unmodified-Since** and **If-None-Match** as well as combinations thereof.</span></span> <span data-ttu-id="0ef5a-143">Para obter mais informações, consulte [Especificando cabeçalhos condicionais para operações do serviço Blob](http://msdn.microsoft.com/library/azure/dd179371.aspx) no MSDN.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-143">For more information see [Specifying Conditional Headers for Blob Service Operations](http://msdn.microsoft.com/library/azure/dd179371.aspx) on MSDN.</span></span>  

<span data-ttu-id="0ef5a-144">A tabela a seguir resume as operações de contêiner que aceitam cabeçalhos condicionais como **If-Match** na solicitação e retornam um valor de ETag na resposta.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-144">The following table summarizes the container operations that accept conditional headers such as **If-Match** in the request and that return an ETag value in the response.</span></span>  

| <span data-ttu-id="0ef5a-145">Operação</span><span class="sxs-lookup"><span data-stu-id="0ef5a-145">Operation</span></span> | <span data-ttu-id="0ef5a-146">Retorna o valor de ETag do contêiner</span><span class="sxs-lookup"><span data-stu-id="0ef5a-146">Returns Container ETag value</span></span> | <span data-ttu-id="0ef5a-147">Aceita cabeçalhos condicionais</span><span class="sxs-lookup"><span data-stu-id="0ef5a-147">Accepts conditional headers</span></span> |
|:--- |:--- |:--- |
| <span data-ttu-id="0ef5a-148">Create Container</span><span class="sxs-lookup"><span data-stu-id="0ef5a-148">Create Container</span></span> |<span data-ttu-id="0ef5a-149">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-149">Yes</span></span> |<span data-ttu-id="0ef5a-150">Não</span><span class="sxs-lookup"><span data-stu-id="0ef5a-150">No</span></span> |
| <span data-ttu-id="0ef5a-151">Get Container Properties</span><span class="sxs-lookup"><span data-stu-id="0ef5a-151">Get Container Properties</span></span> |<span data-ttu-id="0ef5a-152">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-152">Yes</span></span> |<span data-ttu-id="0ef5a-153">Não</span><span class="sxs-lookup"><span data-stu-id="0ef5a-153">No</span></span> |
| <span data-ttu-id="0ef5a-154">Get Container Metadata</span><span class="sxs-lookup"><span data-stu-id="0ef5a-154">Get Container Metadata</span></span> |<span data-ttu-id="0ef5a-155">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-155">Yes</span></span> |<span data-ttu-id="0ef5a-156">Não</span><span class="sxs-lookup"><span data-stu-id="0ef5a-156">No</span></span> |
| <span data-ttu-id="0ef5a-157">Set Container Metadata</span><span class="sxs-lookup"><span data-stu-id="0ef5a-157">Set Container Metadata</span></span> |<span data-ttu-id="0ef5a-158">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-158">Yes</span></span> |<span data-ttu-id="0ef5a-159">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-159">Yes</span></span> |
| <span data-ttu-id="0ef5a-160">Get Container ACL</span><span class="sxs-lookup"><span data-stu-id="0ef5a-160">Get Container ACL</span></span> |<span data-ttu-id="0ef5a-161">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-161">Yes</span></span> |<span data-ttu-id="0ef5a-162">Não</span><span class="sxs-lookup"><span data-stu-id="0ef5a-162">No</span></span> |
| <span data-ttu-id="0ef5a-163">Set Container ACL</span><span class="sxs-lookup"><span data-stu-id="0ef5a-163">Set Container ACL</span></span> |<span data-ttu-id="0ef5a-164">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-164">Yes</span></span> |<span data-ttu-id="0ef5a-165">Sim (*)</span><span class="sxs-lookup"><span data-stu-id="0ef5a-165">Yes (*)</span></span> |
| <span data-ttu-id="0ef5a-166">Delete Container</span><span class="sxs-lookup"><span data-stu-id="0ef5a-166">Delete Container</span></span> |<span data-ttu-id="0ef5a-167">Não</span><span class="sxs-lookup"><span data-stu-id="0ef5a-167">No</span></span> |<span data-ttu-id="0ef5a-168">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-168">Yes</span></span> |
| <span data-ttu-id="0ef5a-169">Lease Container</span><span class="sxs-lookup"><span data-stu-id="0ef5a-169">Lease Container</span></span> |<span data-ttu-id="0ef5a-170">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-170">Yes</span></span> |<span data-ttu-id="0ef5a-171">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-171">Yes</span></span> |
| <span data-ttu-id="0ef5a-172">Listar Blobs</span><span class="sxs-lookup"><span data-stu-id="0ef5a-172">List Blobs</span></span> |<span data-ttu-id="0ef5a-173">Não</span><span class="sxs-lookup"><span data-stu-id="0ef5a-173">No</span></span> |<span data-ttu-id="0ef5a-174">Não</span><span class="sxs-lookup"><span data-stu-id="0ef5a-174">No</span></span> |

<span data-ttu-id="0ef5a-175">(*) As permissões definidas por SetContainerACL são armazenadas em cache e as atualizações dessas permissões levam 30 segundos para serem propagadas, período durante o qual não há garantia de que as atualizações são consistentes.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-175">(*) The permissions defined by SetContainerACL are cached and updates to these permissions take 30 seconds to propagate during which period updates are not guaranteed to be consistent.</span></span>  

<span data-ttu-id="0ef5a-176">A tabela a seguir resume as operações de blob que aceitam cabeçalhos condicionais como **If-Match** na solicitação e retornam um valor de ETag na resposta.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-176">The following table summarizes the blob operations that accept conditional headers such as **If-Match** in the request and that return an ETag value in the response.</span></span>

| <span data-ttu-id="0ef5a-177">Operação</span><span class="sxs-lookup"><span data-stu-id="0ef5a-177">Operation</span></span> | <span data-ttu-id="0ef5a-178">Retorna o valor de ETag</span><span class="sxs-lookup"><span data-stu-id="0ef5a-178">Returns ETag value</span></span> | <span data-ttu-id="0ef5a-179">Aceita cabeçalhos condicionais</span><span class="sxs-lookup"><span data-stu-id="0ef5a-179">Accepts conditional headers</span></span> |
|:--- |:--- |:--- |
| <span data-ttu-id="0ef5a-180">Put Blob</span><span class="sxs-lookup"><span data-stu-id="0ef5a-180">Put Blob</span></span> |<span data-ttu-id="0ef5a-181">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-181">Yes</span></span> |<span data-ttu-id="0ef5a-182">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-182">Yes</span></span> |
| <span data-ttu-id="0ef5a-183">Get Blob</span><span class="sxs-lookup"><span data-stu-id="0ef5a-183">Get Blob</span></span> |<span data-ttu-id="0ef5a-184">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-184">Yes</span></span> |<span data-ttu-id="0ef5a-185">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-185">Yes</span></span> |
| <span data-ttu-id="0ef5a-186">Get Blob Properties</span><span class="sxs-lookup"><span data-stu-id="0ef5a-186">Get Blob Properties</span></span> |<span data-ttu-id="0ef5a-187">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-187">Yes</span></span> |<span data-ttu-id="0ef5a-188">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-188">Yes</span></span> |
| <span data-ttu-id="0ef5a-189">Set Blob Properties</span><span class="sxs-lookup"><span data-stu-id="0ef5a-189">Set Blob Properties</span></span> |<span data-ttu-id="0ef5a-190">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-190">Yes</span></span> |<span data-ttu-id="0ef5a-191">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-191">Yes</span></span> |
| <span data-ttu-id="0ef5a-192">Get Blob Metadata</span><span class="sxs-lookup"><span data-stu-id="0ef5a-192">Get Blob Metadata</span></span> |<span data-ttu-id="0ef5a-193">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-193">Yes</span></span> |<span data-ttu-id="0ef5a-194">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-194">Yes</span></span> |
| <span data-ttu-id="0ef5a-195">Set Blob Metadata</span><span class="sxs-lookup"><span data-stu-id="0ef5a-195">Set Blob Metadata</span></span> |<span data-ttu-id="0ef5a-196">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-196">Yes</span></span> |<span data-ttu-id="0ef5a-197">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-197">Yes</span></span> |
| <span data-ttu-id="0ef5a-198">Lease Blob (*)</span><span class="sxs-lookup"><span data-stu-id="0ef5a-198">Lease Blob (*)</span></span> |<span data-ttu-id="0ef5a-199">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-199">Yes</span></span> |<span data-ttu-id="0ef5a-200">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-200">Yes</span></span> |
| <span data-ttu-id="0ef5a-201">Blob de instantâneo</span><span class="sxs-lookup"><span data-stu-id="0ef5a-201">Snapshot Blob</span></span> |<span data-ttu-id="0ef5a-202">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-202">Yes</span></span> |<span data-ttu-id="0ef5a-203">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-203">Yes</span></span> |
| <span data-ttu-id="0ef5a-204">Copiar blob</span><span class="sxs-lookup"><span data-stu-id="0ef5a-204">Copy Blob</span></span> |<span data-ttu-id="0ef5a-205">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-205">Yes</span></span> |<span data-ttu-id="0ef5a-206">Sim (para o blob de origem e destino)</span><span class="sxs-lookup"><span data-stu-id="0ef5a-206">Yes (for source and destination blob)</span></span> |
| <span data-ttu-id="0ef5a-207">Anular copiar Blob</span><span class="sxs-lookup"><span data-stu-id="0ef5a-207">Abort Copy Blob</span></span> |<span data-ttu-id="0ef5a-208">Não</span><span class="sxs-lookup"><span data-stu-id="0ef5a-208">No</span></span> |<span data-ttu-id="0ef5a-209">Não</span><span class="sxs-lookup"><span data-stu-id="0ef5a-209">No</span></span> |
| <span data-ttu-id="0ef5a-210">Delete Blob</span><span class="sxs-lookup"><span data-stu-id="0ef5a-210">Delete Blob</span></span> |<span data-ttu-id="0ef5a-211">Não</span><span class="sxs-lookup"><span data-stu-id="0ef5a-211">No</span></span> |<span data-ttu-id="0ef5a-212">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-212">Yes</span></span> |
| <span data-ttu-id="0ef5a-213">Put Block</span><span class="sxs-lookup"><span data-stu-id="0ef5a-213">Put Block</span></span> |<span data-ttu-id="0ef5a-214">Não</span><span class="sxs-lookup"><span data-stu-id="0ef5a-214">No</span></span> |<span data-ttu-id="0ef5a-215">Não</span><span class="sxs-lookup"><span data-stu-id="0ef5a-215">No</span></span> |
| <span data-ttu-id="0ef5a-216">Put Block List</span><span class="sxs-lookup"><span data-stu-id="0ef5a-216">Put Block List</span></span> |<span data-ttu-id="0ef5a-217">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-217">Yes</span></span> |<span data-ttu-id="0ef5a-218">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-218">Yes</span></span> |
| <span data-ttu-id="0ef5a-219">Get Block List</span><span class="sxs-lookup"><span data-stu-id="0ef5a-219">Get Block List</span></span> |<span data-ttu-id="0ef5a-220">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-220">Yes</span></span> |<span data-ttu-id="0ef5a-221">Não</span><span class="sxs-lookup"><span data-stu-id="0ef5a-221">No</span></span> |
| <span data-ttu-id="0ef5a-222">Put Page</span><span class="sxs-lookup"><span data-stu-id="0ef5a-222">Put Page</span></span> |<span data-ttu-id="0ef5a-223">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-223">Yes</span></span> |<span data-ttu-id="0ef5a-224">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-224">Yes</span></span> |
| <span data-ttu-id="0ef5a-225">Get Page Ranges</span><span class="sxs-lookup"><span data-stu-id="0ef5a-225">Get Page Ranges</span></span> |<span data-ttu-id="0ef5a-226">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-226">Yes</span></span> |<span data-ttu-id="0ef5a-227">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-227">Yes</span></span> |

<span data-ttu-id="0ef5a-228">(*) Lease Blob não altera a ETag em um blob.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-228">(*) Lease Blob does not change the ETag on a blob.</span></span>  

### <a name="pessimistic-concurrency-for-blobs"></a><span data-ttu-id="0ef5a-229">Simultaneidade pessimista para blobs</span><span class="sxs-lookup"><span data-stu-id="0ef5a-229">Pessimistic concurrency for blobs</span></span>
<span data-ttu-id="0ef5a-230">Para bloquear um blob para uso exclusivo, é possível obter uma [concessão](http://msdn.microsoft.com/library/azure/ee691972.aspx) sobre ele.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-230">To lock a blob for exclusive use, you can acquire a [lease](http://msdn.microsoft.com/library/azure/ee691972.aspx) on it.</span></span> <span data-ttu-id="0ef5a-231">Ao adquirir uma concessão, você especifica por quanto tempo precisa dela: esse período pode ser entre 15 e 60 segundos ou infinito, o que resulta em um bloqueio exclusivo.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-231">When you acquire a lease, you specify for how long you need the lease: this can be for between 15 to 60 seconds or infinite which amounts to an exclusive lock.</span></span> <span data-ttu-id="0ef5a-232">Você pode renovar uma concessão finita para estendê-la e pode liberar qualquer concessão quando terminar de trabalhar com ela.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-232">You can renew a finite lease to extend it, and you can release any lease when you are finished with it.</span></span> <span data-ttu-id="0ef5a-233">O serviço Blob libera as concessões finitas automaticamente quando elas expiram.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-233">The blob service automatically releases finite leases when they expire.</span></span>  

<span data-ttu-id="0ef5a-234">As concessões permitem que diferentes estratégias de sincronização sejam suportadas, incluindo gravação exclusiva/leitura compartilhada, gravação exclusiva/leitura exclusiva e gravação compartilhada/leitura exclusiva.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-234">Leases enable different synchronization strategies to be supported, including exclusive write / shared read, exclusive write / exclusive read and shared write / exclusive read.</span></span> <span data-ttu-id="0ef5a-235">Nos locais em que há uma concessão, o serviço de Armazenamento impõe gravações exclusivas (operações de exclusão, definição e colocação), mas a garantia de exclusividade para operações de leitura requer que o desenvolvedor garanta que todos os aplicativos cliente usam uma ID de concessão e que apenas um cliente de cada vez tem uma ID de concessão válida.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-235">Where a lease exists the storage service enforces exclusive writes (put, set and delete operations) however ensuring exclusivity for read operations requires the developer to ensure that all client applications use a lease ID and that only one client at a time has a valid lease ID.</span></span> <span data-ttu-id="0ef5a-236">As operações de leitura que não incluem uma ID de concessão resultam em leituras compartilhadas.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-236">Read operations that do not include a lease ID result in shared reads.</span></span>  

<span data-ttu-id="0ef5a-237">O trecho de C# a seguir mostra um exemplo de aquisição de uma concessão exclusiva por 30 segundos em um blob, atualizando o conteúdo do blob e liberando a concessão.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-237">The following C# snippet shows an example of acquiring an exclusive lease for 30 seconds on a blob, updating the content of the blob, and then releasing the lease.</span></span> <span data-ttu-id="0ef5a-238">Se já houver uma concessão válida no blob quando você tentar obter uma nova concessão, o serviço Blob retornará um resultado de status "Conflito HTTP (409)".</span><span class="sxs-lookup"><span data-stu-id="0ef5a-238">If there is already a valid lease on the blob when you try to acquire a new lease, the blob service returns an "HTTP (409) Conflict" status result.</span></span> <span data-ttu-id="0ef5a-239">O trecho abaixo usa um objeto **AccessCondition** para encapsular as informações da concessão quando ela faz uma solicitação para atualizar o blob no serviço de Armazenamento.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-239">The snippet below uses an **AccessCondition** object to encapsulate the lease information when it makes a request to update the blob in the storage service.</span></span>  <span data-ttu-id="0ef5a-240">Você pode baixar o exemplo completo aqui: [Gerenciando a Simultaneidade usando o Armazenamento do Azure](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).</span><span class="sxs-lookup"><span data-stu-id="0ef5a-240">You can download the full sample here: [Managing Concurrency using Azure Storage](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).</span></span>

```csharp
// Acquire lease for 15 seconds
string lease = blockBlob.AcquireLease(TimeSpan.FromSeconds(15), null);
Console.WriteLine("Blob lease acquired. Lease = {0}", lease);

// Update blob using lease. This operation will succeed
const string helloText = "Blob updated";
var accessCondition = AccessCondition.GenerateLeaseCondition(lease);
blockBlob.UploadText(helloText, accessCondition: accessCondition);
Console.WriteLine("Blob updated using an exclusive lease");

//Simulate third party update to blob without lease
try
{
    // Below operation will fail as no valid lease provided
    Console.WriteLine("Trying to update blob without valid lease");
    blockBlob.UploadText("Update without lease, will fail");
}
catch (StorageException ex)
{
    if (ex.RequestInformation.HttpStatusCode == (int)HttpStatusCode.PreconditionFailed)
        Console.WriteLine("Precondition failure as expected. Blob's lease does not match");
    else
        throw;
}  
```

<span data-ttu-id="0ef5a-241">Se você tentar realizar uma operação de gravação em um blob sob concessão sem enviar a ID de concessão, a solicitação falhará com um erro 412.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-241">If you attempt a write operation on a leased blob without passing the lease ID, the request fails with a 412 error.</span></span> <span data-ttu-id="0ef5a-242">Observe que se a concessão expirar antes de chamar o método **UploadText**, mas você ainda utilizar a ID de concessão, a solicitação também falhará com um erro **412**.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-242">Note that if the lease expires before calling the **UploadText** method but you still pass the lease ID, the request also fails with a **412** error.</span></span> <span data-ttu-id="0ef5a-243">Para obter mais informações sobre o gerenciamento de tempos de expiração de concessão e IDs de concessão, consulte a documentação de REST de [Lease Blob](http://msdn.microsoft.com/library/azure/ee691972.aspx) .</span><span class="sxs-lookup"><span data-stu-id="0ef5a-243">For more information about managing lease expiry times and lease ids, see the [Lease Blob](http://msdn.microsoft.com/library/azure/ee691972.aspx) REST documentation.</span></span>  

<span data-ttu-id="0ef5a-244">As operações de blob a seguir podem usar concessões para gerenciar a simultaneidade pessimista:</span><span class="sxs-lookup"><span data-stu-id="0ef5a-244">The following blob operations can use leases to manage pessimistic concurrency:</span></span>  

* <span data-ttu-id="0ef5a-245">Put Blob</span><span class="sxs-lookup"><span data-stu-id="0ef5a-245">Put Blob</span></span>
* <span data-ttu-id="0ef5a-246">Get Blob</span><span class="sxs-lookup"><span data-stu-id="0ef5a-246">Get Blob</span></span>
* <span data-ttu-id="0ef5a-247">Get Blob Properties</span><span class="sxs-lookup"><span data-stu-id="0ef5a-247">Get Blob Properties</span></span>
* <span data-ttu-id="0ef5a-248">Set Blob Properties</span><span class="sxs-lookup"><span data-stu-id="0ef5a-248">Set Blob Properties</span></span>
* <span data-ttu-id="0ef5a-249">Get Blob Metadata</span><span class="sxs-lookup"><span data-stu-id="0ef5a-249">Get Blob Metadata</span></span>
* <span data-ttu-id="0ef5a-250">Set Blob Metadata</span><span class="sxs-lookup"><span data-stu-id="0ef5a-250">Set Blob Metadata</span></span>
* <span data-ttu-id="0ef5a-251">Delete Blob</span><span class="sxs-lookup"><span data-stu-id="0ef5a-251">Delete Blob</span></span>
* <span data-ttu-id="0ef5a-252">Put Block</span><span class="sxs-lookup"><span data-stu-id="0ef5a-252">Put Block</span></span>
* <span data-ttu-id="0ef5a-253">Put Block List</span><span class="sxs-lookup"><span data-stu-id="0ef5a-253">Put Block List</span></span>
* <span data-ttu-id="0ef5a-254">Get Block List</span><span class="sxs-lookup"><span data-stu-id="0ef5a-254">Get Block List</span></span>
* <span data-ttu-id="0ef5a-255">Put Page</span><span class="sxs-lookup"><span data-stu-id="0ef5a-255">Put Page</span></span>
* <span data-ttu-id="0ef5a-256">Get Page Ranges</span><span class="sxs-lookup"><span data-stu-id="0ef5a-256">Get Page Ranges</span></span>
* <span data-ttu-id="0ef5a-257">Snapshot Blob - ID de concessão opcional se existir uma concessão</span><span class="sxs-lookup"><span data-stu-id="0ef5a-257">Snapshot Blob - lease ID optional if a lease exists</span></span>
* <span data-ttu-id="0ef5a-258">Copy Blob - ID de concessão obrigatória se existir uma concessão no blob de destino</span><span class="sxs-lookup"><span data-stu-id="0ef5a-258">Copy Blob - lease ID required if a lease exists on the destination blob</span></span>
* <span data-ttu-id="0ef5a-259">Abort Copy Blob - ID de concessão obrigatória se existir uma concessão infinita no blob de destino</span><span class="sxs-lookup"><span data-stu-id="0ef5a-259">Abort Copy Blob - lease ID required if an infinite lease exists on the destination blob</span></span>
* <span data-ttu-id="0ef5a-260">Lease Blob</span><span class="sxs-lookup"><span data-stu-id="0ef5a-260">Lease Blob</span></span>  

### <a name="pessimistic-concurrency-for-containers"></a><span data-ttu-id="0ef5a-261">Simultaneidade pessimista para contêineres</span><span class="sxs-lookup"><span data-stu-id="0ef5a-261">Pessimistic concurrency for containers</span></span>
<span data-ttu-id="0ef5a-262">As concessões em contêineres permitem que as mesmas estratégias de sincronização sejam suportadas como nos blobs (gravação exclusiva/leitura compartilhada, gravação exclusiva/leitura exclusiva e gravação compartilhada/leitura exclusiva), no entanto, diferente dos blobs, o serviço de Armazenamento impõe exclusividade apenas em operações de exclusão.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-262">Leases on containers enable the same synchronization strategies to be supported as on blobs (exclusive write / shared read, exclusive write / exclusive read and shared write / exclusive read) however unlike blobs the storage service only enforces exclusivity on delete operations.</span></span> <span data-ttu-id="0ef5a-263">Para excluir um contêiner com uma concessão ativa, o cliente deve incluir a ID da concessão ativa com a solicitação de exclusão.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-263">To delete a container with an active lease, a client must include the active lease ID with the delete request.</span></span> <span data-ttu-id="0ef5a-264">Todas as outras operações de contêiner obtiveram êxito em um contêiner sob concessão sem incluir a ID de concessão, caso em que são operações compartilhadas.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-264">All other container operations succeed on a leased container without including the lease ID in which case they are shared operations.</span></span> <span data-ttu-id="0ef5a-265">Se a exclusividade das operações de leitura ou atualização (colocação ou definição) for obrigatória, os desenvolvedores devem garantir que todos os clientes usem uma ID de concessão e que apenas um cliente de cada vez tenha uma ID de concessão válida.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-265">If exclusivity of update (put or set) or read operations is required then developers should ensure all clients use a lease ID and that only one client at a time has a valid lease ID.</span></span>  

<span data-ttu-id="0ef5a-266">As operações de contêiner a seguir podem usar concessões para gerenciar a simultaneidade pessimista:</span><span class="sxs-lookup"><span data-stu-id="0ef5a-266">The following container operations can use leases to manage pessimistic concurrency:</span></span>  

* <span data-ttu-id="0ef5a-267">Delete Container</span><span class="sxs-lookup"><span data-stu-id="0ef5a-267">Delete Container</span></span>
* <span data-ttu-id="0ef5a-268">Get Container Properties</span><span class="sxs-lookup"><span data-stu-id="0ef5a-268">Get Container Properties</span></span>
* <span data-ttu-id="0ef5a-269">Get Container Metadata</span><span class="sxs-lookup"><span data-stu-id="0ef5a-269">Get Container Metadata</span></span>
* <span data-ttu-id="0ef5a-270">Set Container Metadata</span><span class="sxs-lookup"><span data-stu-id="0ef5a-270">Set Container Metadata</span></span>
* <span data-ttu-id="0ef5a-271">Get Container ACL</span><span class="sxs-lookup"><span data-stu-id="0ef5a-271">Get Container ACL</span></span>
* <span data-ttu-id="0ef5a-272">Set Container ACL</span><span class="sxs-lookup"><span data-stu-id="0ef5a-272">Set Container ACL</span></span>
* <span data-ttu-id="0ef5a-273">Lease Container</span><span class="sxs-lookup"><span data-stu-id="0ef5a-273">Lease Container</span></span>  

<span data-ttu-id="0ef5a-274">Para obter mais informações, consulte:</span><span class="sxs-lookup"><span data-stu-id="0ef5a-274">For more information see:</span></span>  

* [<span data-ttu-id="0ef5a-275">Especificando cabeçalhos condicionais para operações do serviço Blob</span><span class="sxs-lookup"><span data-stu-id="0ef5a-275">Specifying Conditional Headers for Blob Service Operations</span></span>](http://msdn.microsoft.com/library/azure/dd179371.aspx)
* [<span data-ttu-id="0ef5a-276">Lease Container</span><span class="sxs-lookup"><span data-stu-id="0ef5a-276">Lease Container</span></span>](http://msdn.microsoft.com/library/azure/jj159103.aspx)
* [<span data-ttu-id="0ef5a-277">Lease Blob </span><span class="sxs-lookup"><span data-stu-id="0ef5a-277">Lease Blob </span></span>](http://msdn.microsoft.com/library/azure/ee691972.aspx)

## <a name="managing-concurrency-in-the-table-service"></a><span data-ttu-id="0ef5a-278">Gerenciando a simultaneidade no serviço Tabela</span><span class="sxs-lookup"><span data-stu-id="0ef5a-278">Managing Concurrency in the Table Service</span></span>
<span data-ttu-id="0ef5a-279">O serviço Tabela usa verificações de simultaneidade otimista como o comportamento padrão quando você está trabalhando com entidades, diferente do serviço Blob, em que é necessário escolher explicitamente realizar verificações de simultaneidade otimista.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-279">The table service uses optimistic concurrency checks as the default behavior when you are working with entities, unlike the blob service where you must explicitly choose to perform optimistic concurrency checks.</span></span> <span data-ttu-id="0ef5a-280">A outra diferença entre os serviços Tabela e Blob é que você pode gerenciar apenas o comportamento de simultaneidade de entidades, enquanto que com o serviço Blob é possível gerenciar a simultaneidade de contêineres e blobs.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-280">The other difference between the table and blob services is that you can only manage the concurrency behavior of entities whereas with the blob service you can manage the concurrency of both containers and blobs.</span></span>  

<span data-ttu-id="0ef5a-281">Para usar a simultaneidade otimista e verificar se outro processo modificou uma entidade desde que você a recuperou do serviço de armazenamento de tabela, é possível usar o valor da ETag recebido quando o serviço Tabela retorna uma entidade.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-281">To use optimistic concurrency and to check if another process modified an entity since you retrieved it from the table storage service, you can use the ETag value you receive when the table service returns an entity.</span></span> <span data-ttu-id="0ef5a-282">A estrutura desse processo é a seguinte:</span><span class="sxs-lookup"><span data-stu-id="0ef5a-282">The outline of this process is as follows:</span></span>  

1. <span data-ttu-id="0ef5a-283">Recupere uma entidade do serviço de armazenamento de tabela, a resposta inclui um valor de ETag que identifica o identificador atual associado a essa entidade no serviço de Armazenamento.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-283">Retrieve an entity from the table storage service, the response includes an ETag value that identifies the current identifier associated with that entity in the storage service.</span></span>
2. <span data-ttu-id="0ef5a-284">Ao atualizar a entidade, inclua o valor da ETag recebido na etapa 1 no cabeçalho obrigatório **If-Match** da solicitação enviada para o serviço.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-284">When you update the entity, include the ETag value you received in step 1 in the mandatory **If-Match** header of the request you send to the service.</span></span>
3. <span data-ttu-id="0ef5a-285">O serviço compara o valor da ETag na solicitação com o valor da ETag atual da entidade.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-285">The service compares the ETag value in the request with the current ETag value of the entity.</span></span>
4. <span data-ttu-id="0ef5a-286">Se o valor da ETag atual da entidade for diferente da ETag no cabeçalho obrigatório **If-Match** na solicitação, o serviço retornará um erro 412 para o cliente.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-286">If the current ETag value of the entity is different than the ETag in the mandatory **If-Match** header in the request, the service returns a 412 error to the client.</span></span> <span data-ttu-id="0ef5a-287">Isso indica para o cliente que outro processo atualizou a entidade desde que ele a recuperou.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-287">This indicates to the client that another process has updated the entity since the client retrieved it.</span></span>
5. <span data-ttu-id="0ef5a-288">Se o valor da ETag atual da entidade for o mesmo da ETag no cabeçalho obrigatório **If-Match** na solicitação ou o cabeçalho **If-Match** contiver o caractere curinga (*), o serviço realizará a operação solicitada e atualizará o valor da ETag atual da entidade para mostrar que ela foi atualizada.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-288">If the current ETag value of the entity is the same as the ETag in the mandatory **If-Match** header in the request or the **If-Match** header contains the wildcard character (*), the service performs the requested operation and updates the current ETag value of the entity to show that it has been updated.</span></span>  

<span data-ttu-id="0ef5a-289">Observe que diferente do serviço Blob, o serviço Tabela exige que o cliente inclua um cabeçalho **If-Match** em solicitações de atualização.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-289">Note that unlike the blob service, the table service requires the client to include an **If-Match** header in update requests.</span></span> <span data-ttu-id="0ef5a-290">No entanto, é possível forçar uma atualização incondicional (estratégia último a gravar vence) e ignorar as verificações de simultaneidade se o cliente definir o cabeçalho **If-Match** com o caractere curinga (*) na solicitação.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-290">However, it is possible to force an unconditional update (last writer wins strategy) and bypass concurrency checks if the client sets the **If-Match** header to the wildcard character (*) in the request.</span></span>  

<span data-ttu-id="0ef5a-291">O trecho de C# a seguir mostra uma entidade de cliente que foi criada ou recuperada anteriormente tendo seu endereço de email atualizado.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-291">The following C# snippet shows a customer entity that was previously either created or retrieved having their email address updated.</span></span> <span data-ttu-id="0ef5a-292">A operação de recuperação ou inserção inicial armazena o valor da ETag no objeto do cliente e, como a amostra usa a mesma instância de objeto ao executar a operação de substituição, ela automaticamente envia o valor da ETag de volta ao serviço Tabela, permitindo que o serviço verifique se há violações de simultaneidade.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-292">The initial insert or retrieve operation stores the ETag value in the customer object, and because the sample uses the same object instance when it executes the replace operation, it automatically sends the ETag value back to the table service, enabling the service to check for concurrency violations.</span></span> <span data-ttu-id="0ef5a-293">Se outro processo atualizou a entidade no armazenamento de tabela, o serviço retorna uma mensagem de status HTTP 412 (Falha de precondição).</span><span class="sxs-lookup"><span data-stu-id="0ef5a-293">If another process has updated the entity in table storage, the service returns an HTTP 412 (Precondition Failed) status message.</span></span>  <span data-ttu-id="0ef5a-294">Você pode baixar o exemplo completo aqui: [Gerenciando a Simultaneidade usando o Armazenamento do Azure](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).</span><span class="sxs-lookup"><span data-stu-id="0ef5a-294">You can download the full sample here: [Managing Concurrency using Azure Storage](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).</span></span>

```csharp
try
{
    customer.Email = "updatedEmail@contoso.org";
    TableOperation replaceCustomer = TableOperation.Replace(customer);
    customerTable.Execute(replaceCustomer);
    Console.WriteLine("Replace operation succeeded.");
}
catch (StorageException ex)
{
    if (ex.RequestInformation.HttpStatusCode == 412)
        Console.WriteLine("Optimistic concurrency violation – entity has changed since it was retrieved.");
    else
        throw;
}  
```

<span data-ttu-id="0ef5a-295">Para desabilitar explicitamente a verificação de simultaneidade, você deve definir a propriedade **ETag** do objeto **employee** para "*" antes de executar a operação de substituição.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-295">To explicitly disable the concurrency check, you should set the **ETag** property of the **employee** object to "*" before you execute the replace operation.</span></span>  

```csharp
customer.ETag = "*";  
```

<span data-ttu-id="0ef5a-296">A tabela a seguir resume como as operações de entidade de tabela usam os valores de ETag:</span><span class="sxs-lookup"><span data-stu-id="0ef5a-296">The following table summarizes how the table entity operations use ETag values:</span></span>

| <span data-ttu-id="0ef5a-297">Operação</span><span class="sxs-lookup"><span data-stu-id="0ef5a-297">Operation</span></span> | <span data-ttu-id="0ef5a-298">Retorna o valor de ETag</span><span class="sxs-lookup"><span data-stu-id="0ef5a-298">Returns ETag value</span></span> | <span data-ttu-id="0ef5a-299">Requer o cabeçalho de solicitação If-Match</span><span class="sxs-lookup"><span data-stu-id="0ef5a-299">Requires If-Match request header</span></span> |
|:--- |:--- |:--- |
| <span data-ttu-id="0ef5a-300">Query Entities</span><span class="sxs-lookup"><span data-stu-id="0ef5a-300">Query Entities</span></span> |<span data-ttu-id="0ef5a-301">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-301">Yes</span></span> |<span data-ttu-id="0ef5a-302">Não</span><span class="sxs-lookup"><span data-stu-id="0ef5a-302">No</span></span> |
| <span data-ttu-id="0ef5a-303">Insert Entity</span><span class="sxs-lookup"><span data-stu-id="0ef5a-303">Insert Entity</span></span> |<span data-ttu-id="0ef5a-304">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-304">Yes</span></span> |<span data-ttu-id="0ef5a-305">Não</span><span class="sxs-lookup"><span data-stu-id="0ef5a-305">No</span></span> |
| <span data-ttu-id="0ef5a-306">Update Entity</span><span class="sxs-lookup"><span data-stu-id="0ef5a-306">Update Entity</span></span> |<span data-ttu-id="0ef5a-307">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-307">Yes</span></span> |<span data-ttu-id="0ef5a-308">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-308">Yes</span></span> |
| <span data-ttu-id="0ef5a-309">Merge Entity</span><span class="sxs-lookup"><span data-stu-id="0ef5a-309">Merge Entity</span></span> |<span data-ttu-id="0ef5a-310">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-310">Yes</span></span> |<span data-ttu-id="0ef5a-311">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-311">Yes</span></span> |
| <span data-ttu-id="0ef5a-312">Delete Entity</span><span class="sxs-lookup"><span data-stu-id="0ef5a-312">Delete Entity</span></span> |<span data-ttu-id="0ef5a-313">Não</span><span class="sxs-lookup"><span data-stu-id="0ef5a-313">No</span></span> |<span data-ttu-id="0ef5a-314">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-314">Yes</span></span> |
| <span data-ttu-id="0ef5a-315">Insert or Replace Entity</span><span class="sxs-lookup"><span data-stu-id="0ef5a-315">Insert or Replace Entity</span></span> |<span data-ttu-id="0ef5a-316">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-316">Yes</span></span> |<span data-ttu-id="0ef5a-317">Não</span><span class="sxs-lookup"><span data-stu-id="0ef5a-317">No</span></span> |
| <span data-ttu-id="0ef5a-318">Insert or Merge Entity</span><span class="sxs-lookup"><span data-stu-id="0ef5a-318">Insert or Merge Entity</span></span> |<span data-ttu-id="0ef5a-319">Sim</span><span class="sxs-lookup"><span data-stu-id="0ef5a-319">Yes</span></span> |<span data-ttu-id="0ef5a-320">Não</span><span class="sxs-lookup"><span data-stu-id="0ef5a-320">No</span></span> |

<span data-ttu-id="0ef5a-321">Observe que as operações **Insert or Replace Entity** e **Insert or Merge Entity** *não* realizam nenhuma verificação de simultaneidade, pois não enviam um valor de ETag para o serviço Tabela.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-321">Note that the **Insert or Replace Entity** and **Insert or Merge Entity** operations do *not* perform any concurrency checks because they do not send an ETag value to the table service.</span></span>  

<span data-ttu-id="0ef5a-322">Em geral, os desenvolvedores usando tabelas devem recorrer à simultaneidade otimista ao desenvolver aplicativos escalonáveis.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-322">In general developers using tables should rely on optimistic concurrency when developing scalable applications.</span></span> <span data-ttu-id="0ef5a-323">Se o bloqueio pessimista for necessário, uma abordagem que os desenvolvedores podem adotar ao acessar tabelas é atribuir um blob designado para cada tabela e tentar obter uma concessão no blob antes de operar na tabela.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-323">If pessimistic locking is needed, one approach developers can take when accessing Tables is to assign a designated blob for each table and try to take a lease on the blob before operating on the table.</span></span> <span data-ttu-id="0ef5a-324">Essa abordagem exige que o aplicativo garanta que todos os caminhos de acesso de dados obtenham a concessão antes de operar na tabela.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-324">This approach does require the application to ensure all data access paths obtain the lease prior to operating on the table.</span></span> <span data-ttu-id="0ef5a-325">Você também deve observar que o tempo mínimo de concessão é de 15 segundos, o que exige uma consideração cuidadosa quanto à escalabilidade.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-325">You should also note that the minimum lease time is 15 seconds which requires careful consideration for scalability.</span></span>  

<span data-ttu-id="0ef5a-326">Para obter mais informações, consulte:</span><span class="sxs-lookup"><span data-stu-id="0ef5a-326">For more information see:</span></span>  

* [<span data-ttu-id="0ef5a-327">Operações em entidades</span><span class="sxs-lookup"><span data-stu-id="0ef5a-327">Operations on Entities</span></span>](http://msdn.microsoft.com/library/azure/dd179375.aspx)  

## <a name="managing-concurrency-in-the-queue-service"></a><span data-ttu-id="0ef5a-328">Gerenciando a simultaneidade no serviço Fila</span><span class="sxs-lookup"><span data-stu-id="0ef5a-328">Managing Concurrency in the Queue Service</span></span>
<span data-ttu-id="0ef5a-329">Um cenário em que a simultaneidade é uma preocupação no serviço de filas ocorre quando vários clientes recuperam mensagens de uma fila.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-329">One scenario in which concurrency is a concern in the queueing service is where multiple clients are retrieving messages from a queue.</span></span> <span data-ttu-id="0ef5a-330">Quando uma mensagem é recuperada da fila, a resposta inclui a mensagem e um valor de recebimento pop, que é necessário para excluir a mensagem.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-330">When a message is retrieved from the queue, the response includes the message and a pop receipt value, which is required to delete the message.</span></span> <span data-ttu-id="0ef5a-331">A mensagem não é automaticamente excluída da fila, mas após ser recuperada, não fica visível para outros clientes pelo intervalo de tempo especificado pelo parâmetro visibilitytimeout.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-331">The message is not automatically deleted from the queue, but after it has been retrieved, it is not visible to other clients for the time interval specified by the visibilitytimeout parameter.</span></span> <span data-ttu-id="0ef5a-332">Espera-se que o cliente que recuperou a mensagem a exclua após ela ser processada e antes do tempo especificado pelo elemento TimeNextVisible da resposta, que é calculado com base no valor do parâmetro visibilitytimeout.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-332">The client that retrieves the message is expected to delete the message after it has been processed, and before the time specified by the TimeNextVisible element of the response, which is calculated based on the value of the visibilitytimeout parameter.</span></span> <span data-ttu-id="0ef5a-333">O valor de visibilitytimeout é adicionado ao horário em que a mensagem é recuperada para determinar o valor de TimeNextVisible.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-333">The value of visibilitytimeout is added to the time at which the message is retrieved to determine the value of TimeNextVisible.</span></span>  

<span data-ttu-id="0ef5a-334">O serviço Fila não tem suporte para a simultaneidade pessimista ou otimista e, por essa razão, os clientes que processam mensagens recuperadas de uma fila devem garantir que elas sejam processadas de uma maneira idempotente.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-334">The queue service does not have support for either optimistic or pessimistic concurrency and for this reason clients processing messages retrieved from a queue should ensure messages are processed in an idempotent manner.</span></span> <span data-ttu-id="0ef5a-335">A estratégia último a gravar vence é usada para operações de atualização, como SetQueueServiceProperties, SetQueueMetaData, SetQueueACL e UpdateMessage.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-335">A last writer wins strategy is used for update operations such as SetQueueServiceProperties, SetQueueMetaData, SetQueueACL and UpdateMessage.</span></span>  

<span data-ttu-id="0ef5a-336">Para obter mais informações, consulte:</span><span class="sxs-lookup"><span data-stu-id="0ef5a-336">For more information see:</span></span>  

* [<span data-ttu-id="0ef5a-337">API REST do serviço Fila</span><span class="sxs-lookup"><span data-stu-id="0ef5a-337">Queue Service REST API</span></span>](http://msdn.microsoft.com/library/azure/dd179363.aspx)
* [<span data-ttu-id="0ef5a-338">Receber mensagens</span><span class="sxs-lookup"><span data-stu-id="0ef5a-338">Get Messages</span></span>](http://msdn.microsoft.com/library/azure/dd179474.aspx)  

## <a name="managing-concurrency-in-the-file-service"></a><span data-ttu-id="0ef5a-339">Gerenciando a simultaneidade no serviço Arquivo</span><span class="sxs-lookup"><span data-stu-id="0ef5a-339">Managing Concurrency in the File Service</span></span>
<span data-ttu-id="0ef5a-340">O serviço Arquivo pode ser acessado usando dois pontos de extremidade de protocolo diferentes: SMB e REST.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-340">The file service can be accessed using two different protocol endpoints – SMB and REST.</span></span> <span data-ttu-id="0ef5a-341">O serviço REST não tem suporte para o bloqueio otimista ou pessimista e todas as atualizações seguirão a estratégia último a gravar vence.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-341">The REST service does not have support for either optimistic locking or pessimistic locking and all updates will follow a last writer wins strategy.</span></span> <span data-ttu-id="0ef5a-342">Os clientes SMB que montam compartilhamentos de arquivos podem utilizar os mecanismos de bloqueio do sistema de arquivos para gerenciar o acesso aos arquivos compartilhados, incluindo a capacidade de realizar o bloqueio pessimista.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-342">SMB clients that mount file shares can leverage file system locking mechanisms to manage access to shared files – including the ability to perform pessimistic locking.</span></span> <span data-ttu-id="0ef5a-343">Quando um cliente SMB abre um arquivo, ele especifica o modo de compartilhamento e de acesso do arquivo.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-343">When an SMB client opens a file, it specifies both the file access and share mode.</span></span> <span data-ttu-id="0ef5a-344">Configurar uma opção de Acesso ao Arquivo de “Gravação” ou “Leitura/Gravação” juntamente com um modo de Compartilhamento de Arquivo de “Nenhum” resultará no bloqueio do arquivo por um cliente SMB até o arquivo ser fechado.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-344">Setting a File Access option of "Write" or "Read/Write" along with a File Share mode of "None" will result in the file being locked by an SMB client until the file is closed.</span></span> <span data-ttu-id="0ef5a-345">Se houver a tentativa de realização da operação REST em um arquivo em que um cliente SMB tenha o arquivo bloqueado, o serviço REST retornará o código de status 409 (Conflito) com o código de erro SharingViolation.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-345">If REST operation is attempted on a file where an SMB client has the file locked the REST service will return status code 409 (Conflict) with error code SharingViolation.</span></span>  

<span data-ttu-id="0ef5a-346">Quando um cliente SMB abre um arquivo para exclusão, ele marca o arquivo como exclusão pendente até que todos os outros identificadores abertos do cliente SMB em tal arquivo sejam fechados.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-346">When an SMB client opens a file for delete, it marks the file as pending delete until all other SMB client open handles on that file are closed.</span></span> <span data-ttu-id="0ef5a-347">Enquanto um arquivo estiver marcado como com exclusão pendente, todas as operações REST em tal arquivo retornarão o código de status 409 (Conflito) com o código de erro SMBDeletePending.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-347">While a file is marked as pending delete, any REST operation on that file will return status code 409 (Conflict) with error code SMBDeletePending.</span></span> <span data-ttu-id="0ef5a-348">O código de status 404 (Não encontrado) não é retornado, uma vez que é possível que o cliente SMB remova o sinalizador de exclusão pendente antes de fechar o arquivo.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-348">Status code 404 (Not Found) is not returned since it is possible for the SMB client to remove the pending deletion flag prior to closing the file.</span></span> <span data-ttu-id="0ef5a-349">Em outras palavras, o código de status 404 (Não encontrado) é esperado apenas se o arquivo tiver sido removido.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-349">In other words, status code 404 (Not Found) is only expected when the file has been removed.</span></span> <span data-ttu-id="0ef5a-350">Observe que enquanto um arquivo estiver no estado de exclusão pendente do SMB, ele não será incluído nos resultados de Listar Arquivos. Observe também que as operações REST Delete File e REST Delete Directory são confirmadas de forma atômica e não resultam no estado de exclusão pendente.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-350">Note that while a file is in a SMB pending delete state, it will not be included in the List Files results.Also note that the REST Delete File and REST Delete Directory operations are committed atomically and do not result in pending delete state.</span></span>  

<span data-ttu-id="0ef5a-351">Para obter mais informações, consulte:</span><span class="sxs-lookup"><span data-stu-id="0ef5a-351">For more information see:</span></span>  

* [<span data-ttu-id="0ef5a-352">Gerenciando bloqueios de arquivo</span><span class="sxs-lookup"><span data-stu-id="0ef5a-352">Managing File Locks</span></span>](http://msdn.microsoft.com/library/azure/dn194265.aspx)  

## <a name="summary-and-next-steps"></a><span data-ttu-id="0ef5a-353">Resumo e próximas etapas</span><span class="sxs-lookup"><span data-stu-id="0ef5a-353">Summary and Next Steps</span></span>
<span data-ttu-id="0ef5a-354">O serviço de Armazenamento do Microsoft Azure foi desenvolvido para atender às necessidades dos aplicativos online mais complexos sem forçar os desenvolvedores a comprometerem ou repensarem as principais pressuposições de design, como a simultaneidade e a consistência de dados, as quais eles já consideram corriqueiras.</span><span class="sxs-lookup"><span data-stu-id="0ef5a-354">The Microsoft Azure Storage service has been designed to meet the needs of the most complex online applications without forcing developers to compromise or rethink key design assumptions such as concurrency and data consistency that they have come to take for granted.</span></span>  

<span data-ttu-id="0ef5a-355">Para encontrar o aplicativo de amostra completo citado nesse blog:</span><span class="sxs-lookup"><span data-stu-id="0ef5a-355">For the complete sample application referenced in this blog:</span></span>  

* [<span data-ttu-id="0ef5a-356">Gerenciando a simultaneidade usando o Armazenamento do Azure — aplicativo de amostra</span><span class="sxs-lookup"><span data-stu-id="0ef5a-356">Managing Concurrency using Azure Storage - Sample Application</span></span>](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114)  

<span data-ttu-id="0ef5a-357">Para obter mais informações sobre Armazenamento do Azure, consulte:</span><span class="sxs-lookup"><span data-stu-id="0ef5a-357">For more information on Azure Storage see:</span></span>  

* [<span data-ttu-id="0ef5a-358">Página inicial do Armazenamento do Microsoft Azure</span><span class="sxs-lookup"><span data-stu-id="0ef5a-358">Microsoft Azure Storage Home Page</span></span>](https://azure.microsoft.com/services/storage/)
* [<span data-ttu-id="0ef5a-359">Introdução ao Armazenamento do Azure</span><span class="sxs-lookup"><span data-stu-id="0ef5a-359">Introduction to Azure Storage</span></span>](storage-introduction.md)
* <span data-ttu-id="0ef5a-360">Introdução ao Armazenamento para [Blob](storage-dotnet-how-to-use-blobs.md), [Tabela](storage-dotnet-how-to-use-tables.md), [Filas](storage-dotnet-how-to-use-queues.md) e [Arquivos](storage-dotnet-how-to-use-files.md)</span><span class="sxs-lookup"><span data-stu-id="0ef5a-360">Storage Getting Started for [Blob](storage-dotnet-how-to-use-blobs.md), [Table](storage-dotnet-how-to-use-tables.md),  [Queues](storage-dotnet-how-to-use-queues.md), and [Files](storage-dotnet-how-to-use-files.md)</span></span>
* <span data-ttu-id="0ef5a-361">Arquitetura de Armazenamento – [Armazenamento do Azure: um serviço de armazenamento em nuvem altamente disponível com coerência forte](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx)</span><span class="sxs-lookup"><span data-stu-id="0ef5a-361">Storage Architecture – [Azure Storage : A Highly Available Cloud Storage Service with Strong Consistency](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx)</span></span>


---
title: Guia de Design de tabela de armazenamento do Azure | Microsoft Docs
description: "Projete tabelas escalonáveis e de alto desempenho no Armazenamento de Tabelas do Azure"
services: storage
documentationcenter: na
author: jasonnewyork
manager: tadb
editor: tysonn
ms.assetid: 8e228b0c-2998-4462-8101-9f16517393ca
ms.service: storage
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: storage
ms.date: 02/28/2017
ms.author: jahogg
ms.openlocfilehash: 5ddb234cc97b3113ec865f97195c871b9f2f40d3
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 07/11/2017
---
# <a name="azure-storage-table-design-guide-designing-scalable-and-performant-tables"></a><span data-ttu-id="3bcd8-103">Guia de Design de tabela de armazenamento do Azure: projetando tabelas escalonáveis e de alto desempenho</span><span class="sxs-lookup"><span data-stu-id="3bcd8-103">Azure Storage Table Design Guide: Designing Scalable and Performant Tables</span></span>
[!INCLUDE [storage-table-cosmos-db-tip-include](../../includes/storage-table-cosmos-db-tip-include.md)]

<span data-ttu-id="3bcd8-104">Para projetar tabelas escalonáveis e de alto desempenho, você deve considerar vários fatores, como desempenho, escalabilidade e custo.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-104">To design scalable and performant tables you must consider a number of factors such as performance, scalability, and cost.</span></span> <span data-ttu-id="3bcd8-105">Se você tiver criado anteriormente esquemas de bancos de dados relacionais, essas considerações serão familiares para você, mas embora haja algumas semelhanças entre o modelo de armazenamento do serviço Tabela do Azure e os modelos relacionais, também há várias diferenças importantes.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-105">If you have previously designed schemas for relational databases, these considerations will be familiar to you, but while there are some similarities between the Azure Table service storage model and relational models, there are also many important differences.</span></span> <span data-ttu-id="3bcd8-106">Normalmente, essas diferenças resultam em muito designs diferentes que podem parecer contraintuitivos ou errados para alguém que esteja familiarizado com bancos de dados relacionais, mas que fazem sentido se você estiver criando para um armazenamento de chave/valor de NoSQL, como o serviço Tabela do Azure.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-106">These differences typically lead to very different designs that may look counter-intuitive or wrong to someone familiar with relational databases, but which do make good sense if you are designing for a NoSQL key/value store such as the Azure Table service.</span></span> <span data-ttu-id="3bcd8-107">Muitas das suas diferenças de design refletirão o fato de que o serviço Tabela foi projetado para dar suporte a aplicativos de escala de nuvem que podem conter bilhões de entidades (linhas na terminologia de banco de dados relacional) de dados ou de conjuntos de dados que devem dar suporte a grandes volumes de transações: por isso, você precisa pensar de forma diferente sobre como armazenar seus dados e entender como funciona o serviço Tabela.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-107">Many of your design differences will reflect the fact that the Table service is designed to support cloud-scale applications that can contain billions of entities (rows in relational database terminology) of data or for datasets that must support very high transaction volumes: therefore, you need to think differently about how you store your data and understand how the Table service works.</span></span> <span data-ttu-id="3bcd8-108">Um repositório de dados NoSQL bem projetado pode permitir que sua solução seja muito mais dimensionável (e a um custo menor) do que uma solução que usa um banco de dados relacional.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-108">A well designed NoSQL data store can enable your solution to scale much further (and at a lower cost) than a solution that uses a relational database.</span></span> <span data-ttu-id="3bcd8-109">Este guia ajuda você com esses tópicos.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-109">This guide helps you with these topics.</span></span>  

## <a name="about-the-azure-table-service"></a><span data-ttu-id="3bcd8-110">Sobre o serviço Tabela do Azure</span><span class="sxs-lookup"><span data-stu-id="3bcd8-110">About the Azure Table service</span></span>
<span data-ttu-id="3bcd8-111">Esta seção destaca alguns dos principais recursos do serviço Tabela que são especialmente relevantes para o projeto de desempenho e escalabilidade.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-111">This section highlights some of the key features of the Table service that are especially relevant to designing for performance and scalability.</span></span> <span data-ttu-id="3bcd8-112">Se você não tiver experiência no Armazenamento do Azure e no serviço Tabela, leia primeiro [Introdução ao Armazenamento do Microsoft Azure](storage-introduction.md) e [Introdução ao armazenamento de Tabelas do Azure usando o .NET](storage-dotnet-how-to-use-tables.md) antes de ler o restante deste artigo.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-112">If you are new to Azure Storage and the Table service, first read [Introduction to Microsoft Azure Storage](storage-introduction.md) and [Get started with Azure Table Storage using .NET](storage-dotnet-how-to-use-tables.md) before reading the remainder of this article.</span></span> <span data-ttu-id="3bcd8-113">Embora o foco deste guia seja no serviço Tabela, ele incluirá alguma discussão dos serviços Blob e fila do Azure e como você pode usá-los junto com o serviço Tabela em uma solução.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-113">Although the focus of this guide is on the Table service, it will include some discussion of the Azure Queue and Blob services, and how you might use them along with the Table service in a solution.</span></span>  

<span data-ttu-id="3bcd8-114">O que é o serviço Tabela?</span><span class="sxs-lookup"><span data-stu-id="3bcd8-114">What is the Table service?</span></span> <span data-ttu-id="3bcd8-115">Como você pode esperar do nome, o serviço Tabela usa um formato tabular para armazenar dados.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-115">As you might expect from the name, the Table service uses a tabular format to store data.</span></span> <span data-ttu-id="3bcd8-116">Na terminologia padrão, cada linha da tabela representa uma entidade e as colunas armazenam várias propriedades da entidade.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-116">In the standard terminology, each row of the table represents an entity, and the columns store the various properties of that entity.</span></span> <span data-ttu-id="3bcd8-117">Cada entidade tem um par de chaves para identificá-la exclusivamente, e uma coluna de carimbo de data/hora que o serviço Tabela usa para controlar quando a entidade foi atualizada (isso ocorre automaticamente e não é possível substituir manualmente o carimbo de data/hora por um valor arbitrário).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-117">Every entity has a pair of keys to uniquely identify it, and a timestamp column that the Table service uses to track when the entity was last updated (this happens automatically and you cannot manually overwrite the timestamp with an arbitrary value).</span></span> <span data-ttu-id="3bcd8-118">O serviço Tabela usa este carimbo de data/hora (LMT) da última modificação para gerenciar a simultaneidade otimista.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-118">The Table service uses this last-modified timestamp (LMT) to manage optimistic concurrency.</span></span>  

> [!NOTE]
> <span data-ttu-id="3bcd8-119">As operações de API REST do serviço Tabela também retornam um valor **ETag** obtido com o LMT.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-119">The Table service REST API operations also return an **ETag** value that it derives from the last-modified timestamp (LMT).</span></span> <span data-ttu-id="3bcd8-120">Neste documento, usaremos os termos ETag e LMT indistintamente porque eles se referem aos mesmos dados subjacentes.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-120">In this document we will use the terms ETag and LMT interchangeably because they refer to the same underlying data.</span></span>  
> 
> 

<span data-ttu-id="3bcd8-121">O exemplo a seguir mostra uma estrutura de tabela simples para armazenar entidades de funcionário e departamento.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-121">The following example shows a simple table design to store employee and department entities.</span></span> <span data-ttu-id="3bcd8-122">Muitos dos exemplos mostrados posteriormente neste guia baseiam-se neste design simples.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-122">Many of the examples shown later in this guide are based on this simple design.</span></span>  

<table>
<tr>
<th><span data-ttu-id="3bcd8-123">PartitionKey</span><span class="sxs-lookup"><span data-stu-id="3bcd8-123">PartitionKey</span></span></th>
<th><span data-ttu-id="3bcd8-124">RowKey</span><span class="sxs-lookup"><span data-stu-id="3bcd8-124">RowKey</span></span></th>
<th><span data-ttu-id="3bcd8-125">Timestamp</span><span class="sxs-lookup"><span data-stu-id="3bcd8-125">Timestamp</span></span></th>
<th></th>
</tr>
<tr>
<td><span data-ttu-id="3bcd8-126">Marketing</span><span class="sxs-lookup"><span data-stu-id="3bcd8-126">Marketing</span></span></td>
<td><span data-ttu-id="3bcd8-127">00001</span><span class="sxs-lookup"><span data-stu-id="3bcd8-127">00001</span></span></td>
<td><span data-ttu-id="3bcd8-128">2014-08-22T00:50:32Z</span><span class="sxs-lookup"><span data-stu-id="3bcd8-128">2014-08-22T00:50:32Z</span></span></td>
<td>
<table>
<tr>
<th><span data-ttu-id="3bcd8-129">Nome</span><span class="sxs-lookup"><span data-stu-id="3bcd8-129">FirstName</span></span></th>
<th><span data-ttu-id="3bcd8-130">Sobrenome</span><span class="sxs-lookup"><span data-stu-id="3bcd8-130">LastName</span></span></th>
<th><span data-ttu-id="3bcd8-131">Idade</span><span class="sxs-lookup"><span data-stu-id="3bcd8-131">Age</span></span></th>
<th><span data-ttu-id="3bcd8-132">Email</span><span class="sxs-lookup"><span data-stu-id="3bcd8-132">Email</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="3bcd8-133">Don</span><span class="sxs-lookup"><span data-stu-id="3bcd8-133">Don</span></span></td>
<td><span data-ttu-id="3bcd8-134">Hall</span><span class="sxs-lookup"><span data-stu-id="3bcd8-134">Hall</span></span></td>
<td><span data-ttu-id="3bcd8-135">34</span><span class="sxs-lookup"><span data-stu-id="3bcd8-135">34</span></span></td>
<td>donh@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td><span data-ttu-id="3bcd8-136">Marketing</span><span class="sxs-lookup"><span data-stu-id="3bcd8-136">Marketing</span></span></td>
<td><span data-ttu-id="3bcd8-137">00002</span><span class="sxs-lookup"><span data-stu-id="3bcd8-137">00002</span></span></td>
<td><span data-ttu-id="3bcd8-138">2014-08-22T00:50:34Z</span><span class="sxs-lookup"><span data-stu-id="3bcd8-138">2014-08-22T00:50:34Z</span></span></td>
<td>
<table>
<tr>
<th><span data-ttu-id="3bcd8-139">Nome</span><span class="sxs-lookup"><span data-stu-id="3bcd8-139">FirstName</span></span></th>
<th><span data-ttu-id="3bcd8-140">Sobrenome</span><span class="sxs-lookup"><span data-stu-id="3bcd8-140">LastName</span></span></th>
<th><span data-ttu-id="3bcd8-141">Idade</span><span class="sxs-lookup"><span data-stu-id="3bcd8-141">Age</span></span></th>
<th><span data-ttu-id="3bcd8-142">Email</span><span class="sxs-lookup"><span data-stu-id="3bcd8-142">Email</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="3bcd8-143">Jun</span><span class="sxs-lookup"><span data-stu-id="3bcd8-143">Jun</span></span></td>
<td><span data-ttu-id="3bcd8-144">Cao</span><span class="sxs-lookup"><span data-stu-id="3bcd8-144">Cao</span></span></td>
<td><span data-ttu-id="3bcd8-145">47</span><span class="sxs-lookup"><span data-stu-id="3bcd8-145">47</span></span></td>
<td>junc@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td><span data-ttu-id="3bcd8-146">Marketing</span><span class="sxs-lookup"><span data-stu-id="3bcd8-146">Marketing</span></span></td>
<td><span data-ttu-id="3bcd8-147">Departamento</span><span class="sxs-lookup"><span data-stu-id="3bcd8-147">Department</span></span></td>
<td><span data-ttu-id="3bcd8-148">2014-08-22T00:50:30Z</span><span class="sxs-lookup"><span data-stu-id="3bcd8-148">2014-08-22T00:50:30Z</span></span></td>
<td>
<table>
<tr>
<th><span data-ttu-id="3bcd8-149">DepartmentName</span><span class="sxs-lookup"><span data-stu-id="3bcd8-149">DepartmentName</span></span></th>
<th><span data-ttu-id="3bcd8-150">EmployeeCount</span><span class="sxs-lookup"><span data-stu-id="3bcd8-150">EmployeeCount</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="3bcd8-151">Marketing</span><span class="sxs-lookup"><span data-stu-id="3bcd8-151">Marketing</span></span></td>
<td><span data-ttu-id="3bcd8-152">153</span><span class="sxs-lookup"><span data-stu-id="3bcd8-152">153</span></span></td>
</tr>
</table>
</td>
</tr>
<tr>
<td><span data-ttu-id="3bcd8-153">Vendas</span><span class="sxs-lookup"><span data-stu-id="3bcd8-153">Sales</span></span></td>
<td><span data-ttu-id="3bcd8-154">00010</span><span class="sxs-lookup"><span data-stu-id="3bcd8-154">00010</span></span></td>
<td><span data-ttu-id="3bcd8-155">2014-08-22T00:50:44Z</span><span class="sxs-lookup"><span data-stu-id="3bcd8-155">2014-08-22T00:50:44Z</span></span></td>
<td>
<table>
<tr>
<th><span data-ttu-id="3bcd8-156">Nome</span><span class="sxs-lookup"><span data-stu-id="3bcd8-156">FirstName</span></span></th>
<th><span data-ttu-id="3bcd8-157">Sobrenome</span><span class="sxs-lookup"><span data-stu-id="3bcd8-157">LastName</span></span></th>
<th><span data-ttu-id="3bcd8-158">Idade</span><span class="sxs-lookup"><span data-stu-id="3bcd8-158">Age</span></span></th>
<th><span data-ttu-id="3bcd8-159">Email</span><span class="sxs-lookup"><span data-stu-id="3bcd8-159">Email</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="3bcd8-160">Ken</span><span class="sxs-lookup"><span data-stu-id="3bcd8-160">Ken</span></span></td>
<td><span data-ttu-id="3bcd8-161">Kwok</span><span class="sxs-lookup"><span data-stu-id="3bcd8-161">Kwok</span></span></td>
<td><span data-ttu-id="3bcd8-162">23</span><span class="sxs-lookup"><span data-stu-id="3bcd8-162">23</span></span></td>
<td>kenk@contoso.com</td>
</tr>
</table>
</td>
</tr>
</table>


<span data-ttu-id="3bcd8-163">Até agora, isso parece muito semelhante a uma tabela no banco de dados relacional com as diferenças principais sendo as colunas obrigatórias e a capacidade de armazenar vários tipos de entidade na mesma tabela.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-163">So far, this looks very similar to a table in a relational database with the key differences being the mandatory columns, and the ability to store multiple entity types in the same table.</span></span> <span data-ttu-id="3bcd8-164">Além disso, cada uma das propriedades definidas pelo usuário, como **FirstName** ou **Age**, tem um tipo de dados, como número inteiro ou cadeia de caracteres, semelhante a uma coluna em um banco de dados relacional.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-164">In addition, each of the user-defined properties such as **FirstName** or **Age** has a data type, such as integer or string, just like a column in a relational database.</span></span> <span data-ttu-id="3bcd8-165">Embora diferente em um banco de dados relacional, a natureza sem esquema do serviço Tabela significa que uma propriedade não precisa ter o mesmo tipo de dados em cada entidade.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-165">Although unlike in a relational database, the schema-less nature of the Table service means that a property need not have the same data type on each entity.</span></span> <span data-ttu-id="3bcd8-166">Para armazenar tipos de dados complexos em uma única propriedade, você deve usar um formato serializado como JSON ou XML.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-166">To store complex data types in a single property, you must use a serialized format such as JSON or XML.</span></span> <span data-ttu-id="3bcd8-167">Para obter mais informações sobre o serviço Tabela, como tipos de dados com suporte, intervalos de datas com suporte, regras de nomenclatura e restrições de tamanho, consulte [Noções básicas sobre o modelo de dados do serviço Tabela](http://msdn.microsoft.com/library/azure/dd179338.aspx).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-167">For more information about the table service such as supported data types, supported date ranges, naming rules, and size constraints, see [Understanding the Table Service Data Model](http://msdn.microsoft.com/library/azure/dd179338.aspx).</span></span>

<span data-ttu-id="3bcd8-168">Como você verá, sua escolha de **PartitionKey** e **RowKey** é fundamental para um bom design da tabela.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-168">As you will see, your choice of **PartitionKey** and **RowKey** is fundamental to good table design.</span></span> <span data-ttu-id="3bcd8-169">Cada entidade armazenada em uma tabela deve ter uma combinação exclusiva de **PartitionKey** e **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-169">Every entity stored in a table must have a unique combination of **PartitionKey** and **RowKey**.</span></span> <span data-ttu-id="3bcd8-170">Assim como acontece com as chaves em uma tabela de banco de dados relacional, os valores de **PartitionKey** e **RowKey** são indexados para criar um índice clusterizado que habilita pesquisas rápidas; no entanto, o serviço Tabela não cria índices secundários, de modo que estas são as duas únicas propriedades indexadas (alguns dos padrões descritos posteriormente mostram como você pode contornar essa limitação aparente).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-170">As with keys in a relational database table, the **PartitionKey** and **RowKey** values are indexed to create a clustered index that enables fast look-ups; however, the Table service does not create any secondary indexes so these are the only two indexed properties (some of the patterns described later show how you can work around this apparent limitation).</span></span>  

<span data-ttu-id="3bcd8-171">Uma tabela é composta por uma ou mais partições, e como você verá, muitas das decisões de design tomadas serão em torno da escolha de uma **PartitionKey** e uma **RowKey** adequadas para otimizar sua solução.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-171">A table is made up of one or more partitions, and as you will see, many of the design decisions you make will be around choosing a suitable **PartitionKey** and **RowKey** to optimize your solution.</span></span> <span data-ttu-id="3bcd8-172">Uma solução poderia consistir em apenas uma única tabela que contém todas as suas entidades organizadas em partições, mas normalmente uma solução terá várias tabelas.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-172">A solution could consist of just a single table that contains all your entities organized into partitions, but typically a solution will have multiple tables.</span></span> <span data-ttu-id="3bcd8-173">Tabelas o ajudarão a organizar suas entidades logicamente, gerenciar o acesso aos dados usando listas de controle de acesso, e você pode remover uma tabela inteira usando uma única operação de armazenamento.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-173">Tables help you to logically organize your entities, help you manage access to the data using access control lists, and you can drop an entire table using a single storage operation.</span></span>  

### <a name="table-partitions"></a><span data-ttu-id="3bcd8-174">Partições de tabela</span><span class="sxs-lookup"><span data-stu-id="3bcd8-174">Table partitions</span></span>
<span data-ttu-id="3bcd8-175">O nome da conta, o nome de tabela e **PartitionKey** juntas identificam a partição dentro do serviço de armazenamento no qual o serviço Tabela armazena a entidade.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-175">The account name, table name and **PartitionKey** together identify the partition within the storage service where the table service stores the entity.</span></span> <span data-ttu-id="3bcd8-176">Além de ser parte do esquema de endereçamento de entidades, as partições definem um escopo para transações (consulte [Transações de Grupo de Entidades](#entity-group-transactions) abaixo) e forme a base de como o serviço Tabela pode ser dimensionado.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-176">As well as being part of the addressing scheme for entities, partitions define a scope for transactions (see [Entity Group Transactions](#entity-group-transactions) below), and form the basis of how the table service scales.</span></span> <span data-ttu-id="3bcd8-177">Para obter mais informações sobre partições, consulte [Metas de desempenho e escalabilidade de armazenamento do Azure](storage-scalability-targets.md).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-177">For more information on partitions see [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md).</span></span>  

<span data-ttu-id="3bcd8-178">No serviço Tabela, um nó individual atende a uma ou mais partições completas e o serviço é dimensionado pelo balanceamento dinâmico de carga das partições nos nós.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-178">In the Table service, an individual node services one or more complete partitions and the service scales by dynamically load-balancing partitions across nodes.</span></span> <span data-ttu-id="3bcd8-179">Se um nó estiver sob carga, o serviço Tabela pode *dividir* o intervalo de partições atendidas por esse nó em nós diferentes. Quando o tráfego baixa, o serviço pode *mesclar* os intervalos de partições de nós silenciosos de volta para um único nó.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-179">If a node is under load, the table service can *split* the range of partitions serviced by that node onto different nodes; when traffic subsides, the service can *merge* the partition ranges from quiet nodes back onto a single node.</span></span>  

<span data-ttu-id="3bcd8-180">Para obter mais informações sobre os detalhes internos do serviço Tabela e, em particular, sobre como o serviço gerencia partições, consulte o artigo Armazenamento do Microsoft Azure: [Armazenamento do Microsoft Azure: um serviço de armazenamento em nuvem altamente disponível com coerência forte](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-180">For more information about the internal details of the Table service, and in particular how the service manages partitions, see the paper [Microsoft Azure Storage: A Highly Available Cloud Storage Service with Strong Consistency](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx).</span></span>  

### <a name="entity-group-transactions"></a><span data-ttu-id="3bcd8-181">Transações de Grupo de Entidades</span><span class="sxs-lookup"><span data-stu-id="3bcd8-181">Entity Group Transactions</span></span>
<span data-ttu-id="3bcd8-182">No serviço Tabela, EGTs (Transações de Grupo de Entidades) são o único mecanismo interno para realizar atualizações atômicas entre várias entidades.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-182">In the Table service, Entity Group Transactions (EGTs) are the only built-in mechanism for performing atomic updates across multiple entities.</span></span> <span data-ttu-id="3bcd8-183">EGTs também são conhecidas como *transações de lote* em alguns documentos.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-183">EGTs are also referred to as *batch transactions* in some documentation.</span></span> <span data-ttu-id="3bcd8-184">EGTs só podem operar em entidades armazenadas na mesma partição (compartilhar a mesma chave de partição em determinada tabela), portanto, sempre que você precisar de um comportamento transacional atômico nas várias entidades, precisará garantir que as entidades estejam na mesma partição.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-184">EGTs can only operate on entities stored in the same partition (share the same partition key in a given table), so anytime you need atomic transactional behavior across multiple entities you need to ensure that those entities are in the same partition.</span></span> <span data-ttu-id="3bcd8-185">Isso geralmente é um motivo para manter vários tipos de entidade na mesma tabela (e partição) e não usar várias tabelas para tipos de entidade diferentes.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-185">This is often a reason for keeping multiple entity types in the same table (and partition) and not using multiple tables for different entity types.</span></span> <span data-ttu-id="3bcd8-186">Uma única EGT pode operar no máximo 100 entidades.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-186">A single EGT can operate on at most 100 entities.</span></span>  <span data-ttu-id="3bcd8-187">Se você enviar várias EGTs simultâneas para processamento, é importante garantir que essas EGTs não operem em entidades comuns entre as EGTs; caso contrário, o processamento pode ser retardado.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-187">If you submit multiple concurrent EGTs for processing it is important to ensure  those EGTs do not operate on entities that are common across EGTs as otherwise processing can be delayed.</span></span>

<span data-ttu-id="3bcd8-188">As EGTs também apresentam uma desvantagem potencial para avaliação do design: o uso de mais partições aumenta a escalabilidade do seu aplicativo porque o Azure tem mais oportunidades de balancear a carga de solicitações entre os nós, mas isso pode limitar a capacidade do seu aplicativo para executar transações atômicas e manter a coerência forte dos dados.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-188">EGTs also introduce a potential trade-off for you to evaluate in your design: using more partitions will increase the scalability of your application because Azure has more opportunities for load balancing requests across nodes, but this might limit the ability of your application to perform atomic transactions and maintain strong consistency for your data.</span></span> <span data-ttu-id="3bcd8-189">Além disso, existem metas de escalabilidade específica no nível de uma partição que podem limitar a taxa de transferência de transações esperada para um único nó: para obter mais informações sobre metas de escalabilidade para contas de armazenamento do Azure e o serviço Tabela, consulte [Metas de desempenho e escalabilidade de armazenamento do Azure](storage-scalability-targets.md).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-189">Furthermore, there are specific scalability targets at the level of a partition that might limit the throughput of transactions you can expect for a single node: for more information about the scalability targets for Azure storage accounts and the table service, see [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md).</span></span> <span data-ttu-id="3bcd8-190">As seções posteriores deste guia discutem diversas estratégias de design que o ajudarão a gerenciar compensações como esta e descrevem a melhor escolha para sua chave de partição com base nos requisitos específicos do aplicativo cliente.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-190">Later sections of this guide discuss various design strategies that help you manage trade-offs such as this one, and discuss how best to choose your partition key based on the specific requirements of your client application.</span></span>  

### <a name="capacity-considerations"></a><span data-ttu-id="3bcd8-191">Considerações sobre a capacidade</span><span class="sxs-lookup"><span data-stu-id="3bcd8-191">Capacity considerations</span></span>
<span data-ttu-id="3bcd8-192">A tabela a seguir inclui alguns dos valores de chave, portanto, fique atento ao projetar uma solução de serviço Tabela:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-192">The following table includes some of the key values to be aware of when you are designing a Table service solution:</span></span>  

| <span data-ttu-id="3bcd8-193">Capacidade total de uma conta de armazenamento do Azure</span><span class="sxs-lookup"><span data-stu-id="3bcd8-193">Total capacity of an Azure storage account</span></span> | <span data-ttu-id="3bcd8-194">500 TB</span><span class="sxs-lookup"><span data-stu-id="3bcd8-194">500 TB</span></span> |
| --- | --- |
| <span data-ttu-id="3bcd8-195">Número de tabelas em uma conta de armazenamento do Azure</span><span class="sxs-lookup"><span data-stu-id="3bcd8-195">Number of tables in an Azure storage account</span></span> |<span data-ttu-id="3bcd8-196">Limitado apenas pela capacidade da conta de armazenamento</span><span class="sxs-lookup"><span data-stu-id="3bcd8-196">Limited only by the capacity of the storage account</span></span> |
| <span data-ttu-id="3bcd8-197">Número de partições em uma tabela</span><span class="sxs-lookup"><span data-stu-id="3bcd8-197">Number of partitions in a table</span></span> |<span data-ttu-id="3bcd8-198">Limitado apenas pela capacidade da conta de armazenamento</span><span class="sxs-lookup"><span data-stu-id="3bcd8-198">Limited only by the capacity of the storage account</span></span> |
| <span data-ttu-id="3bcd8-199">Número de entidades em uma partição</span><span class="sxs-lookup"><span data-stu-id="3bcd8-199">Number of entities in a partition</span></span> |<span data-ttu-id="3bcd8-200">Limitado apenas pela capacidade da conta de armazenamento</span><span class="sxs-lookup"><span data-stu-id="3bcd8-200">Limited only by the capacity of the storage account</span></span> |
| <span data-ttu-id="3bcd8-201">Tamanho de uma entidade individual</span><span class="sxs-lookup"><span data-stu-id="3bcd8-201">Size of an individual entity</span></span> |<span data-ttu-id="3bcd8-202">Até 1 MB com um máximo de 255 propriedades (incluindo **PartitionKey**, **RowKey** e **Timestamp**)</span><span class="sxs-lookup"><span data-stu-id="3bcd8-202">Up to 1 MB with a maximum of 255 properties (including the **PartitionKey**, **RowKey**, and **Timestamp**)</span></span> |
| <span data-ttu-id="3bcd8-203">Tamanho do **PartitionKey**</span><span class="sxs-lookup"><span data-stu-id="3bcd8-203">Size of the **PartitionKey**</span></span> |<span data-ttu-id="3bcd8-204">Uma cadeia de caracteres até 1 KB</span><span class="sxs-lookup"><span data-stu-id="3bcd8-204">A string up to 1 KB in size</span></span> |
| <span data-ttu-id="3bcd8-205">Tamanho do **RowKey**</span><span class="sxs-lookup"><span data-stu-id="3bcd8-205">Size of the **RowKey**</span></span> |<span data-ttu-id="3bcd8-206">Uma cadeia de caracteres até 1 KB</span><span class="sxs-lookup"><span data-stu-id="3bcd8-206">A string up to 1 KB in size</span></span> |
| <span data-ttu-id="3bcd8-207">Tamanho de uma Transação de Grupo de Entidades</span><span class="sxs-lookup"><span data-stu-id="3bcd8-207">Size of an Entity Group Transaction</span></span> |<span data-ttu-id="3bcd8-208">Uma transação pode incluir no máximo 100 entidades e a carga deve ser menor que 4 MB.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-208">A transaction can include at most 100 entities and the payload must be less than 4 MB in size.</span></span> <span data-ttu-id="3bcd8-209">Uma EGT só pode atualizar uma entidade uma vez.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-209">An EGT can only update an entity once.</span></span> |

<span data-ttu-id="3bcd8-210">Para obter informações, consulte [Noções básicas sobre o modelo de dados do serviço Tabela](http://msdn.microsoft.com/library/azure/dd179338.aspx).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-210">For more information, see [Understanding the Table Service Data Model](http://msdn.microsoft.com/library/azure/dd179338.aspx).</span></span>  

### <a name="cost-considerations"></a><span data-ttu-id="3bcd8-211">Considerações de custo</span><span class="sxs-lookup"><span data-stu-id="3bcd8-211">Cost considerations</span></span>
<span data-ttu-id="3bcd8-212">Armazenamento de tabela é relativamente barato, mas você deve incluir estimativas de custo para a utilização da capacidade e a quantidade de transações como parte de sua avaliação de qualquer solução que usa o serviço Tabela.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-212">Table storage is relatively inexpensive, but you should include cost estimates for both capacity usage and the quantity of transactions as part of your evaluation of any solution that uses the Table service.</span></span> <span data-ttu-id="3bcd8-213">No entanto, em muitos cenários, o armazenamento de dados duplicados ou desnormalizados para melhorar o desempenho ou a escalabilidade de sua solução é uma abordagem válida.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-213">However, in many scenarios storing denormalized or duplicate data in order to improve the performance or scalability of your solution is a valid approach to take.</span></span> <span data-ttu-id="3bcd8-214">Para obter mais informações sobre preços, consulte [Preços de Armazenamento do Azure](https://azure.microsoft.com/pricing/details/storage/).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-214">For more information about pricing, see [Azure Storage Pricing](https://azure.microsoft.com/pricing/details/storage/).</span></span>  

## <a name="guidelines-for-table-design"></a><span data-ttu-id="3bcd8-215">Diretrizes de design da tabela</span><span class="sxs-lookup"><span data-stu-id="3bcd8-215">Guidelines for table design</span></span>
<span data-ttu-id="3bcd8-216">Essas listas resumem algumas as diretrizes importantes que você deve ter em mente ao criar tabelas, e este guia tratará delas em mais detalhes posteriormente.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-216">These lists summarize some of the key guidelines you should keep in mind when you are designing your tables, and this guide will address them all in more detail later in.</span></span> <span data-ttu-id="3bcd8-217">Essas diretrizes são muito diferentes daquelas que você normalmente seguiria para design de banco de dados relacional.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-217">These guidelines are very different from the guidelines you would typically follow for relational database design.</span></span>  

<span data-ttu-id="3bcd8-218">Criando sua solução do serviço Tabela para ser eficiente em *leitura* :</span><span class="sxs-lookup"><span data-stu-id="3bcd8-218">Designing your Table service solution to be *read* efficient:</span></span>

* <span data-ttu-id="3bcd8-219">***Design para consulta em aplicativos com alta taxa de leitura.***</span><span class="sxs-lookup"><span data-stu-id="3bcd8-219">***Design for querying in read-heavy applications.***</span></span> <span data-ttu-id="3bcd8-220">Quando você está criando tabelas, pense sobre as consultas (especialmente aquelas sensíveis a latência) que você executará antes de pensar em como atualizará as entidades.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-220">When you are designing your tables, think about the queries (especially the latency sensitive ones) that you will execute before you think about how you will update your entities.</span></span> <span data-ttu-id="3bcd8-221">Isso normalmente resulta em uma solução eficiente e de alto desempenho.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-221">This typically results in an efficient and performant solution.</span></span>  
* <span data-ttu-id="3bcd8-222">***Especifique PartitionKey e RowKey em suas consultas.***</span><span class="sxs-lookup"><span data-stu-id="3bcd8-222">***Specify both PartitionKey and RowKey in your queries.***</span></span> <span data-ttu-id="3bcd8-223">*Consultas de ponto* como essas são as consultas de serviço Tabela mais eficientes.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-223">*Point queries* such as these are the most efficient table service queries.</span></span>  
* <span data-ttu-id="3bcd8-224">***Considere armazenar cópias duplicadas de entidades.***</span><span class="sxs-lookup"><span data-stu-id="3bcd8-224">***Consider storing duplicate copies of entities.***</span></span> <span data-ttu-id="3bcd8-225">O armazenamento de tabela é barato, portanto, considere armazenar a mesma entidade várias vezes (com chaves diferentes) para permitir consultas mais eficientes.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-225">Table storage is cheap so consider storing the same entity multiple times (with different keys) to enable more efficient queries.</span></span>  
* <span data-ttu-id="3bcd8-226">***Considere a desnormalização de seus dados.***</span><span class="sxs-lookup"><span data-stu-id="3bcd8-226">***Consider denormalizing your data.***</span></span> <span data-ttu-id="3bcd8-227">O armazenamento de tabela é barato, então considere desnormalizar seus dados.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-227">Table storage is cheap so consider denormalizing your data.</span></span> <span data-ttu-id="3bcd8-228">Por exemplo, armazene entidades resumidas para que consultas a dados agregados só tenham de acessar uma única entidade.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-228">For example, store summary entities so that queries for aggregate data only need to access a single entity.</span></span>  
* <span data-ttu-id="3bcd8-229">***Use valores de chave composta.***</span><span class="sxs-lookup"><span data-stu-id="3bcd8-229">***Use compound key values.***</span></span> <span data-ttu-id="3bcd8-230">As únicas chaves que você tem são **PartitionKey** e **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-230">The only keys you have are **PartitionKey** and **RowKey**.</span></span> <span data-ttu-id="3bcd8-231">Por exemplo, use valores de chave composta para habilitar caminhos alternativo com chave de acesso para entidades.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-231">For example, use compound key values to enable alternate keyed access paths to entities.</span></span>  
* <span data-ttu-id="3bcd8-232">***Use a projeção de consulta.***</span><span class="sxs-lookup"><span data-stu-id="3bcd8-232">***Use query projection.***</span></span> <span data-ttu-id="3bcd8-233">Você pode reduzir a quantidade de dados transferidos pela rede por meio de consultas que selecionam apenas os campos necessários.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-233">You can reduce the amount of data that you transfer over the network by using queries that select just the fields you need.</span></span>  

<span data-ttu-id="3bcd8-234">Criar a solução de serviço Tabela para ser eficiente em *gravação* :</span><span class="sxs-lookup"><span data-stu-id="3bcd8-234">Designing your Table service solution to be *write* efficient:</span></span>  

* <span data-ttu-id="3bcd8-235">***Não crie partições ativas.***</span><span class="sxs-lookup"><span data-stu-id="3bcd8-235">***Do not create hot partitions.***</span></span> <span data-ttu-id="3bcd8-236">Escolha chaves que permitam que você distribua suas solicitações por várias partições em qualquer momento.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-236">Choose keys that enable you to spread your requests across multiple partitions at any point of time.</span></span>  
* <span data-ttu-id="3bcd8-237">***Evite picos no tráfego.***</span><span class="sxs-lookup"><span data-stu-id="3bcd8-237">***Avoid spikes in traffic.***</span></span> <span data-ttu-id="3bcd8-238">Suavize o tráfego por um período razoável de tempo e evite picos no tráfego.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-238">Smooth the traffic over a reasonable period of time and avoid spikes in traffic.</span></span>
* <span data-ttu-id="3bcd8-239">***Não crie, necessariamente, uma tabela separada para cada tipo de entidade.***</span><span class="sxs-lookup"><span data-stu-id="3bcd8-239">***Don't necessarily create a separate table for each type of entity.***</span></span> <span data-ttu-id="3bcd8-240">Quando você precisar de transações atômicas nos tipos de entidade, pode armazenar esses vários tipos de entidade na mesma partição, na mesma tabela.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-240">When you require atomic transactions across entity types, you can store these multiple entity types in the same partition in the same table.</span></span>
* <span data-ttu-id="3bcd8-241">***Considere a produtividade máxima que deve ser atingida.***</span><span class="sxs-lookup"><span data-stu-id="3bcd8-241">***Consider the maximum throughput you must achieve.***</span></span> <span data-ttu-id="3bcd8-242">Você deve estar ciente dos destinos de escalabilidade para o serviço Tabela e garantir que seu design não fará com que você os exceda.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-242">You must be aware of the scalability targets for the Table service and ensure that your design will not cause you to exceed them.</span></span>  

<span data-ttu-id="3bcd8-243">À medida que você ler este guia, verá exemplos que colocam todos esses princípios em prática.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-243">As you read this guide, you will see examples that put all of these principles into practice.</span></span>  

## <a name="design-for-querying"></a><span data-ttu-id="3bcd8-244">Design para consulta</span><span class="sxs-lookup"><span data-stu-id="3bcd8-244">Design for querying</span></span>
<span data-ttu-id="3bcd8-245">Soluções de serviço Tabela podem ser de leitura intensiva, gravação intensiva ou uma combinação dos dois.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-245">Table service solutions may be read intensive, write intensive, or a mix of the two.</span></span> <span data-ttu-id="3bcd8-246">Esta seção aborda as coisas a serem lembradas ao criar seu serviço Tabela para dar suporte a operações de leitura com eficiência.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-246">This section focuses on the things to bear in mind when you are designing your Table service to support read operations efficiently.</span></span> <span data-ttu-id="3bcd8-247">Normalmente, um design que dá suporte a operações de leitura com eficiência também é eficiente para operações de gravação.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-247">Typically, a design that supports read operations efficiently is also efficient for write operations.</span></span> <span data-ttu-id="3bcd8-248">No entanto, na próxima seção, [Design para modificação de dados](#design-for-data-modification), existem e são discutidas considerações adicionais para se ter em mente ao projetar de modo a dar suporte a operações de gravação.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-248">However, there are additional considerations to bear in mind when designing to support write operations, discussed in the next section, [Design for data modification](#design-for-data-modification).</span></span>

<span data-ttu-id="3bcd8-249">Um bom ponto de partida para criar a solução serviço Tabela para que você possa ler os dados com eficiência é perguntar "Quais consultas meu aplicativo precisará executar para recuperar os dados necessários do serviço Tabela?"</span><span class="sxs-lookup"><span data-stu-id="3bcd8-249">A good starting point for designing your Table service solution to enable you to read data efficiently is to ask "What queries will my application need to execute to retrieve the data it needs from the Table service?"</span></span>  

> [!NOTE]
> <span data-ttu-id="3bcd8-250">Com o serviço Tabela, é importante obter o design correto com antecedência porque é difícil e caro alterá-lo depois.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-250">With the Table service, it's important to get the design correct up front because it's difficult and expensive to change it later.</span></span> <span data-ttu-id="3bcd8-251">Por exemplo, em um banco de dados relacional é frequentemente possível solucionar problemas de desempenho simplesmente adicionando índices a um banco de dados: isso não é uma opção com o serviço Tabela.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-251">For example, in a relational database it's often possible to address performance issues simply by adding indexes to an existing database: this is not an option with the Table service.</span></span>  
> 
> 

<span data-ttu-id="3bcd8-252">Esta seção se concentra nos principais problemas que você deve abordar ao projetar suas tabelas para consulta.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-252">This section focuses on the key issues you must address when you design your tables for querying.</span></span> <span data-ttu-id="3bcd8-253">Os tópicos abordados nesta seção incluem:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-253">The topics covered in this section include:</span></span>

* [<span data-ttu-id="3bcd8-254">Como sua escolha de PartitionKey e RowKey afeta o desempenho da consulta</span><span class="sxs-lookup"><span data-stu-id="3bcd8-254">How your choice of PartitionKey and RowKey impacts query performance</span></span>](#how-your-choice-of-partitionkey-and-rowkey-impacts-query-performance)
* [<span data-ttu-id="3bcd8-255">Escolhendo uma PartitionKey apropriada</span><span class="sxs-lookup"><span data-stu-id="3bcd8-255">Choosing an appropriate PartitionKey</span></span>](#choosing-an-appropriate-partitionkey)
* [<span data-ttu-id="3bcd8-256">Otimizando consultas para o serviço Tabela</span><span class="sxs-lookup"><span data-stu-id="3bcd8-256">Optimizing queries for the Table service</span></span>](#optimizing-queries-for-the-table-service)
* [<span data-ttu-id="3bcd8-257">Armazenando dados no serviço Tabela</span><span class="sxs-lookup"><span data-stu-id="3bcd8-257">Sorting data in the Table service</span></span>](#sorting-data-in-the-table-service)

### <a name="how-your-choice-of-partitionkey-and-rowkey-impacts-query-performance"></a><span data-ttu-id="3bcd8-258">Como sua escolha de PartitionKey e RowKey afeta o desempenho da consulta</span><span class="sxs-lookup"><span data-stu-id="3bcd8-258">How your choice of PartitionKey and RowKey impacts query performance</span></span>
<span data-ttu-id="3bcd8-259">Os exemplos a seguir pressupõem que o serviço Tabela é armazenar entidades de funcionário com a seguinte estrutura (a maioria dos exemplos omite a propriedade **Timestamp** por motivos de clareza):</span><span class="sxs-lookup"><span data-stu-id="3bcd8-259">The following examples assume the table service is storing employee entities with the following structure (most of the examples omit the **Timestamp** property for clarity):</span></span>  

| <span data-ttu-id="3bcd8-260">*Nome da coluna*</span><span class="sxs-lookup"><span data-stu-id="3bcd8-260">*Column name*</span></span> | <span data-ttu-id="3bcd8-261">*Tipo de dados*</span><span class="sxs-lookup"><span data-stu-id="3bcd8-261">*Data type*</span></span> |
| --- | --- |
| <span data-ttu-id="3bcd8-262">**PartitionKey** (nome de departamento)</span><span class="sxs-lookup"><span data-stu-id="3bcd8-262">**PartitionKey** (Department Name)</span></span> |<span data-ttu-id="3bcd8-263">Cadeia de caracteres</span><span class="sxs-lookup"><span data-stu-id="3bcd8-263">String</span></span> |
| <span data-ttu-id="3bcd8-264">**RowKey** (Id do funcionário)</span><span class="sxs-lookup"><span data-stu-id="3bcd8-264">**RowKey** (Employee Id)</span></span> |<span data-ttu-id="3bcd8-265">Cadeia de caracteres</span><span class="sxs-lookup"><span data-stu-id="3bcd8-265">String</span></span> |
| <span data-ttu-id="3bcd8-266">**Nome**</span><span class="sxs-lookup"><span data-stu-id="3bcd8-266">**FirstName**</span></span> |<span data-ttu-id="3bcd8-267">Cadeia de caracteres</span><span class="sxs-lookup"><span data-stu-id="3bcd8-267">String</span></span> |
| <span data-ttu-id="3bcd8-268">**Sobrenome**</span><span class="sxs-lookup"><span data-stu-id="3bcd8-268">**LastName**</span></span> |<span data-ttu-id="3bcd8-269">Cadeia de caracteres</span><span class="sxs-lookup"><span data-stu-id="3bcd8-269">String</span></span> |
| <span data-ttu-id="3bcd8-270">**Idade**</span><span class="sxs-lookup"><span data-stu-id="3bcd8-270">**Age**</span></span> |<span data-ttu-id="3bcd8-271">Número inteiro</span><span class="sxs-lookup"><span data-stu-id="3bcd8-271">Integer</span></span> |
| <span data-ttu-id="3bcd8-272">**EmailAddress**</span><span class="sxs-lookup"><span data-stu-id="3bcd8-272">**EmailAddress**</span></span> |<span data-ttu-id="3bcd8-273">Cadeia de caracteres</span><span class="sxs-lookup"><span data-stu-id="3bcd8-273">String</span></span> |

<span data-ttu-id="3bcd8-274">A seção anterior, [Visão geral do serviço Tabela do Azure](#overview), descreve alguns dos principais recursos do serviço Tabela do Azure, que têm uma influência direta no design para consulta.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-274">The earlier section [Azure Table service overview](#overview) describes some of the key features of the Azure Table service that have a direct influence on designing for query.</span></span> <span data-ttu-id="3bcd8-275">Isso resulta nas seguintes diretrizes gerais para a criação de consultas do serviço Tabela.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-275">These result in the following general guidelines for designing Table service queries.</span></span> <span data-ttu-id="3bcd8-276">Observe que a sintaxe de filtro usada nos exemplos a seguir é proveniente da API REST do serviço Tabela. Para obter mais informações, veja [Query Entities](http://msdn.microsoft.com/library/azure/dd179421.aspx) (Consultar entidades).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-276">Note that the filter syntax used in the examples below is from the Table service REST API, for more information see [Query Entities](http://msdn.microsoft.com/library/azure/dd179421.aspx).</span></span>  

* <span data-ttu-id="3bcd8-277">Uma ***Consulta de Ponto*** é a pesquisa mais eficiente a ser usada e é recomendada para pesquisas de alto volume ou pesquisas que exigem a latência mais baixa.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-277">A ***Point Query*** is the most efficient lookup to use and is recommended to be used for high-volume lookups or lookups requiring lowest latency.</span></span> <span data-ttu-id="3bcd8-278">Tal consulta pode usar os índices para localizar uma entidade individual de modo muito eficiente, especificando os valores **PartitionKey** e **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-278">Such a query can use the indexes to locate an individual entity very efficiently by specifying both the **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="3bcd8-279">Por exemplo: $filter=(PartitionKey eq 'Sales') and (RowKey eq '2')</span><span class="sxs-lookup"><span data-stu-id="3bcd8-279">For example: $filter=(PartitionKey eq 'Sales') and (RowKey eq '2')</span></span>  
* <span data-ttu-id="3bcd8-280">A segunda melhor opção é uma ***Consulta de Intervalo***, que usa **PartitionKey** e filtros em um intervalo de valores de **RowKey** para retornar mais de uma entidade.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-280">Second best is a ***Range Query*** that uses the **PartitionKey** and filters on a range of **RowKey** values to return more than one entity.</span></span> <span data-ttu-id="3bcd8-281">O valor de **PartitionKey** identifica uma partição específica e os valores de **RowKey** identificam um subconjunto das entidades na partição.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-281">The **PartitionKey** value identifies a specific partition, and the **RowKey** values identify a subset of the entities in that partition.</span></span> <span data-ttu-id="3bcd8-282">Por exemplo: $filter=PartitionKey eq 'Sales' and RowKey ge 'S' and RowKey lt 'T'</span><span class="sxs-lookup"><span data-stu-id="3bcd8-282">For example: $filter=PartitionKey eq 'Sales' and RowKey ge 'S' and RowKey lt 'T'</span></span>  
* <span data-ttu-id="3bcd8-283">A terceira melhor opção é uma ***Verificação de Partição***, que usa **PartitionKey** e filtros em outra propriedade não chave e que pode retornar mais de uma entidade.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-283">Third best is a ***Partition Scan*** that uses the **PartitionKey** and filters on another non-key property and that may return more than one entity.</span></span> <span data-ttu-id="3bcd8-284">O valor **PartitionKey** identifica uma partição específica e os valores de propriedades selecionados para um subconjunto das entidades nessa partição.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-284">The **PartitionKey** value identifies a specific partition, and the property values select for a subset of the entities in that partition.</span></span> <span data-ttu-id="3bcd8-285">Por exemplo: $filter=PartitionKey eq 'Sales' and LastName eq 'Smith'</span><span class="sxs-lookup"><span data-stu-id="3bcd8-285">For example: $filter=PartitionKey eq 'Sales' and LastName eq 'Smith'</span></span>  
* <span data-ttu-id="3bcd8-286">Uma ***Verificação de Tabela*** não inclui **PartitionKey** e é muito ineficiente, pois pesquisa todas as partições que, por sua vez, compõem sua tabela para qualquer entidade correspondente.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-286">A ***Table Scan*** does not include the **PartitionKey** and is very inefficient because it searches all of the partitions that make up your table in turn for any matching entities.</span></span> <span data-ttu-id="3bcd8-287">A verificação da tabela será realizada, independentemente de o filtro usar ou não a **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-287">It will perform a table scan regardless of whether or not your filter uses the **RowKey**.</span></span> <span data-ttu-id="3bcd8-288">Por exemplo: $filter=LastName eq 'Dias'</span><span class="sxs-lookup"><span data-stu-id="3bcd8-288">For example: $filter=LastName eq 'Jones'</span></span>  
* <span data-ttu-id="3bcd8-289">As consultas que retornam várias entidades as retornam classificadas na ordem **PartitionKey** e **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-289">Queries that return multiple entities return them sorted in **PartitionKey** and **RowKey** order.</span></span> <span data-ttu-id="3bcd8-290">Para evitar reclassificar as entidades no cliente, escolha uma **RowKey** que define a ordem de classificação mais comum.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-290">To avoid resorting the entities in the client, choose a **RowKey** that defines the most common sort order.</span></span>  

<span data-ttu-id="3bcd8-291">Observe que o uso de um operador "**or**" para especificar um filtro com base em valores de **RowKey** resulta em uma verificação de partição, e não é tratado como uma consulta de intervalo.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-291">Note that using an "**or**" to specify a filter based on **RowKey** values results in a partition scan and is not treated as a range query.</span></span> <span data-ttu-id="3bcd8-292">Portanto, você deve evitar consultas que usam filtros, como: $filter=PartitionKey eq 'Sales' and (RowKey eq '121' or RowKey eq '322')</span><span class="sxs-lookup"><span data-stu-id="3bcd8-292">Therefore, you should avoid queries that use filters such as: $filter=PartitionKey eq 'Sales' and (RowKey eq '121' or RowKey eq '322')</span></span>  

<span data-ttu-id="3bcd8-293">Para obter exemplos de código de cliente que usam a Biblioteca de Cliente de Armazenamento para executar consultas eficientes, consulte:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-293">For examples of client-side code that use the Storage Client Library to execute efficient queries, see:</span></span>  

* [<span data-ttu-id="3bcd8-294">Executando uma consulta de ponto usando a Biblioteca de Cliente de Armazenamento</span><span class="sxs-lookup"><span data-stu-id="3bcd8-294">Executing a point query using the Storage Client Library</span></span>](#executing-a-point-query-using-the-storage-client-library)
* [<span data-ttu-id="3bcd8-295">Recuperando várias entidades usando LINQ</span><span class="sxs-lookup"><span data-stu-id="3bcd8-295">Retrieving multiple entities using LINQ</span></span>](#retrieving-multiple-entities-using-linq)
* [<span data-ttu-id="3bcd8-296">Projeção do lado do servidor</span><span class="sxs-lookup"><span data-stu-id="3bcd8-296">Server-side projection</span></span>](#server-side-projection)  

<span data-ttu-id="3bcd8-297">Para obter exemplos de código do lado do cliente que pode lidar com vários tipos de entidade armazenados na mesma tabela, consulte:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-297">For examples of client-side code that can handle multiple entity types stored in the same table, see:</span></span>  

* [<span data-ttu-id="3bcd8-298">Trabalhando com tipos de entidade heterogênea</span><span class="sxs-lookup"><span data-stu-id="3bcd8-298">Working with heterogeneous entity types</span></span>](#working-with-heterogeneous-entity-types)  

### <a name="choosing-an-appropriate-partitionkey"></a><span data-ttu-id="3bcd8-299">Escolhendo uma PartitionKey apropriada</span><span class="sxs-lookup"><span data-stu-id="3bcd8-299">Choosing an appropriate PartitionKey</span></span>
<span data-ttu-id="3bcd8-300">Sua escolha de **PartitionKey** deve equilibrar a necessidade de habilitar o uso de EGTs (para garantir a consistência) com a necessidade de distribuir suas entidades por várias partições (para garantir uma solução escalonável).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-300">Your choice of **PartitionKey** should balance the need to enables the use of EGTs (to ensure consistency) against the requirement to distribute your entities across multiple partitions (to ensure a scalable solution).</span></span>  

<span data-ttu-id="3bcd8-301">Por um lado, você pode armazenar todas as suas entidades em uma única partição, mas isso pode limitar a escalabilidade da solução e impedir que o serviço Tabela seja capaz de solicitar balanceamento de carga.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-301">At one extreme, you could store all your entities in a single partition, but this may limit the scalability of your solution and would prevent the table service from being able to load-balance requests.</span></span> <span data-ttu-id="3bcd8-302">Por outro lado, você pode armazenar uma entidade por partição, o que seria altamente escalonável e permitiria que o serviço Tabela balanceasse a carga das solicitações, mas impediria o uso de transações em grupo de entidades.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-302">At the other extreme, you could store one entity per partition, which would be highly scalable and which enables the table service to load-balance requests, but which would prevent you from using entity group transactions.</span></span>  

<span data-ttu-id="3bcd8-303">Uma **PartitionKey** ideal é aquela que permite que você use consultas eficientes e que tenha partições suficientes para garantir que sua solução seja escalonável.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-303">An ideal **PartitionKey** is one that enables you to use efficient queries and that has sufficient partitions to ensure your solution is scalable.</span></span> <span data-ttu-id="3bcd8-304">Normalmente, você descobrirá que as entidades terão uma propriedade adequada que distribui suas entidades em partições suficientes.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-304">Typically, you will find that your entities will have a suitable property that distributes your entities across sufficient partitions.</span></span>

> [!NOTE]
> <span data-ttu-id="3bcd8-305">Por exemplo, em um sistema que armazena informações sobre usuários ou funcionários, UserID pode ser uma boa PartitionKey.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-305">For example, in a system that stores information about users or employees, UserID may be a good PartitionKey.</span></span> <span data-ttu-id="3bcd8-306">Você pode ter várias entidades que usam uma determinada UserID como a chave da partição.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-306">You may have several entities that use a given UserID as the partition key.</span></span> <span data-ttu-id="3bcd8-307">Cada entidade que armazena dados sobre um usuário é agrupada em uma única partição, e pode ser acessada por meio de transações do grupo de entidades, continuando altamente escalonável.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-307">Each entity that stores data about a user is grouped into a single partition, and so these entities are accessible via entity group transactions, while still being highly scalable.</span></span>
> 
> 

<span data-ttu-id="3bcd8-308">Há considerações adicionais na sua escolha de **PartitionKey** relacionadas a como você vai inserir, atualizar e excluir entidades: consulte a seção [Design para modificação de dados](#design-for-data-modification) abaixo.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-308">There are additional considerations in your choice of **PartitionKey** that relate to how you will insert, update, and delete entities: see the section [Design for data modification](#design-for-data-modification) below.</span></span>  

### <a name="optimizing-queries-for-the-table-service"></a><span data-ttu-id="3bcd8-309">Otimizando consultas para o serviço Tabela</span><span class="sxs-lookup"><span data-stu-id="3bcd8-309">Optimizing queries for the Table service</span></span>
<span data-ttu-id="3bcd8-310">O serviço Tabela indexa automaticamente suas entidades usando os valores de **PartitionKey** e **RowKey** em um único índice clusterizado; por isso as consultas de ponto são as mais eficientes.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-310">The Table service automatically indexes your entities using the **PartitionKey** and **RowKey** values in a single clustered index, hence the reason that point queries are the most efficient to use.</span></span> <span data-ttu-id="3bcd8-311">No entanto, não há qualquer índice além daquele no índice clusterizado em **PartitionKey** e **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-311">However, there are no indexes other than that on the clustered index on the **PartitionKey** and **RowKey**.</span></span>

<span data-ttu-id="3bcd8-312">Muitos designs devem atender aos requisitos para habilitar a pesquisa de entidades com base em vários critérios.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-312">Many designs must meet requirements to enable lookup of entities based on multiple criteria.</span></span> <span data-ttu-id="3bcd8-313">Por exemplo, localizar entidades de funcionário com base em email, ID de funcionário ou sobrenome.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-313">For example, locating employee entities based on email, employee id, or last name.</span></span> <span data-ttu-id="3bcd8-314">Os padrões a seguir, na seção [Padrões de design de tabela](#table-design-patterns) , abordam esses tipos de requisito e descrevem maneiras de contornar o fato de que o serviço Tabela não fornece índices secundários:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-314">The following patterns in the section [Table Design Patterns](#table-design-patterns) address these types of requirement and describe ways of working around the fact that the Table service does not provide secondary indexes:</span></span>  

* <span data-ttu-id="3bcd8-315">[Padrão de índice secundário intrapartição](#intra-partition-secondary-index-pattern) - armazene várias cópias de cada entidade usando valores diferentes de **RowKey** (na mesma partição) para permitir pesquisas rápidas e eficientes, bem como ordens de classificação alternativas usando valores de **RowKey** diferentes.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-315">[Intra-partition secondary index pattern](#intra-partition-secondary-index-pattern) - Store multiple copies of each entity using different **RowKey** values (in the same partition) to enable fast and efficient lookups and alternate sort orders by using different **RowKey** values.</span></span>  
* <span data-ttu-id="3bcd8-316">[Padrão de índice secundário entre partições](#inter-partition-secondary-index-pattern) - Armazene várias cópias de cada entidade usando valores diferentes de RowKey em partições separadas ou em tabelas separadas, a fim de permitir pesquisas rápidas e eficientes e ordens de classificação alternativas usando valores diferentes de **RowKey** .</span><span class="sxs-lookup"><span data-stu-id="3bcd8-316">[Inter-partition secondary index pattern](#inter-partition-secondary-index-pattern) - Store multiple copies of each entity using different RowKey values in separate partitions or in separate tables to enable fast and efficient lookups and alternate sort orders by using different **RowKey** values.</span></span>  
* <span data-ttu-id="3bcd8-317">[Padrão de entidades de índice](#index-entities-pattern) - Mantenha entidades de índice para permitir pesquisas eficientes que retornem listas de entidades.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-317">[Index Entities Pattern](#index-entities-pattern) - Maintain index entities to enable efficient searches that return lists of entities.</span></span>  

### <a name="sorting-data-in-the-table-service"></a><span data-ttu-id="3bcd8-318">Armazenando dados no serviço Tabela</span><span class="sxs-lookup"><span data-stu-id="3bcd8-318">Sorting data in the Table service</span></span>
<span data-ttu-id="3bcd8-319">O serviço Tabela retorna entidades classificadas em ordem crescente com base em **PartitionKey** e, em seguida, **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-319">The Table service returns entities sorted in ascending order based on **PartitionKey** and then by **RowKey**.</span></span> <span data-ttu-id="3bcd8-320">Essas chaves são valores de cadeia de caracteres e para garantir que os valores numéricos sejam classificados corretamente, você deve convertê-los em um comprimento fixo e preenchê-los com zeros.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-320">These keys are string values and to ensure that numeric values sort correctly, you should convert them to a fixed length and pad them with zeroes.</span></span> <span data-ttu-id="3bcd8-321">Por exemplo, se o valor da ID de funcionário que você usa como a **RowKey** for um valor inteiro, você deverá converter a ID do funcionário **123** em **00000123**.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-321">For example, if the employee id value you use as the **RowKey** is an integer value, you should convert employee id **123** to **00000123**.</span></span>  

<span data-ttu-id="3bcd8-322">Muitos aplicativos têm requisitos para usar dados classificados em ordens diferentes: por exemplo, classificação de funcionários por nome ou por data de ingresso.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-322">Many applications have requirements to use data sorted in different orders: for example, sorting employees by name, or by joining date.</span></span> <span data-ttu-id="3bcd8-323">Os seguintes padrões, na seção [Padrões de Design de tabela](#table-design-patterns) , abordam como alternar as ordens de classificação para suas entidades:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-323">The following patterns in the section [Table Design Patterns](#table-design-patterns) address how to alternate sort orders for your entities:</span></span>  

* <span data-ttu-id="3bcd8-324">[Padrão de índice secundário intrapartição](#intra-partition-secondary-index-pattern) - Armazene várias cópias de cada entidade usando valores diferentes de RowKey (na mesma partição), para permitir pesquisas rápidas e eficientes e ordens de classificação alternativas usando valores de RowKey diferentes.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-324">[Intra-partition secondary index pattern](#intra-partition-secondary-index-pattern) - Store multiple copies of each entity using different RowKey values (in the same partition) to enable fast and efficient lookups and alternate sort orders by using different RowKey values.</span></span>  
* <span data-ttu-id="3bcd8-325">[Padrão de índice secundário entre partições](#inter-partition-secondary-index-pattern) - Armazene várias cópias de cada entidade usando valores diferentes de RowKey em partições e tabelas separadas, para permitir pesquisas rápidas e eficientes e ordens de classificação alternativas usando valores diferentes de RowKey.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-325">[Inter-partition secondary index pattern](#inter-partition-secondary-index-pattern) - Store multiple copies of each entity using different RowKey values in separate partitions in separate tables to enable fast and efficient lookups and alternate sort orders by using different RowKey values.</span></span>
* <span data-ttu-id="3bcd8-326">[Padrão da parte final do log](#log-tail-pattern) – recupere as *n* entidades adicionadas mais recentemente a uma partição usando um valor de **RowKey** que classifica em ordem de data e hora inversa.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-326">[Log tail pattern](#log-tail-pattern) - Retrieve the *n* entities most recently added to a partition by using a **RowKey** value that sorts in reverse date and time order.</span></span>  

## <a name="design-for-data-modification"></a><span data-ttu-id="3bcd8-327">Design para modificação de dados</span><span class="sxs-lookup"><span data-stu-id="3bcd8-327">Design for data modification</span></span>
<span data-ttu-id="3bcd8-328">Esta seção enfoca as considerações de design para otimizar inserções, atualizações e exclusões.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-328">This section focuses on the design considerations for optimizing inserts, updates, and deletes.</span></span> <span data-ttu-id="3bcd8-329">Em alguns casos, você precisará avaliar a compensação entre designs que otimizam para consulta em relação a designs que otimizam para modificação de dados, da mesma forma que em designs de bancos de dados relacionais (embora as técnicas para gerenciar vantagens e desvantagens do design sejam diferentes em um banco de dados relacional).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-329">In some cases, you will need to evaluate the trade-off between designs that optimize for querying against designs that optimize for data modification just as you do in designs for relational databases (although the techniques for managing the design trade-offs are different in a relational database).</span></span> <span data-ttu-id="3bcd8-330">A seção [Padrões de design de tabela](#table-design-patterns) descreve alguns padrões de design detalhados para o serviço Tabela e destaca algumas compensações.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-330">The section [Table Design Patterns](#table-design-patterns) describes some detailed design patterns for the Table service and highlights some these trade-offs.</span></span> <span data-ttu-id="3bcd8-331">Na prática, você descobrirá que muitos designs otimizados para entidades de consulta também funcionam bem para modificar entidades.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-331">In practice, you will find that many designs optimized for querying entities also work well for modifying entities.</span></span>  

### <a name="optimizing-the-performance-of-insert-update-and-delete-operations"></a><span data-ttu-id="3bcd8-332">Otimizando o desempenho das operações de inserção, atualização e exclusão</span><span class="sxs-lookup"><span data-stu-id="3bcd8-332">Optimizing the performance of insert, update, and delete operations</span></span>
<span data-ttu-id="3bcd8-333">Para atualizar ou excluir uma entidade, você deve ser capaz de identificá-la usando os valores de **PartitionKey** e **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-333">To update or delete an entity, you must be able to identify it by using the **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="3bcd8-334">Nesse sentido, a escolha de **PartitionKey** e **RowKey** para modificar entidades deve seguir critérios semelhantes à escolha para dar suporte a consultas de ponto, a fim identificar entidades do modo mais eficiente possível.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-334">In this respect, your choice of **PartitionKey** and **RowKey** for modifying entities should follow similar criteria to your choice to support point queries because you want to identify entities as efficiently as possible.</span></span> <span data-ttu-id="3bcd8-335">Não convém usar uma verificação ineficiente de tabela ou de partição para localizar uma entidade, a fim de descobrir os valores de **PartitionKey** e **RowKey** necessários para atualizá-la ou excluí-la.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-335">You do not want to use an inefficient partition or table scan to locate an entity in order to discover the **PartitionKey** and **RowKey** values you need to update or delete it.</span></span>  

<span data-ttu-id="3bcd8-336">Os padrões a seguir, na seção [Padrões de design de tabela](#table-design-patterns) , abordam a otimização do desempenho ou suas operações de inserção, atualização e exclusão:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-336">The following patterns in the section [Table Design Patterns](#table-design-patterns) address optimizing the performance or your insert, update, and delete operations:</span></span>  

* <span data-ttu-id="3bcd8-337">[Padrão de exclusão de alto volume](#high-volume-delete-pattern) - Habilite a exclusão de um alto volume de entidades armazenando todas as entidades para exclusão simultânea em suas próprias tabelas separadas; exclua as entidades por meio da exclusão da tabela.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-337">[High volume delete pattern](#high-volume-delete-pattern) - Enable the deletion of a high volume of entities by storing all the entities for simultaneous deletion in their own separate table; you delete the entities by deleting the table.</span></span>  
* <span data-ttu-id="3bcd8-338">[Padrão de série de dados](#data-series-pattern) - Armazene séries completas de dados em uma única entidade para minimizar o número de solicitações feitas.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-338">[Data series pattern](#data-series-pattern) - Store complete data series in a single entity to minimize the number of requests you make.</span></span>  
* <span data-ttu-id="3bcd8-339">[Padrão de entidades longas](#wide-entities-pattern) - Use várias entidades físicas para armazenar entidades lógicas com mais de 252 propriedades.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-339">[Wide entities pattern](#wide-entities-pattern) - Use multiple physical entities to store logical entities with more than 252 properties.</span></span>  
* <span data-ttu-id="3bcd8-340">[Padrão de entidades grandes](#large-entities-pattern) - Use o armazenamento de blobs para armazenar grandes valores de propriedade.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-340">[Large entities pattern](#large-entities-pattern) - Use blob storage to store large property values.</span></span>  

### <a name="ensuring-consistency-in-your-stored-entities"></a><span data-ttu-id="3bcd8-341">Garantindo a consistência nas suas entidades armazenadas</span><span class="sxs-lookup"><span data-stu-id="3bcd8-341">Ensuring consistency in your stored entities</span></span>
<span data-ttu-id="3bcd8-342">Outro fator-chave que influencia sua escolha de chaves para otimizar as modificações de dados é como garantir a consistência usando transações atômicas.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-342">The other key factor that influences your choice of keys for optimizing data modifications is how to ensure consistency by using atomic transactions.</span></span> <span data-ttu-id="3bcd8-343">Você só pode usar uma EGT para operar em entidades armazenadas na mesma partição.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-343">You can only use an EGT to operate on entities stored in the same partition.</span></span>  

<span data-ttu-id="3bcd8-344">Os padrões a seguir, na seção [Padrões de design de tabela](#table-design-patterns) , tratam da consistência de gerenciamento:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-344">The following patterns in the section [Table Design Patterns](#table-design-patterns) address managing consistency:</span></span>  

* <span data-ttu-id="3bcd8-345">[Padrão de índice secundário intrapartição](#intra-partition-secondary-index-pattern) - armazene várias cópias de cada entidade usando valores diferentes de **RowKey** (na mesma partição) para permitir pesquisas rápidas e eficientes, bem como ordens de classificação alternativas usando valores de **RowKey** diferentes.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-345">[Intra-partition secondary index pattern](#intra-partition-secondary-index-pattern) - Store multiple copies of each entity using different **RowKey** values (in the same partition) to enable fast and efficient lookups and alternate sort orders by using different **RowKey** values.</span></span>  
* <span data-ttu-id="3bcd8-346">[Padrão de índice secundário entre partições](#inter-partition-secondary-index-pattern) - Armazene várias cópias de cada entidade usando valores diferentes de RowKey em partições separadas ou em tabelas separadas, a fim de permitir pesquisas rápidas e eficientes e ordens de classificação alternativas usando valores diferentes de **RowKey** .</span><span class="sxs-lookup"><span data-stu-id="3bcd8-346">[Inter-partition secondary index pattern](#inter-partition-secondary-index-pattern) - Store multiple copies of each entity using different RowKey values in separate partitions or in separate tables to enable fast and efficient lookups and alternate sort orders by using different **RowKey** values.</span></span>  
* <span data-ttu-id="3bcd8-347">[Padrão de transações eventualmente consistentes](#eventually-consistent-transactions-pattern) - Habilite comportamento eventualmente consistente entre limites de partição ou limites do sistema de armazenamento usando filas do Azure.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-347">[Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern) - Enable eventually consistent behavior across partition boundaries or storage system boundaries by using Azure queues.</span></span>
* <span data-ttu-id="3bcd8-348">[Padrão de entidades de índice](#index-entities-pattern) - Mantenha entidades de índice para permitir pesquisas eficientes que retornem listas de entidades.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-348">[Index Entities Pattern](#index-entities-pattern) - Maintain index entities to enable efficient searches that return lists of entities.</span></span>  
* <span data-ttu-id="3bcd8-349">[Padrão de desnormalização](#denormalization-pattern) - Combine dados relacionados juntos em uma única entidade, para que você possa recuperar todos os dados de que precisa com uma única consulta de ponto.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-349">[Denormalization pattern](#denormalization-pattern) - Combine related data together in a single entity to enable you to retrieve all the data you need with a single point query.</span></span>  
* <span data-ttu-id="3bcd8-350">[Padrão de série de dados](#data-series-pattern) - Armazene séries completas de dados em uma única entidade para minimizar o número de solicitações feitas.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-350">[Data series pattern](#data-series-pattern) - Store complete data series in a single entity to minimize the number of requests you make.</span></span>  

<span data-ttu-id="3bcd8-351">Para saber mais sobre transações de grupo, consulte a seção [Transações de grupo de entidades](#entity-group-transactions).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-351">For information about entity group transactions, see the section [Entity Group Transactions](#entity-group-transactions).</span></span>  

### <a name="ensuring-your-design-for-efficient-modifications-facilitates-efficient-queries"></a><span data-ttu-id="3bcd8-352">Garantir seu design para modificações eficientes facilita consultas eficientes</span><span class="sxs-lookup"><span data-stu-id="3bcd8-352">Ensuring your design for efficient modifications facilitates efficient queries</span></span>
<span data-ttu-id="3bcd8-353">Em muitos casos, um design para consultas eficientes resulta em modificações eficientes, mas você sempre deve avaliar se esse é o caso para seu cenário específico.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-353">In many cases, a design for efficient querying results in efficient modifications, but you should always evaluate whether this is the case for your specific scenario.</span></span> <span data-ttu-id="3bcd8-354">Alguns dos padrões na seção [Padrões de design de tabela](#table-design-patterns) avaliam explicitamente as compensações entre a consulta e a modificação de entidades, e você deve sempre levar em consideração o número de cada tipo de operação.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-354">Some of the patterns in the section [Table Design Patterns](#table-design-patterns) explicitly evaluate trade-offs between querying and modifying entities, and you should always take into account the number of each type of operation.</span></span>  

<span data-ttu-id="3bcd8-355">Os padrões a seguir, na seção [Padrões de design de tabela](#table-design-patterns) , abordam as compensações entre o design para consultas eficientes e o design para modificação eficiente de dados:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-355">The following patterns in the section [Table Design Patterns](#table-design-patterns) address trade-offs between designing for efficient queries and designing for efficient data modification:</span></span>  

* <span data-ttu-id="3bcd8-356">[Padrão de chave composta](#compound-key-pattern) - Use valores **RowKey** compostos para permitir que um cliente pesquise dados relacionados com uma consulta de único ponto.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-356">[Compound key pattern](#compound-key-pattern) - Use compound **RowKey** values to enable a client to lookup related data with a single point query.</span></span>  
* <span data-ttu-id="3bcd8-357">[Padrão da parte final do log](#log-tail-pattern) – recupere as *n* entidades adicionadas mais recentemente a uma partição usando um valor de **RowKey** que classifica em ordem de data e hora inversa.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-357">[Log tail pattern](#log-tail-pattern) - Retrieve the *n* entities most recently added to a partition by using a **RowKey** value that sorts in reverse date and time order.</span></span>  

## <a name="encrypting-table-data"></a><span data-ttu-id="3bcd8-358">Criptografando dados de tabela</span><span class="sxs-lookup"><span data-stu-id="3bcd8-358">Encrypting Table Data</span></span>
<span data-ttu-id="3bcd8-359">A Biblioteca de Cliente do Armazenamento do Azure para .NET dá suporte à criptografia de propriedades de entidade para as operações de inserção e substituição.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-359">The .NET Azure Storage Client Library supports encryption of string entity properties for insert and replace operations.</span></span> <span data-ttu-id="3bcd8-360">As cadeias de caracteres criptografadas são armazenadas no serviço como propriedades binárias, e são convertidas novamente em cadeias de caracteres após a descriptografia.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-360">The encrypted strings are stored on the service as binary properties, and they are converted back to strings after decryption.</span></span>    

<span data-ttu-id="3bcd8-361">Para tabelas, além da política de criptografia, os usuários devem especificar as propriedades que devem ser criptografadas.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-361">For tables, in addition to the encryption policy, users must specify the properties to be encrypted.</span></span> <span data-ttu-id="3bcd8-362">Isso pode ser feito especificando o atributo [EncryptProperty] \(para entidades POCO que derivam de TableEntity) ou um resolvedor de criptografia nas opções de solicitação.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-362">This can be done by either specifying an [EncryptProperty] attribute (for POCO entities that derive from TableEntity) or an encryption resolver in request options.</span></span> <span data-ttu-id="3bcd8-363">Um resolvedor de criptografia é um delegado que usa uma chave de partição, a chave de linha e o nome da propriedade e retorna um valor booliano que indica se essa propriedade deve ser criptografada.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-363">An encryption resolver is a delegate that takes a partition key, row key, and property name and returns a Boolean that indicates whether that property should be encrypted.</span></span> <span data-ttu-id="3bcd8-364">Durante a criptografia, a biblioteca de cliente usará essas informações para decidir se uma propriedade deve ser criptografada durante a gravação para a transmissão.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-364">During encryption, the client library will use this information to decide whether a property should be encrypted while writing to the wire.</span></span> <span data-ttu-id="3bcd8-365">O representante também oferece a possibilidade de lógica em torno de como as propriedades são criptografadas.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-365">The delegate also provides for the possibility of logic around how properties are encrypted.</span></span> <span data-ttu-id="3bcd8-366">(Por exemplo, se X, então criptografar a propriedade A; caso contrário, criptografar as propriedades A e B.) Observe que não é necessário fornecer essas informações durante a leitura ou ap consultar entidades.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-366">(For example, if X, then encrypt property A; otherwise encrypt properties A and B.) Note that it is not necessary to provide this information while reading or querying entities.</span></span>

<span data-ttu-id="3bcd8-367">Saiba que atualmente não há suporte para a mesclagem.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-367">Note that merge is not currently supported.</span></span> <span data-ttu-id="3bcd8-368">Como um subconjunto de propriedades pode ter sido criptografado anteriormente usando uma chave diferente, simplesmente mesclar as novas propriedades e atualizar os metadados resultará em perda de dados.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-368">Since a subset of properties may have been encrypted previously using a different key, simply merging the new properties and updating the metadata will result in data loss.</span></span> <span data-ttu-id="3bcd8-369">Mesclar requer fazer chamadas de serviço extra para ler a entidade já existente no serviço ou usar uma nova chave por propriedade, os quais não são ambos adequados por motivos de desempenho.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-369">Merging either requires making extra service calls to read the pre-existing entity from the service, or using a new key per property, both of which are not suitable for performance reasons.</span></span>     

<span data-ttu-id="3bcd8-370">Para obter informações sobre como criptografar dados de tabela, confira [Criptografia do lado do cliente e Cofre da Chave do Azure para Armazenamento do Microsoft Azure](storage-client-side-encryption.md).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-370">For information about encrypting table data, see [Client-Side Encryption and Azure Key Vault for Microsoft Azure Storage](storage-client-side-encryption.md).</span></span>  

## <a name="modelling-relationships"></a><span data-ttu-id="3bcd8-371">Relações de modelagem</span><span class="sxs-lookup"><span data-stu-id="3bcd8-371">Modelling relationships</span></span>
<span data-ttu-id="3bcd8-372">A criação de modelos de domínio é uma etapa importante na criação de sistemas complexos.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-372">Building domain models is a key step in the design of complex systems.</span></span> <span data-ttu-id="3bcd8-373">Normalmente, você usa o processo de modelagem para identificar entidades e as relações entre elas, como uma forma de compreender o domínio de negócios e informar o design do seu sistema.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-373">Typically, you use the modelling process to identify entities and the relationships between them as a way to understand the business domain and inform the design of your system.</span></span> <span data-ttu-id="3bcd8-374">Esta seção se concentra em como você pode converter alguns dos tipos de relações comuns encontrados em modelos de domínio em designs para o serviço Tabela.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-374">This section focuses on how you can translate some of the common relationship types found in domain models to designs for the Table service.</span></span> <span data-ttu-id="3bcd8-375">O processo de mapeamento de um modelo de dados lógico para um modelo de dados baseado em NoSQL físico é muito diferente do usado durante a criação de um banco de dados relacional.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-375">The process of mapping from a logical data-model to a physical NoSQL based data-model is very different from that used when designing a relational database.</span></span> <span data-ttu-id="3bcd8-376">Design de bancos de dados relacionais geralmente assume um processo de normalização de dados otimizado para minimizar a redundância – e uma funcionalidade de consulta declarativa que abstrai como a implementação do banco de dados funciona.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-376">Relational databases design typically assumes a data normalization process optimized for minimizing redundancy – and a declarative querying capability that abstracts how the implementation of how the database works.</span></span>  

### <a name="one-to-many-relationships"></a><span data-ttu-id="3bcd8-377">Relações um-para-muitos</span><span class="sxs-lookup"><span data-stu-id="3bcd8-377">One-to-many relationships</span></span>
<span data-ttu-id="3bcd8-378">Relações um-para-muitos entre objetos de domínio de negócios ocorrerem com muita frequência: por exemplo, um departamento tem muitos funcionários.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-378">One-to-many relationships between business domain objects occur very frequently: for example, one department has many employees.</span></span> <span data-ttu-id="3bcd8-379">Há várias maneiras de implementar relações um-para-muitos no serviço Tabela, cada com prós e contras que podem ser relevantes ao cenário específico.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-379">There are several ways to implement one-to-many relationships in the Table service each with pros and cons that may be relevant to the particular scenario.</span></span>  

<span data-ttu-id="3bcd8-380">Considere o exemplo de uma grande empresa multinacional com dezenas de milhares de departamentos e entidades de funcionário em que cada departamento tem muitos funcionários e cada funcionário associado a um departamento específico.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-380">Consider the example of a large multi-national corporation with tens of thousands of departments and employee entities where every department has many employees and each employee as associated with one specific department.</span></span> <span data-ttu-id="3bcd8-381">Uma abordagem é armazenar departamento separado e entidades de funcionário como estes:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-381">One approach is to store separate department and employee entities such as these:</span></span>  

![][1]

<span data-ttu-id="3bcd8-382">Este exemplo mostra uma relação implícita de um-para-muitos entre os tipos com base no valor **PartitionKey** .</span><span class="sxs-lookup"><span data-stu-id="3bcd8-382">This example shows an implicit one-to-many relationship between the types based on the **PartitionKey** value.</span></span> <span data-ttu-id="3bcd8-383">Cada departamento pode ter muitos funcionários.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-383">Each department can have many employees.</span></span>  

<span data-ttu-id="3bcd8-384">Este exemplo também mostra uma entidade de departamento e suas entidades de funcionário relacionadas na mesma partição.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-384">This example also shows a department entity and its related employee entities in the same partition.</span></span> <span data-ttu-id="3bcd8-385">Você pode optar por usar diferentes partições, tabelas ou até mesmo contas de armazenamento para os diferentes tipos de entidade.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-385">You could choose to use different partitions, tables, or even storage accounts for the different entity types.</span></span>  

<span data-ttu-id="3bcd8-386">Uma abordagem alternativa é desnormalizar seus dados e armazenar apenas entidades de funcionário com dados desnormalizados de departamento, conforme mostrado no exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-386">An alternative approach is to denormalize your data and store only employee entities with denormalized department data as shown in the following example.</span></span> <span data-ttu-id="3bcd8-387">Neste cenário específico, essa abordagem desnormalizada pode não ser a melhor se você precisar ser capaz de alterar os detalhes de um gerente de departamento, pois para isso você precisa atualizar todos os funcionários do departamento.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-387">In this particular scenario, this denormalized approach may not be the best if you have a requirement to be able to change the details of a department manager because to do this you need to update every employee in the department.</span></span>  

![][2]

<span data-ttu-id="3bcd8-388">Para saber mais, confira [Padrão de desnormalização](#denormalization-pattern) mais adiante neste guia.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-388">For more information, see the [Denormalization pattern](#denormalization-pattern) later in this guide.</span></span>  

<span data-ttu-id="3bcd8-389">A tabela a seguir resume os prós e contras de cada uma das abordagens descritas acima para o armazenamento de entidades de funcionário e departamento que têm uma relação um-para-muitos.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-389">The following table summarizes the pros and cons of each of the approaches outlined above for storing employee and department entities that have a one-to-many relationship.</span></span> <span data-ttu-id="3bcd8-390">Você também deve considerar a frequência com que pretende executar várias operações: pode ser aceitável ter um projeto que inclui uma operação cara, se essa operação ocorrer apenas raramente.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-390">You should also consider how often you expect to perform various operations: it may be acceptable to have a design that includes an expensive operation if that operation only happens infrequently.</span></span>  

<table>
<tr>
<th><span data-ttu-id="3bcd8-391">Abordagem</span><span class="sxs-lookup"><span data-stu-id="3bcd8-391">Approach</span></span></th>
<th><span data-ttu-id="3bcd8-392">Prós</span><span class="sxs-lookup"><span data-stu-id="3bcd8-392">Pros</span></span></th>
<th><span data-ttu-id="3bcd8-393">Contras</span><span class="sxs-lookup"><span data-stu-id="3bcd8-393">Cons</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="3bcd8-394">Separar tipos de entidade, mesma partição, mesma tabela</span><span class="sxs-lookup"><span data-stu-id="3bcd8-394">Separate entity types, same partition, same table</span></span></td>
<td>
<ul>
<li><span data-ttu-id="3bcd8-395">Você pode atualizar uma entidade de departamento com uma única operação.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-395">You can update a department entity with a single operation.</span></span></li>
<li><span data-ttu-id="3bcd8-396">Você pode usar uma EGT para manter a consistência se precisar modificar uma entidade de departamento sempre que atualizar/inserir/excluir uma entidade de funcionário.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-396">You can use an EGT to maintain consistency if you have a requirement to modify a department entity whenever you update/insert/delete an employee entity.</span></span> <span data-ttu-id="3bcd8-397">Por exemplo, se você mantiver uma contagem de funcionários do departamento para cada departamento.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-397">For example if you maintain a departmental employee count for each department.</span></span></li>
</ul>
</td>
<td>
<ul>
<li><span data-ttu-id="3bcd8-398">Talvez seja necessário recuperar uma entidade de funcionário e departamento para algumas atividades do cliente.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-398">You may need to retrieve both an employee and a department entity for some client activities.</span></span></li>
<li><span data-ttu-id="3bcd8-399">As operações de armazenamento ocorrem na mesma partição.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-399">Storage operations happen in the same partition.</span></span> <span data-ttu-id="3bcd8-400">Em grandes volumes de transações, isso pode resultar em um ponto de acesso.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-400">At high transaction volumes, this may result in a hotspot.</span></span></li>
<li><span data-ttu-id="3bcd8-401">Não é possível mover um funcionário para outro departamento usando uma EGT.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-401">You cannot move an employee to a new department using an EGT.</span></span></li>
</ul>
</td>
</tr>
<tr>
<td><span data-ttu-id="3bcd8-402">Tipos de entidade separada, diferentes partições ou tabelas ou contas de armazenamento</span><span class="sxs-lookup"><span data-stu-id="3bcd8-402">Separate entity types, different partitions or tables or storage accounts</span></span></td>
<td>
<ul>
<li><span data-ttu-id="3bcd8-403">Você pode atualizar uma entidade de departamento ou funcionário com uma única operação.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-403">You can update a department entity or employee entity with a single operation.</span></span></li>
<li><span data-ttu-id="3bcd8-404">Em grandes volumes de transações, isso pode ajudar a distribuir a carga entre mais partições.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-404">At high transaction volumes, this may help spread the load across more partitions.</span></span></li>
</ul>
</td>
<td>
<ul>
<li><span data-ttu-id="3bcd8-405">Talvez seja necessário recuperar uma entidade de funcionário e departamento para algumas atividades do cliente.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-405">You may need to retrieve both an employee and a department entity for some client activities.</span></span></li>
<li><span data-ttu-id="3bcd8-406">Não é possível usar EGTs para manter a consistência quando você atualiza/insere/exclui um funcionário e atualiza um departamento.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-406">You cannot use EGTs to maintain consistency when you update/insert/delete an employee and update a department.</span></span> <span data-ttu-id="3bcd8-407">Por exemplo, a atualização de uma contagem de funcionários em uma entidade de departamento.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-407">For example, updating an employee count in a department entity.</span></span></li>
<li><span data-ttu-id="3bcd8-408">Não é possível mover um funcionário para outro departamento usando uma EGT.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-408">You cannot move an employee to a new department using an EGT.</span></span></li>
</ul>
</td>
</tr>
<tr>
<td><span data-ttu-id="3bcd8-409">Desnormalizar em um único tipo de entidade</span><span class="sxs-lookup"><span data-stu-id="3bcd8-409">Denormalize into single entity type</span></span></td>
<td>
<ul>
<li><span data-ttu-id="3bcd8-410">Você pode recuperar todas as informações necessárias com uma única solicitação.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-410">You can retrieve all the information you need with a single request.</span></span></li>
</ul>
</td>
<td>
<ul>
<li><span data-ttu-id="3bcd8-411">Pode ser caro manter a consistência se você precisar atualizar informações do departamento (o exigiria que você atualizasse todos os funcionários em um departamento).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-411">It may be expensive to maintain consistency if you need to update department information (this would require you to update all the employees in a department).</span></span></li>
</ul>
</td>
</tr>
</table>

<span data-ttu-id="3bcd8-412">Como escolher entre essas opções e quais os prós e contras são mais significativos, depende de seus cenários específicos do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-412">How you choose between these options, and which of the pros and cons are most significant, depends on your specific application scenarios.</span></span> <span data-ttu-id="3bcd8-413">Por exemplo, com que frequência você modifica entidades de departamento; todas as consultas de funcionário precisam de informações departamentais adicionais; a que distância você está dos limites de escalabilidade em suas partições ou em sua conta de armazenamento?</span><span class="sxs-lookup"><span data-stu-id="3bcd8-413">For example, how often do you modify department entities; do all your employee queries need the additional departmental information; how close are you to the scalability limits on your partitions or your storage account?</span></span>  

### <a name="one-to-one-relationships"></a><span data-ttu-id="3bcd8-414">Relações um-para-um</span><span class="sxs-lookup"><span data-stu-id="3bcd8-414">One-to-one relationships</span></span>
<span data-ttu-id="3bcd8-415">Modelos de domínio podem incluir relações um-para-um entre entidades.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-415">Domain models may include one-to-one relationships between entities.</span></span> <span data-ttu-id="3bcd8-416">Se você precisar implementar uma relação individual no serviço Tabela, também deve escolher como vincular as duas entidades relacionadas, quando precisar recuperá-las.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-416">If you need to implement a one-to-one relationship in the Table service, you must also choose how to link the two related entities when you need to retrieve them both.</span></span> <span data-ttu-id="3bcd8-417">Esse link pode ser implícito, com base em uma convenção nos valores de chave, ou então explícito, armazenando um link na forma dos valores de **PartitionKey** e **RowKey** em cada entidade até sua entidade relacionada.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-417">This link can be either implicit, based on a convention in the key values, or explicit by storing a link in the form of **PartitionKey** and **RowKey** values in each entity to its related entity.</span></span> <span data-ttu-id="3bcd8-418">Para ver uma discussão sobre a conveniência ou não de armazenar as entidades relacionadas na mesma partição, confira a seção [Relações de um-para-muitos](#one-to-many-relationships).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-418">For a discussion of whether you should store the related entities in the same partition, see the section [One-to-many relationships](#one-to-many-relationships).</span></span>  

<span data-ttu-id="3bcd8-419">Observe que também há considerações de implementação que podem levá-lo a implementar relações um-para-um no serviço Tabela:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-419">Note that there are also implementation considerations that might lead you to implement one-to-one relationships in the Table service:</span></span>  

* <span data-ttu-id="3bcd8-420">Controlando grandes entidades (para obter mais informações, consulte [Padrão de grandes entidades](#large-entities-pattern)).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-420">Handling large entities (for more information, see [Large Entities Pattern](#large-entities-pattern)).</span></span>  
* <span data-ttu-id="3bcd8-421">A implementação de controles de acesso (para saber mais, consulte [Controlando o acesso com assinaturas de acesso compartilhado](#controlling-access-with-shared-access-signatures)).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-421">Implementing access controls (for more information, see [Controlling access with Shared Access Signatures](#controlling-access-with-shared-access-signatures)).</span></span>  

### <a name="join-in-the-client"></a><span data-ttu-id="3bcd8-422">Unindo o cliente</span><span class="sxs-lookup"><span data-stu-id="3bcd8-422">Join in the client</span></span>
<span data-ttu-id="3bcd8-423">Embora haja maneiras de modelar relações no serviço Tabela, você não deve se esquecer de que os dois motivos principais para usar o serviço Tabela são a escalabilidade e o desempenho.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-423">Although there are ways to model relationships in the Table service, you should not forget that the two prime reasons for using the Table service are scalability and performance.</span></span> <span data-ttu-id="3bcd8-424">Se você achar que está modelando muitas relações que comprometem o desempenho e a escalabilidade de sua solução, deverá se perguntar se é necessário criar todas as relações de dados no design de tabela.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-424">If you find you are modelling many relationships that compromise the performance and scalability of your solution, you should ask yourself if it is necessary to build all the data relationships into your table design.</span></span> <span data-ttu-id="3bcd8-425">Você poderá simplificar o design e melhorar a escalabilidade e o desempenho de sua solução se permitir que o aplicativo cliente execute as junções necessárias.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-425">You may be able to simplify the design and improve the scalability and performance of your solution if you let your client application perform any necessary joins.</span></span>  

<span data-ttu-id="3bcd8-426">Por exemplo, se você tiver tabelas pequenas que contêm dados que não são alterados com muita frequência, você pode recuperar esses dados uma vez e armazená-los no cliente.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-426">For example, if you have small tables that contain data that does not change very often, then you can retrieve this data once and cache it on the client.</span></span> <span data-ttu-id="3bcd8-427">Isso pode evitar idas e voltas repetidas para recuperar os mesmos dados.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-427">This can avoid repeated roundtrips to retrieve the same data.</span></span> <span data-ttu-id="3bcd8-428">Nos exemplos que examinamos neste guia, o conjunto dos departamentos em uma pequena organização é provavelmente pequeno e alterado raramente, tornando-o um bom candidato para dados que o aplicativo cliente pode baixar uma vez e armazenar como dados de pesquisa.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-428">In the examples we have looked at in this guide, the set of departments in a small organization is likely to be small and change infrequently making it a good candidate for data that client application can download once and cache as look up data.</span></span>  

### <a name="inheritance-relationships"></a><span data-ttu-id="3bcd8-429">Relações de herança</span><span class="sxs-lookup"><span data-stu-id="3bcd8-429">Inheritance relationships</span></span>
<span data-ttu-id="3bcd8-430">Se seu aplicativo cliente usa um conjunto de classes que fazem parte de uma relação de herança para representar entidades de negócios, você poderá persistir facilmente essas entidades no serviço Tabela.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-430">If your client application uses a set of classes that form part of an inheritance relationship to represent business entities, you can easily persist those entities in the Table service.</span></span> <span data-ttu-id="3bcd8-431">Por exemplo, você pode ter o seguinte conjunto de classes definidas em seu aplicativo cliente, em que **Pessoa** é uma classe abstrata.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-431">For example, you might have the following set of classes defined in your client application where **Person** is an abstract class.</span></span>

![][3]

<span data-ttu-id="3bcd8-432">Você pode persistir instâncias das duas classes concretas no serviço Tabela usando uma única tabela Pessoa com entidades que têm a seguinte aparência:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-432">You can persist instances of the two concrete classes in the Table service using a single Person table using entities in that look like this:</span></span>  

![][4]

<span data-ttu-id="3bcd8-433">Para saber mais sobre como trabalhar com vários tipos de entidade na mesma tabela no código cliente, confira a seção [Trabalhando com tipos de entidade heterogênea](#working-with-heterogeneous-entity-types) mais adiante neste guia.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-433">For more information about working with multiple entity types in the same table in client code, see the section [Working with heterogeneous entity types](#working-with-heterogeneous-entity-types) later in this guide.</span></span> <span data-ttu-id="3bcd8-434">Isso fornece exemplos de como reconhecer o tipo de entidade no código do cliente.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-434">This provides examples of how to recognize the entity type in client code.</span></span>  

## <a name="table-design-patterns"></a><span data-ttu-id="3bcd8-435">Padrões de design de tabela</span><span class="sxs-lookup"><span data-stu-id="3bcd8-435">Table Design Patterns</span></span>
<span data-ttu-id="3bcd8-436">Nas seções anteriores, você viu que algumas discussões detalhadas sobre como otimizar o design da tabela para recuperar dados de entidade usando consultas e para inserir, atualizar e excluir dados de entidade.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-436">In previous sections, you have seen some detailed discussions about how to optimize your table design for both retrieving entity data using queries and for inserting, updating, and deleting entity data.</span></span> <span data-ttu-id="3bcd8-437">Esta seção descreve alguns padrões adequados para uso com soluções de serviço Tabela.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-437">This section describes some patterns appropriate for use with Table service solutions.</span></span> <span data-ttu-id="3bcd8-438">Além disso, você verá como abordar praticamente alguns dos problemas e compensações gerados anteriormente neste guia.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-438">In addition, you will see how you can practically address some of the issues and trade-offs raised previously in this guide.</span></span> <span data-ttu-id="3bcd8-439">O diagrama a seguir resume as relações entre os diferentes padrões:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-439">The following diagram summarizes the relationships between the different patterns:</span></span>  

![][5]

<span data-ttu-id="3bcd8-440">O mapa padrão acima destaca algumas relações entre padrões (azul) e antipadrões (laranja) documentados neste guia.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-440">The pattern map above highlights some relationships between patterns (blue) and anti-patterns (orange) that are documented in this guide.</span></span> <span data-ttu-id="3bcd8-441">Certamente há muitos outros padrões que vale a pena considerar.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-441">There are of course many other patterns that are worth considering.</span></span> <span data-ttu-id="3bcd8-442">Por exemplo, um dos principais cenários para o serviço Tabela é utilizar o [Padrão de Exibição Materializada](https://msdn.microsoft.com/library/azure/dn589782.aspx) do padrão [CQRS (Segregação de Responsabilidade da Consulta de Comando)](https://msdn.microsoft.com/library/azure/jj554200.aspx).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-442">For example, one of the key scenarios for Table Service is to use the [Materialized View Pattern](https://msdn.microsoft.com/library/azure/dn589782.aspx) from the [Command Query Responsibility Segregation (CQRS)](https://msdn.microsoft.com/library/azure/jj554200.aspx) pattern.</span></span>  

### <a name="intra-partition-secondary-index-pattern"></a><span data-ttu-id="3bcd8-443">Padrão de índice secundário intrapartição</span><span class="sxs-lookup"><span data-stu-id="3bcd8-443">Intra-partition secondary index pattern</span></span>
<span data-ttu-id="3bcd8-444">Armazene várias cópias de cada entidade usando valores diferentes de **RowKey** (na mesma partição) para permitir pesquisas rápidas e eficientes, bem como ordens de classificação alternativas usando valores diferentes de **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-444">Store multiple copies of each entity using different **RowKey** values (in the same partition) to enable fast and efficient lookups and alternate sort orders by using different **RowKey** values.</span></span> <span data-ttu-id="3bcd8-445">Atualizações entre as cópias podem ser mantidas consistentes usando EGTs.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-445">Updates between copies can be kept consistent using EGT's.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="3bcd8-446">Contexto e problema</span><span class="sxs-lookup"><span data-stu-id="3bcd8-446">Context and problem</span></span>
<span data-ttu-id="3bcd8-447">O serviço Tabela indexa automaticamente as entidades usando os valores de **PartitionKey** e **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-447">The Table service automatically indexes entities using the **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="3bcd8-448">Isso habilita um aplicativo cliente a recuperar uma entidade com eficiência usando esses valores.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-448">This enables a client application to retrieve an entity efficiently using these values.</span></span> <span data-ttu-id="3bcd8-449">Por exemplo, usando a estrutura de tabela mostrada abaixo, um aplicativo cliente pode usar uma consulta de ponto para recuperar uma entidade de funcionário individual usando o nome do departamento e a ID do funcionário (os valores de **PartitionKey** e **RowKey**).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-449">For example, using the table structure shown below, a client application can use a point query to retrieve an individual employee entity by using the department name and the employee id (the **PartitionKey** and **RowKey** values).</span></span> <span data-ttu-id="3bcd8-450">Um cliente também pode recuperar entidades classificadas por ID de funcionário dentro de cada departamento.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-450">A client can also retrieve entities sorted by employee id within each department.</span></span>

![][6]

<span data-ttu-id="3bcd8-451">Se você quiser ser capaz de encontrar uma entidade funcionário com base no valor de outra propriedade, como o endereço de email, deve usar uma verificação de partição menos eficiente para localizar uma correspondência.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-451">If you also want to be able to find an employee entity based on the value of another property, such as email address, you must use a less efficient partition scan to find a match.</span></span> <span data-ttu-id="3bcd8-452">Isso ocorre porque o serviço Tabela não fornece índices secundários.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-452">This is because the table service does not provide secondary indexes.</span></span> <span data-ttu-id="3bcd8-453">Além disso, não há opção para solicitar uma lista de funcionários classificados em uma ordem diferente da ordem **RowKey** .</span><span class="sxs-lookup"><span data-stu-id="3bcd8-453">In addition, there is no option to request a list of employees sorted in a different order than **RowKey** order.</span></span>  

#### <a name="solution"></a><span data-ttu-id="3bcd8-454">Solução</span><span class="sxs-lookup"><span data-stu-id="3bcd8-454">Solution</span></span>
<span data-ttu-id="3bcd8-455">Para solucionar a falta de índices secundários, armazene várias cópias de cada entidade com cada cópia, usando um valor diferente de **RowKey** .</span><span class="sxs-lookup"><span data-stu-id="3bcd8-455">To work around the lack of secondary indexes, you can store multiple copies of each entity with each copy using a different **RowKey** value.</span></span> <span data-ttu-id="3bcd8-456">Se você armazenar uma entidade com as estruturas mostradas abaixo, poderá recuperar com eficiência entidades de funcionário com base na ID do funcionário ou endereço de email.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-456">If you store an entity with the structures shown below, you can efficiently retrieve employee entities based on email address or employee id.</span></span> <span data-ttu-id="3bcd8-457">Os valores de prefixo para **RowKey**, "empid_" e "email_" permitem a consulta de um único funcionário ou um intervalo de funcionários usando um intervalo de endereços de email ou IDs de funcionário.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-457">The prefix values for the **RowKey**, "empid_" and "email_" enable you to query for a single employee or a range of employees by using a range of email addresses or employee ids.</span></span>  

![][7]

<span data-ttu-id="3bcd8-458">Os seguintes dois critérios de filtro (uma pesquisa por ID funcionário e uma por endereço de email) especificam consultas de ponto:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-458">The following two filter criteria (one looking up by employee id and one looking up by email address) both specify point queries:</span></span>  

* <span data-ttu-id="3bcd8-459">$filter=(PartitionKey eq 'Sales') and (RowKey eq 'empid_000223')</span><span class="sxs-lookup"><span data-stu-id="3bcd8-459">$filter=(PartitionKey eq 'Sales') and (RowKey eq 'empid_000223')</span></span>  
* <span data-ttu-id="3bcd8-460">$filter=(PartitionKey eq 'Sales') e (RowKey eq 'email_jonesj@contoso.com')</span><span class="sxs-lookup"><span data-stu-id="3bcd8-460">$filter=(PartitionKey eq 'Sales') and (RowKey eq 'email_jonesj@contoso.com')</span></span>  

<span data-ttu-id="3bcd8-461">Ao consultar um intervalo de entidades de funcionário, você poderá, usando uma consulta às entidades com o prefixo apropriado em **RowKey**, especificar um intervalo classificado por ordem de ID de funcionário ou por ordem de endereços de email.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-461">If you query for a range of employee entities, you can specify a range sorted in employee id order, or a range sorted in email address order by querying for entities with the appropriate prefix in the **RowKey**.</span></span>  

* <span data-ttu-id="3bcd8-462">Para localizar todos os funcionários do departamento de vendas com uma ID de funcionário no intervalo 000100 a 000199, use: $filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000100') and (RowKey le 'empid_000199')</span><span class="sxs-lookup"><span data-stu-id="3bcd8-462">To find all the employees in the Sales department with an employee id in the range 000100 to 000199 use: $filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000100') and (RowKey le 'empid_000199')</span></span>  
* <span data-ttu-id="3bcd8-463">Para localizar todos os funcionários do departamento de Vendas com um endereço de email que começa com a letra 'a', use: $filter=(PartitionKey eq 'Sales') and (RowKey ge 'email_a') and (RowKey lt 'email_b')</span><span class="sxs-lookup"><span data-stu-id="3bcd8-463">To find all the employees in the Sales department with an email address starting with the letter 'a' use: $filter=(PartitionKey eq 'Sales') and (RowKey ge 'email_a') and (RowKey lt 'email_b')</span></span>  
  
  <span data-ttu-id="3bcd8-464">Observe que a sintaxe de filtro usada nos exemplos acima é proveniente da API REST do serviço Tabela. Para saber mais, confira [Query Entities](http://msdn.microsoft.com/library/azure/dd179421.aspx) (Consultar Entidades).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-464">Note that the filter syntax used in the examples above is from the Table service REST API, for more information see [Query Entities](http://msdn.microsoft.com/library/azure/dd179421.aspx).</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="3bcd8-465">Problemas e considerações</span><span class="sxs-lookup"><span data-stu-id="3bcd8-465">Issues and considerations</span></span>
<span data-ttu-id="3bcd8-466">Considere os seguintes pontos ao decidir como implementar esse padrão:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-466">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="3bcd8-467">Armazenamento de tabela é relativamente barato, portanto a sobrecarga de custos de armazenar dados duplicados não deve ser uma preocupação importante.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-467">Table storage is relatively cheap to use so the cost overhead of storing duplicate data should not be a major concern.</span></span> <span data-ttu-id="3bcd8-468">No entanto, você deve sempre avaliar o custo de seu design com base nas necessidades de armazenamento previstas e só adicionar entidades duplicadas para dar suporte a consultas que seu aplicativo cliente executará.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-468">However, you should always evaluate the cost of your design based on your anticipated storage requirements and only add duplicate entities to support the queries your client application will execute.</span></span>  
* <span data-ttu-id="3bcd8-469">Como as entidades de índice secundário são armazenadas na mesma partição que as entidades originais, você deve se certificar de não exceder as metas de escalabilidade para uma partição individual.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-469">Because the secondary index entities are stored in the same partition as the original entities, you should ensure that you do not exceed the scalability targets for an individual partition.</span></span>  
* <span data-ttu-id="3bcd8-470">Você pode manter suas entidades duplicadas consistentes entre si usando EGTs para atualizar as duas cópias da entidade atomicamente.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-470">You can keep your duplicate entities consistent with each other by using EGTs to update the two copies of the entity atomically.</span></span> <span data-ttu-id="3bcd8-471">Isso significa que você deve armazenar todas as cópias de uma entidade na mesma partição.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-471">This implies that you should store all copies of an entity in the same partition.</span></span> <span data-ttu-id="3bcd8-472">Para saber mais, confira a seção [Usando transações de grupo de entidades](#entity-group-transactions).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-472">For more information, see the section [Using Entity Group Transactions](#entity-group-transactions).</span></span>  
* <span data-ttu-id="3bcd8-473">O valor usado para **RowKey** deve ser exclusivo para cada entidade.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-473">The value used for the **RowKey** must be unique for each entity.</span></span> <span data-ttu-id="3bcd8-474">Considere o uso de valores de chave composta.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-474">Consider using compound key values.</span></span>  
* <span data-ttu-id="3bcd8-475">O preenchimento de valores numéricos na **RowKey** (por exemplo, a ID de funcionário 000223), permite classificação e filtragem corretas, com base em limites superiores e inferiores.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-475">Padding numeric values in the **RowKey** (for example, the employee id 000223), enables correct sorting and filtering based on upper and lower bounds.</span></span>  
* <span data-ttu-id="3bcd8-476">Você não precisa necessariamente duplicar todas as propriedades da entidade.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-476">You do not necessarily need to duplicate all the properties of your entity.</span></span> <span data-ttu-id="3bcd8-477">Por exemplo, se as consultas que pesquisam as entidades usando o endereço de email em **RowKey** nunca precisarem da idade do funcionário, essas entidades poderão ter a seguinte estrutura:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-477">For example, if the queries that lookup the entities using the email address in the **RowKey** never need the employee's age, these entities could have the following structure:</span></span>

![][8]

* <span data-ttu-id="3bcd8-478">Normalmente é melhor armazenar dados duplicados e certificar-se de que você possa recuperar todos os dados que precisa com uma única consulta, do que usar uma consulta para localizar uma entidade e outra para pesquisar os dados necessários.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-478">It is typically better to store duplicate data and ensure that you can retrieve all the data you need with a single query, than to use one query to locate an entity and another to lookup the required data.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="3bcd8-479">Quando usar esse padrão</span><span class="sxs-lookup"><span data-stu-id="3bcd8-479">When to use this pattern</span></span>
<span data-ttu-id="3bcd8-480">Use esse padrão quando o aplicativo cliente precisar recuperar entidades usando uma variedade de chaves diferentes, quando o cliente precisar recuperar entidades em diferentes ordens de classificação, e onde é possível identificar cada entidade usando uma variedade de valores exclusivos.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-480">Use this pattern when your client application needs to retrieve entities using a variety of different keys, when your client needs to retrieve entities in different sort orders, and where you can identify each entity using a variety of unique values.</span></span> <span data-ttu-id="3bcd8-481">No entanto, você deve ter certeza de que não excederá os limites de escalabilidade da partição durante a execução de pesquisas da entidade, usando valores diferentes de **RowKey** .</span><span class="sxs-lookup"><span data-stu-id="3bcd8-481">However, you should be sure that you do not exceed the partition scalability limits when you are performing entity lookups using the different **RowKey** values.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="3bcd8-482">Diretrizes e padrões relacionados</span><span class="sxs-lookup"><span data-stu-id="3bcd8-482">Related patterns and guidance</span></span>
<span data-ttu-id="3bcd8-483">Os padrões e diretrizes a seguir também podem ser relevantes ao implementar esse padrão:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-483">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="3bcd8-484">Padrão de índice secundário entre partições</span><span class="sxs-lookup"><span data-stu-id="3bcd8-484">Inter-partition secondary index pattern</span></span>](#inter-partition-secondary-index-pattern)
* [<span data-ttu-id="3bcd8-485">Padrão de chave composta</span><span class="sxs-lookup"><span data-stu-id="3bcd8-485">Compound key pattern</span></span>](#compound-key-pattern)
* [<span data-ttu-id="3bcd8-486">Transações do Grupo de Entidades</span><span class="sxs-lookup"><span data-stu-id="3bcd8-486">Entity Group Transactions</span></span>](#entity-group-transactions)
* [<span data-ttu-id="3bcd8-487">Trabalhando com tipos de entidade heterogênea</span><span class="sxs-lookup"><span data-stu-id="3bcd8-487">Working with heterogeneous entity types</span></span>](#working-with-heterogeneous-entity-types)

### <a name="inter-partition-secondary-index-pattern"></a><span data-ttu-id="3bcd8-488">Padrão de índice secundário entre partições</span><span class="sxs-lookup"><span data-stu-id="3bcd8-488">Inter-partition secondary index pattern</span></span>
<span data-ttu-id="3bcd8-489">Armazene várias cópias de cada entidade usando valores diferentes de **RowKey** em partições ou tabelas separadas para permitir pesquisas rápidas e eficientes, bem como ordens de classificação alternativas usando valores diferentes de **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-489">Store multiple copies of each entity using different **RowKey** values in separate partitions or in separate tables to enable fast and efficient lookups and alternate sort orders by using different **RowKey** values.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="3bcd8-490">Contexto e problema</span><span class="sxs-lookup"><span data-stu-id="3bcd8-490">Context and problem</span></span>
<span data-ttu-id="3bcd8-491">O serviço Tabela indexa automaticamente as entidades usando os valores de **PartitionKey** e **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-491">The Table service automatically indexes entities using the **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="3bcd8-492">Isso habilita um aplicativo cliente a recuperar uma entidade com eficiência usando esses valores.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-492">This enables a client application to retrieve an entity efficiently using these values.</span></span> <span data-ttu-id="3bcd8-493">Por exemplo, usando a estrutura de tabela mostrada abaixo, um aplicativo cliente pode usar uma consulta de ponto para recuperar uma entidade de funcionário individual usando o nome do departamento e a ID do funcionário (os valores de **PartitionKey** e **RowKey**).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-493">For example, using the table structure shown below, a client application can use a point query to retrieve an individual employee entity by using the department name and the employee id (the **PartitionKey** and **RowKey** values).</span></span> <span data-ttu-id="3bcd8-494">Um cliente também pode recuperar entidades classificadas por ID de funcionário dentro de cada departamento.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-494">A client can also retrieve entities sorted by employee id within each department.</span></span>  

![][9]

<span data-ttu-id="3bcd8-495">Se você quiser ser capaz de encontrar uma entidade funcionário com base no valor de outra propriedade, como o endereço de email, deve usar uma verificação de partição menos eficiente para localizar uma correspondência.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-495">If you also want to be able to find an employee entity based on the value of another property, such as email address, you must use a less efficient partition scan to find a match.</span></span> <span data-ttu-id="3bcd8-496">Isso ocorre porque o serviço Tabela não fornece índices secundários.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-496">This is because the table service does not provide secondary indexes.</span></span> <span data-ttu-id="3bcd8-497">Além disso, não há opção para solicitar uma lista de funcionários classificados em uma ordem diferente da ordem **RowKey** .</span><span class="sxs-lookup"><span data-stu-id="3bcd8-497">In addition, there is no option to request a list of employees sorted in a different order than **RowKey** order.</span></span>  

<span data-ttu-id="3bcd8-498">Você está prevendo um volume muito alto de transações em relação a essas entidades e deseja minimizar o risco de o serviço Tabela limitar o seu cliente.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-498">You are anticipating a very high volume of transactions against these entities and want to minimize the risk of the Table service throttling your client.</span></span>  

#### <a name="solution"></a><span data-ttu-id="3bcd8-499">Solução</span><span class="sxs-lookup"><span data-stu-id="3bcd8-499">Solution</span></span>
<span data-ttu-id="3bcd8-500">Para solucionar a falta de índices secundários, você pode armazenar várias cópias de cada entidade com cada cópia usando valores diferentes de **PartitionKey** e **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-500">To work around the lack of secondary indexes, you can store multiple copies of each entity with each copy using different **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="3bcd8-501">Se você armazenar uma entidade com as estruturas mostradas abaixo, poderá recuperar com eficiência entidades de funcionário com base na ID do funcionário ou endereço de email.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-501">If you store an entity with the structures shown below, you can efficiently retrieve employee entities based on email address or employee id.</span></span> <span data-ttu-id="3bcd8-502">Os valores de prefixo para **PartitionKey**, "empid_" e "email_" permitem que você identifique o índice que deseja usar para uma consulta.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-502">The prefix values for the **PartitionKey**, "empid_" and "email_" enable you to identify which index you want to use for a query.</span></span>  

![][10]

<span data-ttu-id="3bcd8-503">Os seguintes dois critérios de filtro (uma pesquisa por ID funcionário e uma por endereço de email) especificam consultas de ponto:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-503">The following two filter criteria (one looking up by employee id and one looking up by email address) both specify point queries:</span></span>  

* <span data-ttu-id="3bcd8-504">$filter=(PartitionKey eq 'empid_Sales') and (RowKey eq '000223')</span><span class="sxs-lookup"><span data-stu-id="3bcd8-504">$filter=(PartitionKey eq 'empid_Sales') and (RowKey eq '000223')</span></span>
* <span data-ttu-id="3bcd8-505">$filter=(PartitionKey eq 'email_Sales') e (RowKey eq 'jonesj@contoso.com')</span><span class="sxs-lookup"><span data-stu-id="3bcd8-505">$filter=(PartitionKey eq 'email_Sales') and (RowKey eq 'jonesj@contoso.com')</span></span>  

<span data-ttu-id="3bcd8-506">Ao consultar um intervalo de entidades de funcionário, você poderá, usando uma consulta às entidades com o prefixo apropriado em **RowKey**, especificar um intervalo classificado por ordem de ID de funcionário ou por ordem de endereços de email.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-506">If you query for a range of employee entities, you can specify a range sorted in employee id order, or a range sorted in email address order by querying for entities with the appropriate prefix in the **RowKey**.</span></span>  

* <span data-ttu-id="3bcd8-507">Para localizar todos os funcionários do departamento de vendas com uma ID de funcionário no intervalo de **000100** a **000199**, classificados por ordem de ID de funcionário, use: $filter=(PartitionKey eq 'empid_Sales') e (RowKey ge '000100') e (RowKey le '000199')</span><span class="sxs-lookup"><span data-stu-id="3bcd8-507">To find all the employees in the Sales department with an employee id in the range **000100** to **000199** sorted in employee id order use: $filter=(PartitionKey eq 'empid_Sales') and (RowKey ge '000100') and (RowKey le '000199')</span></span>  
* <span data-ttu-id="3bcd8-508">Para localizar todos os funcionários do departamento de vendas com um endereço de email que comece com 'a', classificados por ordem de endereço de email, use: $filter=(PartitionKey eq 'email_Sales') and (RowKey ge 'a') and (RowKey lt 'b')</span><span class="sxs-lookup"><span data-stu-id="3bcd8-508">To find all the employees in the Sales department with an email address that starts with 'a' sorted in email address order use: $filter=(PartitionKey eq 'email_Sales') and (RowKey ge 'a') and (RowKey lt 'b')</span></span>  

<span data-ttu-id="3bcd8-509">Observe que a sintaxe de filtro usada nos exemplos acima é proveniente da API REST do serviço Tabela. Para saber mais, confira [Query Entities](http://msdn.microsoft.com/library/azure/dd179421.aspx) (Consultar Entidades).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-509">Note that the filter syntax used in the examples above is from the Table service REST API, for more information see [Query Entities](http://msdn.microsoft.com/library/azure/dd179421.aspx).</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="3bcd8-510">Problemas e considerações</span><span class="sxs-lookup"><span data-stu-id="3bcd8-510">Issues and considerations</span></span>
<span data-ttu-id="3bcd8-511">Considere os seguintes pontos ao decidir como implementar esse padrão:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-511">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="3bcd8-512">Você pode manter suas entidades duplicadas eventualmente consistentes entre si usando o [Padrão de transações eventualmente consistentes](#eventually-consistent-transactions-pattern) para manter as entidades de índice primário e secundário.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-512">You can keep your duplicate entities eventually consistent with each other by using the [Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern) to maintain the primary and secondary index entities.</span></span>  
* <span data-ttu-id="3bcd8-513">Armazenamento de tabela é relativamente barato, portanto a sobrecarga de custos de armazenar dados duplicados não deve ser uma preocupação importante.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-513">Table storage is relatively cheap to use so the cost overhead of storing duplicate data should not be a major concern.</span></span> <span data-ttu-id="3bcd8-514">No entanto, você deve sempre avaliar o custo de seu design com base nas necessidades de armazenamento previstas e só adicionar entidades duplicadas para dar suporte a consultas que seu aplicativo cliente executará.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-514">However, you should always evaluate the cost of your design based on your anticipated storage requirements and only add duplicate entities to support the queries your client application will execute.</span></span>  
* <span data-ttu-id="3bcd8-515">O valor usado para **RowKey** deve ser exclusivo para cada entidade.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-515">The value used for the **RowKey** must be unique for each entity.</span></span> <span data-ttu-id="3bcd8-516">Considere o uso de valores de chave composta.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-516">Consider using compound key values.</span></span>  
* <span data-ttu-id="3bcd8-517">O preenchimento de valores numéricos na **RowKey** (por exemplo, a ID de funcionário 000223), permite classificação e filtragem corretas, com base em limites superiores e inferiores.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-517">Padding numeric values in the **RowKey** (for example, the employee id 000223), enables correct sorting and filtering based on upper and lower bounds.</span></span>  
* <span data-ttu-id="3bcd8-518">Você não precisa necessariamente duplicar todas as propriedades da entidade.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-518">You do not necessarily need to duplicate all the properties of your entity.</span></span> <span data-ttu-id="3bcd8-519">Por exemplo, se as consultas que pesquisam as entidades usando o endereço de email em **RowKey** nunca precisarem da idade do funcionário, essas entidades poderão ter a seguinte estrutura:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-519">For example, if the queries that lookup the entities using the email address in the **RowKey** never need the employee's age, these entities could have the following structure:</span></span>
  
  ![][11]
* <span data-ttu-id="3bcd8-520">É geralmente melhor armazenar dados duplicados e garantir que você possa recuperar todos os dados que precisa com uma única consulta do que usar uma consulta para localizar uma entidade usando o índice secundário e outra para pesquisar os dados necessários no índice primário.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-520">It is typically better to store duplicate data and ensure that you can retrieve all the data you need with a single query than to use one query to locate an entity using the secondary index and another to lookup the required data in the primary index.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="3bcd8-521">Quando usar esse padrão</span><span class="sxs-lookup"><span data-stu-id="3bcd8-521">When to use this pattern</span></span>
<span data-ttu-id="3bcd8-522">Use esse padrão quando o aplicativo cliente precisar recuperar entidades usando uma variedade de chaves diferentes, quando o cliente precisar recuperar entidades em diferentes ordens de classificação, e onde é possível identificar cada entidade usando uma variedade de valores exclusivos.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-522">Use this pattern when your client application needs to retrieve entities using a variety of different keys, when your client needs to retrieve entities in different sort orders, and where you can identify each entity using a variety of unique values.</span></span> <span data-ttu-id="3bcd8-523">Use esse padrão quando quiser evitar exceder os limites de escalabilidade da partição durante a execução de pesquisas de entidade usando os valores diferentes de **RowKey** .</span><span class="sxs-lookup"><span data-stu-id="3bcd8-523">Use this pattern when you want to avoid exceeding the partition scalability limits when you are performing entity lookups using the different **RowKey** values.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="3bcd8-524">Diretrizes e padrões relacionados</span><span class="sxs-lookup"><span data-stu-id="3bcd8-524">Related patterns and guidance</span></span>
<span data-ttu-id="3bcd8-525">Os padrões e diretrizes a seguir também podem ser relevantes ao implementar esse padrão:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-525">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="3bcd8-526">Padrão de transações eventualmente consistentes</span><span class="sxs-lookup"><span data-stu-id="3bcd8-526">Eventually consistent transactions pattern</span></span>](#eventually-consistent-transactions-pattern)  
* [<span data-ttu-id="3bcd8-527">Padrão de índice secundário intrapartição</span><span class="sxs-lookup"><span data-stu-id="3bcd8-527">Intra-partition secondary index pattern</span></span>](#intra-partition-secondary-index-pattern)  
* [<span data-ttu-id="3bcd8-528">Padrão de chave composta</span><span class="sxs-lookup"><span data-stu-id="3bcd8-528">Compound key pattern</span></span>](#compound-key-pattern)  
* [<span data-ttu-id="3bcd8-529">Transações do Grupo de Entidades</span><span class="sxs-lookup"><span data-stu-id="3bcd8-529">Entity Group Transactions</span></span>](#entity-group-transactions)  
* [<span data-ttu-id="3bcd8-530">Trabalhando com tipos de entidade heterogênea</span><span class="sxs-lookup"><span data-stu-id="3bcd8-530">Working with heterogeneous entity types</span></span>](#working-with-heterogeneous-entity-types)  

### <a name="eventually-consistent-transactions-pattern"></a><span data-ttu-id="3bcd8-531">Padrão de transações eventualmente consistentes</span><span class="sxs-lookup"><span data-stu-id="3bcd8-531">Eventually consistent transactions pattern</span></span>
<span data-ttu-id="3bcd8-532">Habilite comportamento eventualmente consistente entre limites de partição ou limites do sistema de armazenamento usando filas do Azure.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-532">Enable eventually consistent behavior across partition boundaries or storage system boundaries by using Azure queues.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="3bcd8-533">Contexto e problema</span><span class="sxs-lookup"><span data-stu-id="3bcd8-533">Context and problem</span></span>
<span data-ttu-id="3bcd8-534">EGTs habilitam transações atômicas entre várias entidades que compartilham a mesma chave de partição.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-534">EGTs enable atomic transactions across multiple entities that share the same partition key.</span></span> <span data-ttu-id="3bcd8-535">Por motivos de escalabilidade e desempenho, você pode optar por armazenar entidades que têm requisitos de consistência em partições separadas ou em um sistema de armazenamento separado: nesse cenário, você não pode usar EGTs para manter a consistência.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-535">For performance and scalability reasons, you might decide to store entities that have consistency requirements in separate partitions or in a separate storage system: in such a scenario, you cannot use EGTs to maintain consistency.</span></span> <span data-ttu-id="3bcd8-536">Por exemplo, você pode ter um requisito para manter a consistência eventual entre:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-536">For example, you might have a requirement to maintain eventual consistency between:</span></span>  

* <span data-ttu-id="3bcd8-537">Entidades armazenadas em duas partições diferentes na mesma tabela em tabelas diferentes e em contas de armazenamento diferentes.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-537">Entities stored in two different partitions in the same table, in different tables, in in different storage accounts.</span></span>  
* <span data-ttu-id="3bcd8-538">Uma entidade armazenada no serviço Tabela e um blob armazenado no serviço Blob.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-538">An entity stored in the Table service and a blob stored in the Blob service.</span></span>  
* <span data-ttu-id="3bcd8-539">Uma entidade armazenada no serviço Tabela e um arquivo em um sistema de arquivos.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-539">An entity stored in the Table service and a file in a file system.</span></span>  
* <span data-ttu-id="3bcd8-540">Um repositório de entidades no serviço Tabela ainda indexado usando o serviço de pesquisa do Azure.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-540">An entity store in the Table service yet indexed using the Azure Search service.</span></span>  

#### <a name="solution"></a><span data-ttu-id="3bcd8-541">Solução</span><span class="sxs-lookup"><span data-stu-id="3bcd8-541">Solution</span></span>
<span data-ttu-id="3bcd8-542">Ao usar as filas do Azure, você pode implementar uma solução que fornece consistência eventual em duas ou mais partições ou sistemas de armazenamento.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-542">By using Azure queues, you can implement a solution that delivers eventual consistency across two or more partitions or storage systems.</span></span>
<span data-ttu-id="3bcd8-543">Para ilustrar essa abordagem, suponha que você tenha de ser capaz de arquivar entidades antigas de funcionário.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-543">To illustrate this approach, assume you have a requirement to be able to archive old employee entities.</span></span> <span data-ttu-id="3bcd8-544">Entidades antigas de funcionário raramente são consultadas e devem ser excluídas de todas as atividades que lidam com funcionários atuais.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-544">Old employee entities are rarely queried and should be excluded from any activities that deal with current employees.</span></span> <span data-ttu-id="3bcd8-545">Para implementar esse requisito, armazene funcionários ativos na tabela **Atual** e funcionários antigos na tabela **Arquivo morto**.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-545">To implement this requirement you store active employees in the **Current** table and old employees in the **Archive** table.</span></span> <span data-ttu-id="3bcd8-546">O arquivamento de um funcionário exige a exclusão da entidade da tabela **Atual** e a adição da entidade à tabela **Arquivo morto**, mas não é possível usar uma EGT para executar essas duas operações.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-546">Archiving an employee requires you to delete the entity from the **Current** table and add the entity to the **Archive** table, but you cannot use an EGT to perform these two operations.</span></span> <span data-ttu-id="3bcd8-547">Para evitar o risco de que uma falha faça com que uma entidade seja exibida nas tabelas ou em nenhuma, a operação de arquivamento deve ser eventualmente consistente.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-547">To avoid the risk that a failure causes an entity to appear in both or neither tables, the archive operation must be eventually consistent.</span></span> <span data-ttu-id="3bcd8-548">O diagrama de sequência a seguir descreve as etapas nesta operação.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-548">The following sequence diagram outlines the steps in this operation.</span></span> <span data-ttu-id="3bcd8-549">Mais detalhes são fornecidos para caminhos de exceção no seguinte texto.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-549">More detail is provided for exception paths in the text following.</span></span>  

![][12]

<span data-ttu-id="3bcd8-550">Um cliente inicia a operação de arquivamento colocando uma mensagem em uma fila do Azure, neste exemplo para arquivar funcionário nº456.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-550">A client initiates the archive operation by placing a message on an Azure queue, in this example to archive employee #456.</span></span> <span data-ttu-id="3bcd8-551">Uma função de trabalho controla a fila para novas mensagens; quando encontra uma, lê a mensagem e deixa uma cópia oculta na fila.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-551">A worker role polls the queue for new messages; when it finds one, it reads the message and leaves a hidden copy on the queue.</span></span> <span data-ttu-id="3bcd8-552">A função de trabalho, em seguida, busca uma cópia da entidade na tabela **Atual**, insere uma cópia na tabela **Arquivo morto** e exclui o original da tabela **Atual**.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-552">The worker role next fetches a copy of the entity from the **Current** table, inserts a copy in the **Archive** table, and then deletes the original from the **Current** table.</span></span> <span data-ttu-id="3bcd8-553">Finalmente, se não houve erros das etapas anteriores, a função de trabalho exclui a mensagem oculta da fila.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-553">Finally, if there were no errors from the previous steps, the worker role deletes the hidden message from the queue.</span></span>  

<span data-ttu-id="3bcd8-554">Neste exemplo, a etapa 4 insere o funcionário na tabela **Arquivo morto** .</span><span class="sxs-lookup"><span data-stu-id="3bcd8-554">In this example, step 4 inserts the employee into the **Archive** table.</span></span> <span data-ttu-id="3bcd8-555">Ele pode adicionar o funcionário em um blob no serviço Blob ou um arquivo em um sistema de arquivos.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-555">It could add the employee to a blob in the Blob service or a file in a file system.</span></span>  

#### <a name="recovering-from-failures"></a><span data-ttu-id="3bcd8-556">Recuperando de falhas</span><span class="sxs-lookup"><span data-stu-id="3bcd8-556">Recovering from failures</span></span>
<span data-ttu-id="3bcd8-557">Caso a função de trabalho precise reiniciar a operação de arquivamento, é importante que as operações nas etapas **4** e **5** sejam *idempotentes*.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-557">It is important that the operations in steps **4** and **5** must be *idempotent* in case the worker role needs to restart the archive operation.</span></span> <span data-ttu-id="3bcd8-558">Se estiver usando o serviço Tabela, na etapa **4**, você deverá usar uma operação "inserir ou substituir"; na etapa **5**, você deverá usar uma operação "excluir se existir" na biblioteca de cliente que está usando.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-558">If you are using the Table service, for step **4** you should use an "insert or replace" operation; for step **5** you should use a "delete if exists" operation in the client library you are using.</span></span> <span data-ttu-id="3bcd8-559">Se você estiver usando outro sistema de armazenamento, deve usar uma operação idempotente apropriada.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-559">If you are using another storage system, you must use an appropriate idempotent operation.</span></span>  

<span data-ttu-id="3bcd8-560">Se a função de trabalho nunca concluir a etapa **6**, após um tempo limite a mensagem reaparecerá na fila, pronta para ser reprocessada pela função de trabalho.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-560">If the worker role never completes step **6**, then after a timeout the message reappears on the queue ready for the worker role to try to reprocess it.</span></span> <span data-ttu-id="3bcd8-561">A função de trabalho pode verificar quantas vezes uma mensagem na fila foi lida e, se necessário, sinalizá-la como uma mensagem "suspeita" para investigação, enviando-a para uma fila separada.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-561">The worker role can check how many times a message on the queue has been read and, if necessary, flag it is a "poison" message for investigation by sending it to a separate queue.</span></span> <span data-ttu-id="3bcd8-562">Para saber mais sobre a leitura de mensagens da fila e verificar a contagem de remoção da fila, consulte [Obter mensagens](https://msdn.microsoft.com/library/azure/dd179474.aspx).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-562">For more information about reading queue messages and checking the dequeue count, see [Get Messages](https://msdn.microsoft.com/library/azure/dd179474.aspx).</span></span>  

<span data-ttu-id="3bcd8-563">Alguns erros dos serviços Tabela e Fila são erros transitórios e o aplicativo cliente deve incluir uma lógica de repetição adequada para lidar com eles.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-563">Some errors from the Table and Queue services are transient errors, and your client application should include suitable retry logic to handle them.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="3bcd8-564">Problemas e considerações</span><span class="sxs-lookup"><span data-stu-id="3bcd8-564">Issues and considerations</span></span>
<span data-ttu-id="3bcd8-565">Considere os seguintes pontos ao decidir como implementar esse padrão:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-565">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="3bcd8-566">Esta solução não fornece isolamento da transação.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-566">This solution does not provide for transaction isolation.</span></span> <span data-ttu-id="3bcd8-567">Por exemplo, um cliente pode ler as tabelas **Atual** e **Arquivo morto** quando a função de trabalho estiver entre as etapas **4** e **5** e ver uma exibição inconsistente dos dados.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-567">For example, a client could read the **Current** and **Archive** tables when the worker role was between steps **4** and **5**, and see an inconsistent view of the data.</span></span> <span data-ttu-id="3bcd8-568">Observe que os dados serão consistentes eventualmente.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-568">Note that the data will be consistent eventually.</span></span>  
* <span data-ttu-id="3bcd8-569">Você deve se certificar de que as etapas 4 e 5 sejam idempotentes para garantir a consistência eventual.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-569">You must be sure that steps 4 and 5 are idempotent in order to ensure eventual consistency.</span></span>  
* <span data-ttu-id="3bcd8-570">Você pode dimensionar a solução usando várias filas e instâncias de função de trabalho.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-570">You can scale the solution by using multiple queues and worker role instances.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="3bcd8-571">Quando usar esse padrão</span><span class="sxs-lookup"><span data-stu-id="3bcd8-571">When to use this pattern</span></span>
<span data-ttu-id="3bcd8-572">Use esse padrão quando quiser garantir a consistência eventual entre entidades que existem nas tabelas ou partições diferentes.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-572">Use this pattern when you want to guarantee eventual consistency between entities that exist in different partitions or tables.</span></span> <span data-ttu-id="3bcd8-573">Você pode estender esse padrão para garantir a consistência eventual de operações entre o serviço Tabela e o serviço Blob e outras fontes de dados de armazenamento não Azure, como banco de dados ou sistema de arquivos.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-573">You can extend this pattern to ensure eventual consistency for operations across the Table service and the Blob service and other non-Azure Storage data sources such as database or the file system.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="3bcd8-574">Diretrizes e padrões relacionados</span><span class="sxs-lookup"><span data-stu-id="3bcd8-574">Related patterns and guidance</span></span>
<span data-ttu-id="3bcd8-575">Os padrões e diretrizes a seguir também podem ser relevantes ao implementar esse padrão:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-575">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="3bcd8-576">Transações do Grupo de Entidades</span><span class="sxs-lookup"><span data-stu-id="3bcd8-576">Entity Group Transactions</span></span>](#entity-group-transactions)  
* [<span data-ttu-id="3bcd8-577">Mesclar ou substituir</span><span class="sxs-lookup"><span data-stu-id="3bcd8-577">Merge or replace</span></span>](#merge-or-replace)  

> [!NOTE]
> <span data-ttu-id="3bcd8-578">Se o isolamento da transação for importante para sua solução, você deve considerar a recriação das tabelas para poder usar as EGTs.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-578">If transaction isolation is important to your solution, you should consider redesigning your tables to enable you to use EGTs.</span></span>  
> 
> 

### <a name="index-entities-pattern"></a><span data-ttu-id="3bcd8-579">Padrão de entidades de índice</span><span class="sxs-lookup"><span data-stu-id="3bcd8-579">Index Entities Pattern</span></span>
<span data-ttu-id="3bcd8-580">Mantenha entidades de índice para habilitar pesquisas eficientes que retornam listas de entidades.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-580">Maintain index entities to enable efficient searches that return lists of entities.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="3bcd8-581">Contexto e problema</span><span class="sxs-lookup"><span data-stu-id="3bcd8-581">Context and problem</span></span>
<span data-ttu-id="3bcd8-582">O serviço Tabela indexa automaticamente as entidades usando os valores de **PartitionKey** e **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-582">The Table service automatically indexes entities using the **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="3bcd8-583">Isso habilita um aplicativo cliente a recuperar uma entidade com eficiência usando uma consulta de ponto.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-583">This enables a client application to retrieve an entity efficiently using a point query.</span></span> <span data-ttu-id="3bcd8-584">Por exemplo, usando a estrutura de tabela mostrada abaixo, um aplicativo cliente pode recuperar de maneira eficiente uma entidade de funcionário individual pelo uso do nome do departamento e da ID do funcionário (**PartitionKey** e **RowKey**).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-584">For example, using the table structure shown below, a client application can efficiently retrieve an individual employee entity by using the department name and the employee id (the **PartitionKey** and **RowKey**).</span></span>  

![][13]

<span data-ttu-id="3bcd8-585">Se você quiser ser capaz de recuperar uma lista de entidades de funcionário com base no valor de outra propriedade não exclusiva, como seu sobrenome, deve usar uma verificação de partição menos eficiente para localizar correspondências em vez de usar um índice para examiná-las diretamente.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-585">If you also want to be able to retrieve a list of employee entities based on the value of another non-unique property, such as their last name, you must use a less efficient partition scan to find matches rather than using an index to look them up directly.</span></span> <span data-ttu-id="3bcd8-586">Isso ocorre porque o serviço Tabela não fornece índices secundários.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-586">This is because the table service does not provide secondary indexes.</span></span>  

#### <a name="solution"></a><span data-ttu-id="3bcd8-587">Solução</span><span class="sxs-lookup"><span data-stu-id="3bcd8-587">Solution</span></span>
<span data-ttu-id="3bcd8-588">Para habilitar a pesquisa por sobrenome com a estrutura de entidade mostrada acima, você deve manter listas de ids de funcionário.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-588">To enable lookup by last name with the entity structure shown above, you must maintain lists of employee ids.</span></span> <span data-ttu-id="3bcd8-589">Para recuperar entidades de funcionário com determinado sobrenome, como Dias, primeiro localize a lista de ids de funcionário para os funcionários com Dias como sobrenome e recupere essas entidades.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-589">If you want to retrieve the employee entities with a particular last name, such as Jones, you must first locate the list of employee ids for employees with Jones as their last name, and then retrieve those employee entities.</span></span> <span data-ttu-id="3bcd8-590">Há três opções principais para armazenar listas de ids de funcionário:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-590">There are three main options for storing the lists of employee ids:</span></span>  

* <span data-ttu-id="3bcd8-591">Use o armazenamento de blobs.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-591">Use blob storage.</span></span>  
* <span data-ttu-id="3bcd8-592">Crie entidades de índice na mesma partição que as entidades do funcionário.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-592">Create index entities in the same partition as the employee entities.</span></span>  
* <span data-ttu-id="3bcd8-593">Crie entidades de índice em uma partição ou tabela separada.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-593">Create index entities in a separate partition or table.</span></span>  

<span data-ttu-id="3bcd8-594"><u>Opção n°. 1: usar o armazenamento de blob</u></span><span class="sxs-lookup"><span data-stu-id="3bcd8-594"><u>Option #1: Use blob storage</u></span></span>  

<span data-ttu-id="3bcd8-595">Para a primeira opção, crie um blob para todos os sobrenomes exclusivos e em cada repositório de blobs uma lista de valores **PartitionKey** (departamento) e **RowKey** (ID do funcionário) para os funcionários com esse sobrenome.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-595">For the first option, you create a blob for every unique last name, and in each blob store a list of the **PartitionKey** (department) and **RowKey** (employee id) values for employees that have that last name.</span></span> <span data-ttu-id="3bcd8-596">Quando você adiciona ou exclui um funcionário, deve garantir que o conteúdo do blob relevante seja eventualmente consistente com as entidades do funcionário.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-596">When you add or delete an employee you should ensure that the content of the relevant blob is eventually consistent with the employee entities.</span></span>  

<span data-ttu-id="3bcd8-597"><u>Opção 2:</u> Criar entidades de índice na mesma partição</span><span class="sxs-lookup"><span data-stu-id="3bcd8-597"><u>Option #2:</u> Create index entities in the same partition</span></span>  

<span data-ttu-id="3bcd8-598">Para a segunda opção, use as entidades de índice que armazenam os dados a seguir:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-598">For the second option, use index entities that store the following data:</span></span>  

![][14]

<span data-ttu-id="3bcd8-599">A propriedade **EmployeeIDs** contém uma lista de IDs de funcionário para os funcionários com o sobrenome armazenado em **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-599">The **EmployeeIDs** property contains a list of employee ids for employees with the last name stored in the **RowKey**.</span></span>  

<span data-ttu-id="3bcd8-600">As etapas a seguir descrevem o processo que você deve seguir ao adicionar um novo funcionário, se você estiver usando a segunda opção.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-600">The following steps outline the process you should follow when you are adding a new employee if you are using the second option.</span></span> <span data-ttu-id="3bcd8-601">Neste exemplo, estamos adicionando um funcionário com ID 000152 e um sobrenome Jones no departamento de Vendas:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-601">In this example, we are adding an employee with Id 000152 and a last name Jones in the Sales department:</span></span>  

1. <span data-ttu-id="3bcd8-602">Recupere a entidade de índice com um valor de **PartitionKey** igual a "Vendas" e valor de **RowKey** igual a "Dias".</span><span class="sxs-lookup"><span data-stu-id="3bcd8-602">Retrieve the index entity with a **PartitionKey** value "Sales" and the **RowKey** value "Jones."</span></span> <span data-ttu-id="3bcd8-603">Salve o ETag dessa entidade para usar na etapa 2.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-603">Save the ETag of this entity to use in step 2.</span></span>  
2. <span data-ttu-id="3bcd8-604">Crie uma transação de grupo de entidades (ou seja, uma operação em lote) que insira a nova entidade de funcionário (valor de **PartitionKey** igual a "Vendas" e valor de **RowKey** igual a "000152") e atualize a entidade de índice (valor de **PartitionKey** igual a "Vendas" e valor de **RowKey** igual a "Dias"), adicionando a ID do novo funcionário à lista no campo EmployeeIDs.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-604">Create an entity group transaction (that is, a batch operation) that inserts the new employee entity (**PartitionKey** value "Sales" and **RowKey** value "000152"), and updates the index entity (**PartitionKey** value "Sales" and **RowKey** value "Jones") by adding the new employee id to the list in the EmployeeIDs field.</span></span> <span data-ttu-id="3bcd8-605">Para saber mais sobre transações de grupo de entidades, confira a seção [Transações de grupo de entidades](#entity-group-transactions).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-605">For more information about entity group transactions, see [Entity Group Transactions](#entity-group-transactions).</span></span>  
3. <span data-ttu-id="3bcd8-606">Se a transação de grupo de entidades falhar devido a um erro de simultaneidade otimista (alguém modificou a entidade de índice), será necessário recomeçar na etapa 1.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-606">If the entity group transaction fails because of an optimistic concurrency error (someone else has just modified the index entity), then you need to start over at step 1 again.</span></span>  

<span data-ttu-id="3bcd8-607">Você pode usar uma abordagem semelhante à exclusão de um funcionário se usar a segunda opção.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-607">You can use a similar approach to deleting an employee if you are using the second option.</span></span> <span data-ttu-id="3bcd8-608">Alterar o sobrenome do funcionário é um pouco mais complexo, pois você precisará executar uma transação de grupo de entidades que atualiza as três entidades: a entidade funcionário, a entidade de índice para o sobrenome antigo e a entidade de índice para o novo sobrenome.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-608">Changing an employee's last name is slightly more complex because you will need to execute an entity group transaction that updates three entities: the employee entity, the index entity for the old last name, and the index entity for the new last name.</span></span> <span data-ttu-id="3bcd8-609">Você deve recuperar cada entidade antes de fazer alterações para recuperar os valores de ETag que depois pode usar para executar as atualizações usando a simultaneidade otimista.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-609">You must retrieve each entity before making any changes in order to retrieve the ETag values that you can then use to perform the updates using optimistic concurrency.</span></span>  

<span data-ttu-id="3bcd8-610">As etapas abaixo descrevem o processo que você deve seguir quando precisar procurar todos os funcionários com determinado sobrenome em um departamento, se estiver usando a segunda opção.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-610">The following steps outline the process you should follow when you need to look up all the employees with a given last name in a department if you are using the second option.</span></span> <span data-ttu-id="3bcd8-611">Neste exemplo, estamos procurando todos os funcionários com o sobrenome Dias no departamento de Vendas:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-611">In this example, we are looking up all the employees with last name Jones in the Sales department:</span></span>  

1. <span data-ttu-id="3bcd8-612">Recupere a entidade de índice com um valor de **PartitionKey** igual a "Vendas" e valor de **RowKey** igual a "Dias".</span><span class="sxs-lookup"><span data-stu-id="3bcd8-612">Retrieve the index entity with a **PartitionKey** value "Sales" and the **RowKey** value "Jones."</span></span>  
2. <span data-ttu-id="3bcd8-613">Analise a lista de Ids no campo EmployeeIDs.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-613">Parse the list of employee Ids in the EmployeeIDs field.</span></span>  
3. <span data-ttu-id="3bcd8-614">Se precisar de informações adicionais sobre cada um desses funcionários (como endereços de email), recupere cada uma das entidades de funcionário usando o valor de **PartitionKey** igual a "Vendas" e os valores de **RowKey** da lista de funcionários obtida na etapa 2.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-614">If you need additional information about each of these employees (such as their email addresses), retrieve each of the employee entities using **PartitionKey** value "Sales" and **RowKey** values from the list of employees you obtained in step 2.</span></span>  

<span data-ttu-id="3bcd8-615"><u>Opção 3:</u> criar entidades de índice em uma partição ou tabela separada</span><span class="sxs-lookup"><span data-stu-id="3bcd8-615"><u>Option #3:</u> Create index entities in a separate partition or table</span></span>  

<span data-ttu-id="3bcd8-616">Para a terceira opção, use as entidades de índice que armazenam os dados a seguir:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-616">For the third option, use index entities that store the following data:</span></span>  

![][15]

<span data-ttu-id="3bcd8-617">A propriedade **EmployeeIDs** contém uma lista de IDs de funcionário para os funcionários com o sobrenome armazenado em **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-617">The **EmployeeIDs** property contains a list of employee ids for employees with the last name stored in the **RowKey**.</span></span>  

<span data-ttu-id="3bcd8-618">Com a terceira opção, você não pode usar EGTs para manter a consistência porque as entidades de índice estão em uma partição separada das entidades de funcionário.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-618">With the third option, you cannot use EGTs to maintain consistency because the index entities are in a separate partition from the employee entities.</span></span> <span data-ttu-id="3bcd8-619">Certifique-se de que as entidades de índice sejam eventualmente consistentes com as entidades de funcionário.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-619">You should ensure that the index entities are eventually consistent with the employee entities.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="3bcd8-620">Problemas e considerações</span><span class="sxs-lookup"><span data-stu-id="3bcd8-620">Issues and considerations</span></span>
<span data-ttu-id="3bcd8-621">Considere os seguintes pontos ao decidir como implementar esse padrão:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-621">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="3bcd8-622">Essa solução exige, pelo menos, duas consultas para recuperar entidades correspondentes: uma para consultar as entidades de índice para obter a lista de valores de **RowKey** e consultas para recuperar cada entidade na lista.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-622">This solution requires at least two queries to retrieve matching entities: one to query the index entities to obtain the list of **RowKey** values, and then queries to retrieve each entity in the list.</span></span>  
* <span data-ttu-id="3bcd8-623">Considerando que uma entidade individual tem um tamanho máximo de 1 MB, as opções nº2 e 3 na solução supõem que a lista de ids de funcionário para determinado sobrenome nunca é maior que 1 MB.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-623">Given that an individual entity has a maximum size of 1 MB, option #2 and option #3 in the solution assume that the list of employee ids for any given last name is never greater than 1 MB.</span></span> <span data-ttu-id="3bcd8-624">Se a lista de ids de funcionário é provavelmente maior que 1 MB em tamanho, use a opção nº1 e armazene os dados de índice no armazenamento de blob.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-624">If the list of employee ids is likely to be greater than 1 MB in size, use option #1 and store the index data in blob storage.</span></span>  
* <span data-ttu-id="3bcd8-625">Se você usar a opção n. 2 (usando EGTs para controlar a adição e exclusão de funcionários e alterar o sobrenome do funcionário), você deverá avaliar se o volume de transações abordará os limites de escalabilidade em uma determinada partição.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-625">If you use option #2 (using EGTs to handle adding and deleting employees, and changing an employee's last name) you must evaluate if the volume of transactions will approach the scalability limits in a given partition.</span></span> <span data-ttu-id="3bcd8-626">Se esse for o caso, você deve considerar uma solução eventualmente consistente (opção nº1 ou 3) que usa filas para manipular solicitações de atualização e permite que você armazene suas entidades de índice em uma partição separada das entidades de funcionário.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-626">If this is the case, you should consider an eventually consistent solution (option #1 or option #3) that uses queues to handle the update requests and enables you to store your index entities in a separate partition from the employee entities.</span></span>  
* <span data-ttu-id="3bcd8-627">A opção nº2 nesta solução pressupõe que você deseja pesquisar por sobrenome dentro de um departamento: por exemplo, você quer recuperar uma lista de funcionários com um sobrenome Jones no departamento de Vendas.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-627">Option #2 in this solution assumes that you want to look up by last name within a department: for example, you want to retrieve a list of employees with a last name Jones in the Sales department.</span></span> <span data-ttu-id="3bcd8-628">Para pesquisar todos os funcionários com um sobrenome Jones em toda a organização, use a opção nº1 ou 3.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-628">If you want to be able to look up all the employees with a last name Jones across the whole organization, use either option #1 or option #3.</span></span>
* <span data-ttu-id="3bcd8-629">É possível implementar uma solução baseada em fila que fornece consistência eventual (veja [Padrão de transações eventualmente consistentes](#eventually-consistent-transactions-pattern) para obter mais detalhes).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-629">You can implement a queue-based solution that delivers eventual consistency (see the [Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern) for more details).</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="3bcd8-630">Quando usar esse padrão</span><span class="sxs-lookup"><span data-stu-id="3bcd8-630">When to use this pattern</span></span>
<span data-ttu-id="3bcd8-631">Use esse padrão quando quiser pesquisar um conjunto de entidades que compartilham um valor da propriedade comum, como todos os funcionários com o sobrenome Dias.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-631">Use this pattern when you want to lookup a set of entities that all share a common property value, such as all employees with the last name Jones.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="3bcd8-632">Diretrizes e padrões relacionados</span><span class="sxs-lookup"><span data-stu-id="3bcd8-632">Related patterns and guidance</span></span>
<span data-ttu-id="3bcd8-633">Os padrões e diretrizes a seguir também podem ser relevantes ao implementar esse padrão:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-633">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="3bcd8-634">Padrão de chave composta</span><span class="sxs-lookup"><span data-stu-id="3bcd8-634">Compound key pattern</span></span>](#compound-key-pattern)  
* [<span data-ttu-id="3bcd8-635">Padrão de transações eventualmente consistentes</span><span class="sxs-lookup"><span data-stu-id="3bcd8-635">Eventually consistent transactions pattern</span></span>](#eventually-consistent-transactions-pattern)  
* [<span data-ttu-id="3bcd8-636">Transações do Grupo de Entidades</span><span class="sxs-lookup"><span data-stu-id="3bcd8-636">Entity Group Transactions</span></span>](#entity-group-transactions)  
* [<span data-ttu-id="3bcd8-637">Trabalhando com tipos de entidade heterogênea</span><span class="sxs-lookup"><span data-stu-id="3bcd8-637">Working with heterogeneous entity types</span></span>](#working-with-heterogeneous-entity-types)  

### <a name="denormalization-pattern"></a><span data-ttu-id="3bcd8-638">Padrão de desnormalização</span><span class="sxs-lookup"><span data-stu-id="3bcd8-638">Denormalization pattern</span></span>
<span data-ttu-id="3bcd8-639">Combine dados relacionados juntos em uma única entidade para que você possa recuperar todos os dados que precisa com uma ponto único de consulta.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-639">Combine related data together in a single entity to enable you to retrieve all the data you need with a single point query.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="3bcd8-640">Contexto e problema</span><span class="sxs-lookup"><span data-stu-id="3bcd8-640">Context and problem</span></span>
<span data-ttu-id="3bcd8-641">Em um banco de dados relacional, você geralmente normaliza dados para remover a duplicação, resultando em consultas que recuperam dados de várias tabelas.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-641">In a relational database, you typically normalize data to remove duplication resulting in queries that retrieve data from multiple tables.</span></span> <span data-ttu-id="3bcd8-642">Se você normalizar dados em tabelas do Azure, terá de ir e voltar várias vezes do cliente ao servidor para recuperar os dados relacionados.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-642">If you normalize your data in Azure tables, you must make multiple round trips from the client to the server to retrieve your related data.</span></span> <span data-ttu-id="3bcd8-643">Por exemplo, com a estrutura de tabela mostrada abaixo, você precisa de dois viagens de ida e volta para recuperar os detalhes de um departamento: uma para buscar a entidade do departamento que inclui a ID do gerente e outra solicitação para buscar detalhes do gerente em uma entidade de funcionário.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-643">For example, with the table structure shown below you need two round trips to retrieve the details for a department: one to fetch the department entity that includes the manager's id, and then another request to fetch the manager's details in an employee entity.</span></span>  

![][16]

#### <a name="solution"></a><span data-ttu-id="3bcd8-644">Solução</span><span class="sxs-lookup"><span data-stu-id="3bcd8-644">Solution</span></span>
<span data-ttu-id="3bcd8-645">Em vez de armazenar os dados em duas entidades separadas, desnormalize os dados e mantenha uma cópia dos detalhes do gerente na entidade de departamento.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-645">Instead of storing the data in two separate entities, denormalize the data and keep a copy of the manager's details in the department entity.</span></span> <span data-ttu-id="3bcd8-646">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-646">For example:</span></span>  

![][17]

<span data-ttu-id="3bcd8-647">Com entidades de departamento armazenadas com essas propriedades, agora você pode recuperar todos os detalhes de que precisa sobre um departamento usando uma consulta de ponto.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-647">With department entities stored with these properties, you can now retrieve all the details you need about a department using a point query.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="3bcd8-648">Problemas e considerações</span><span class="sxs-lookup"><span data-stu-id="3bcd8-648">Issues and considerations</span></span>
<span data-ttu-id="3bcd8-649">Considere os seguintes pontos ao decidir como implementar esse padrão:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-649">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="3bcd8-650">Existe alguma sobrecarga de custo associada ao armazenar alguns dados duas vezes.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-650">There is some cost overhead associated with storing some data twice.</span></span> <span data-ttu-id="3bcd8-651">O benefício de desempenho (resultante de menos solicitações ao serviço de armazenamento) normalmente supera o aumento marginal nos custos de armazenamento (e esse custo é parcialmente compensado por uma redução no número de transações que você precisa para obter detalhes de um departamento).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-651">The performance benefit (resulting from fewer requests to the storage service) typically outweighs the marginal increase in storage costs (and this cost is partially offset by a reduction in the number of transactions you require to fetch the details of a department).</span></span>  
* <span data-ttu-id="3bcd8-652">Você deve manter a consistência das duas entidades que armazenam informações sobre os gerentes.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-652">You must maintain the consistency of the two entities that store information about managers.</span></span> <span data-ttu-id="3bcd8-653">Você pode tratar o problema de consistência usando EGTs para atualizar várias entidades em uma única transação atômica: nesse caso, a entidade de departamento e a entidade de funcionário para o gerente do departamento são armazenadas na mesma partição.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-653">You can handle the consistency issue by using EGTs to update multiple entities in a single atomic transaction: in this case, the department entity, and the employee entity for the department manager are stored in the same partition.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="3bcd8-654">Quando usar esse padrão</span><span class="sxs-lookup"><span data-stu-id="3bcd8-654">When to use this pattern</span></span>
<span data-ttu-id="3bcd8-655">Use esse padrão quando precisar pesquisar informações relacionadas com frequência.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-655">Use this pattern when you frequently need to look up related information.</span></span> <span data-ttu-id="3bcd8-656">Esse padrão reduz o número de consultas que o cliente deve fazer para recuperar os dados necessários.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-656">This pattern reduces the number of queries your client must make to retrieve the data it requires.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="3bcd8-657">Diretrizes e padrões relacionados</span><span class="sxs-lookup"><span data-stu-id="3bcd8-657">Related patterns and guidance</span></span>
<span data-ttu-id="3bcd8-658">Os padrões e diretrizes a seguir também podem ser relevantes ao implementar esse padrão:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-658">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="3bcd8-659">Padrão de chave composta</span><span class="sxs-lookup"><span data-stu-id="3bcd8-659">Compound key pattern</span></span>](#compound-key-pattern)  
* [<span data-ttu-id="3bcd8-660">Transações do Grupo de Entidades</span><span class="sxs-lookup"><span data-stu-id="3bcd8-660">Entity Group Transactions</span></span>](#entity-group-transactions)  
* [<span data-ttu-id="3bcd8-661">Trabalhando com tipos de entidade heterogênea</span><span class="sxs-lookup"><span data-stu-id="3bcd8-661">Working with heterogeneous entity types</span></span>](#working-with-heterogeneous-entity-types)

### <a name="compound-key-pattern"></a><span data-ttu-id="3bcd8-662">Padrão de chave composta</span><span class="sxs-lookup"><span data-stu-id="3bcd8-662">Compound key pattern</span></span>
<span data-ttu-id="3bcd8-663">Use valores **RowKey** compostos para permitir que um cliente pesquise dados relacionados a uma consulta de ponto único.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-663">Use compound **RowKey** values to enable a client to lookup related data with a single point query.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="3bcd8-664">Contexto e problema</span><span class="sxs-lookup"><span data-stu-id="3bcd8-664">Context and problem</span></span>
<span data-ttu-id="3bcd8-665">Em um banco de dados relacional, é bastante natural usar junções em consultas para retornar partes relacionadas de dados para o cliente em uma única consulta.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-665">In a relational database, it is quite natural to use joins in queries to return related pieces of data to the client in a single query.</span></span> <span data-ttu-id="3bcd8-666">Por exemplo, você pode usar a ID do funcionário para pesquisar uma lista de entidades relacionadas que contém o desempenho e analisar os dados desse funcionário.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-666">For example, you might use the employee id to look up a list of related entities that contain performance and review data for that employee.</span></span>  

<span data-ttu-id="3bcd8-667">Suponhamos que você esteja armazenando entidades de funcionário no serviço Tabela usando a seguinte estrutura:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-667">Assume you are storing employee entities in the Table service using the following structure:</span></span>  

![][18]

<span data-ttu-id="3bcd8-668">Você também precisa armazenar dados históricos relacionados a revisões e desempenho de cada ano que o funcionário trabalhou para a sua organização e precisa ser capaz de acessar essas informações por ano.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-668">You also need to store historical data relating to reviews and performance for each year the employee has worked for your organization and you need to be able to access this information by year.</span></span> <span data-ttu-id="3bcd8-669">Uma opção é criar outra tabela que armazena entidades com a seguinte estrutura:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-669">One option is to create another table that stores entities with the following structure:</span></span>  

![][19]

<span data-ttu-id="3bcd8-670">Observe que com essa abordagem você poderá duplicar algumas informações (como nome e sobrenome) na nova entidade para recuperar seus dados com uma única solicitação.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-670">Notice that with this approach you may decide to duplicate some information (such as first name and last name) in the new entity to enable you to retrieve your data with a single request.</span></span> <span data-ttu-id="3bcd8-671">No entanto, não é possível manter uma coerência forte porque você não pode usar uma EGT para atualizar as duas entidades atomicamente.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-671">However, you cannot maintain strong consistency because you cannot use an EGT to update the two entities atomically.</span></span>  

#### <a name="solution"></a><span data-ttu-id="3bcd8-672">Solução</span><span class="sxs-lookup"><span data-stu-id="3bcd8-672">Solution</span></span>
<span data-ttu-id="3bcd8-673">Armazene um novo tipo de entidade em sua tabela original usando entidades com a seguinte estrutura:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-673">Store a new entity type in your original table using entities with the following structure:</span></span>  

![][20]

<span data-ttu-id="3bcd8-674">Observe como a **RowKey** agora é uma chave composta de ID de funcionário e o ano dos dados de revisão que permitem recuperar o desempenho do funcionário e analisar os dados com uma única solicitação para uma única entidade.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-674">Notice how the **RowKey** is now a compound key made up of the employee id and the year of the review data that enables you to retrieve the employee's performance and review data with a single request for a single entity.</span></span>  

<span data-ttu-id="3bcd8-675">O exemplo a seguir descreve como você pode recuperar todos os dados de revisão de um funcionário específico (por exemplo, um funcionário 000123 no departamento de Vendas):</span><span class="sxs-lookup"><span data-stu-id="3bcd8-675">The following example outlines how you can retrieve all the review data for a particular employee (such as employee 000123 in the Sales department):</span></span>  

<span data-ttu-id="3bcd8-676">$filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000123') and (RowKey lt 'empid_000124')&$select=RowKey,Manager Rating,Peer Rating,Comments</span><span class="sxs-lookup"><span data-stu-id="3bcd8-676">$filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000123') and (RowKey lt 'empid_000124')&$select=RowKey,Manager Rating,Peer Rating,Comments</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="3bcd8-677">Problemas e considerações</span><span class="sxs-lookup"><span data-stu-id="3bcd8-677">Issues and considerations</span></span>
<span data-ttu-id="3bcd8-678">Considere os seguintes pontos ao decidir como implementar esse padrão:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-678">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="3bcd8-679">Você deve usar um caractere separador adequado que facilite a análise do valor de **RowKey**: por exemplo, **000123_2012**.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-679">You should use a suitable separator character that makes it easy to parse the **RowKey** value: for example, **000123_2012**.</span></span>  
* <span data-ttu-id="3bcd8-680">Você também está armazenando essa entidade na mesma partição que outras entidades que contêm dados relacionados para o mesmo funcionário, o que significa que você pode usar EGTs para manter a coerência forte.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-680">You are also storing this entity in the same partition as other entities that contain related data for the same employee, which means you can use EGTs to maintain strong consistency.</span></span>
* <span data-ttu-id="3bcd8-681">Você deve considerar com que frequência consultará os dados para determinar se esse padrão é apropriado.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-681">You should consider how frequently you will query the data to determine whether this pattern is appropriate.</span></span>  <span data-ttu-id="3bcd8-682">Por exemplo, se você for acessar os dados de revisão com pouca frequência e os dados principais do funcionário com mais frequência, deve mantê-los como entidades separadas.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-682">For example, if you will access the review data infrequently and the main employee data often you should keep them as separate entities.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="3bcd8-683">Quando usar esse padrão</span><span class="sxs-lookup"><span data-stu-id="3bcd8-683">When to use this pattern</span></span>
<span data-ttu-id="3bcd8-684">Use esse padrão quando precisar armazenar uma ou mais entidades relacionadas que você consulta com frequência.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-684">Use this pattern when you need to store one or more related entities that you query frequently.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="3bcd8-685">Diretrizes e padrões relacionados</span><span class="sxs-lookup"><span data-stu-id="3bcd8-685">Related patterns and guidance</span></span>
<span data-ttu-id="3bcd8-686">Os padrões e diretrizes a seguir também podem ser relevantes ao implementar esse padrão:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-686">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="3bcd8-687">Transações do Grupo de Entidades</span><span class="sxs-lookup"><span data-stu-id="3bcd8-687">Entity Group Transactions</span></span>](#entity-group-transactions)  
* [<span data-ttu-id="3bcd8-688">Trabalhando com tipos de entidade heterogênea</span><span class="sxs-lookup"><span data-stu-id="3bcd8-688">Working with heterogeneous entity types</span></span>](#working-with-heterogeneous-entity-types)  
* [<span data-ttu-id="3bcd8-689">Padrão de transações eventualmente consistentes</span><span class="sxs-lookup"><span data-stu-id="3bcd8-689">Eventually consistent transactions pattern</span></span>](#eventually-consistent-transactions-pattern)  

### <a name="log-tail-pattern"></a><span data-ttu-id="3bcd8-690">Padrão de rastro do log</span><span class="sxs-lookup"><span data-stu-id="3bcd8-690">Log tail pattern</span></span>
<span data-ttu-id="3bcd8-691">Recupere as *n* entidades adicionadas mais recentemente a uma partição usando um valor de **RowKey** que classifica em ordem de data e hora inversa.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-691">Retrieve the *n* entities most recently added to a partition by using a **RowKey** value that sorts in reverse date and time order.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="3bcd8-692">Contexto e problema</span><span class="sxs-lookup"><span data-stu-id="3bcd8-692">Context and problem</span></span>
<span data-ttu-id="3bcd8-693">Um requisito comum é ser capaz de recuperar as entidades criadas mais recentemente, por exemplo, os dez reembolsos de despesa mais recentes enviados por um funcionário.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-693">A common requirement is be able to retrieve the most recently created entities, for example the ten most recent expense claims submitted by an employee.</span></span> <span data-ttu-id="3bcd8-694">As consultas de tabela dão suporte a uma operação de consulta **$top** para retornar as primeiras *n* entidades de um conjunto: não há nenhuma operação de consulta equivalente para retornar as últimas n entidades de um conjunto.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-694">Table queries support a **$top** query operation to return the first *n* entities from a set: there is no equivalent query operation to return the last n entities in a set.</span></span>  

#### <a name="solution"></a><span data-ttu-id="3bcd8-695">Solução</span><span class="sxs-lookup"><span data-stu-id="3bcd8-695">Solution</span></span>
<span data-ttu-id="3bcd8-696">Armazene as entidades usando uma **RowKey** que classifica naturalmente em ordem inversa de data/hora. Fazendo isso, a entrada mais recente será sempre a primeira na tabela.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-696">Store the entities using a **RowKey** that naturally sorts in reverse date/time order by using so the most recent entry is always the first one in the table.</span></span>  

<span data-ttu-id="3bcd8-697">Por exemplo, para recuperar os dez reembolsos de despesa mais recentes enviadas por um funcionário, você pode usar um valor de escala inversa derivado de data/hora atual.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-697">For example, to be able to retrieve the ten most recent expense claims submitted by an employee, you can use a reverse tick value derived from the current date/time.</span></span> <span data-ttu-id="3bcd8-698">O seguinte exemplo de código C# mostra uma maneira de criar um valor adequado de "escala invertida" para uma **RowKey** que classifica do mais recente ao mais antigo:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-698">The following C# code sample shows one way to create a suitable "inverted ticks" value for a **RowKey** that sorts from the most recent to the oldest:</span></span>  

`string invertedTicks = string.Format("{0:D19}", DateTime.MaxValue.Ticks - DateTime.UtcNow.Ticks);`  

<span data-ttu-id="3bcd8-699">Você pode retornar ao valor de data/hora usando o seguinte código:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-699">You can get back to the date time value using the following code:</span></span>  

`DateTime dt = new DateTime(DateTime.MaxValue.Ticks - Int64.Parse(invertedTicks));`  

<span data-ttu-id="3bcd8-700">A consulta a tabela tem esta aparência:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-700">The table query looks like this:</span></span>  

`https://myaccount.table.core.windows.net/EmployeeExpense(PartitionKey='empid')?$top=10`  

#### <a name="issues-and-considerations"></a><span data-ttu-id="3bcd8-701">Problemas e considerações</span><span class="sxs-lookup"><span data-stu-id="3bcd8-701">Issues and considerations</span></span>
<span data-ttu-id="3bcd8-702">Considere os seguintes pontos ao decidir como implementar esse padrão:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-702">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="3bcd8-703">Você precisa preencher o valor da escala invertida com zeros para garantir que o valor de cadeia de caracteres seja classificado conforme o esperado.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-703">You must pad the reverse tick value with leading zeroes to ensure the string value sorts as expected.</span></span>  
* <span data-ttu-id="3bcd8-704">Você deve estar ciente das metas de escalabilidade no nível de uma partição.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-704">You must be aware of the scalability targets at the level of a partition.</span></span> <span data-ttu-id="3bcd8-705">Cuidado não criar partições com ponto de acesso.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-705">Be careful not create hot spot partitions.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="3bcd8-706">Quando usar esse padrão</span><span class="sxs-lookup"><span data-stu-id="3bcd8-706">When to use this pattern</span></span>
<span data-ttu-id="3bcd8-707">Use esse padrão quando precisar acessar entidades na ordem inversa de data/hora ou quando precisar acessar entidades adicionadas mais recentemente.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-707">Use this pattern when you need to access entities in reverse date/time order or when you need to access the most recently added entities.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="3bcd8-708">Diretrizes e padrões relacionados</span><span class="sxs-lookup"><span data-stu-id="3bcd8-708">Related patterns and guidance</span></span>
<span data-ttu-id="3bcd8-709">Os padrões e diretrizes a seguir também podem ser relevantes ao implementar esse padrão:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-709">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="3bcd8-710">Antipadrão prefixar/acrescentar</span><span class="sxs-lookup"><span data-stu-id="3bcd8-710">Prepend / append anti-pattern</span></span>](#prepend-append-anti-pattern)  
* [<span data-ttu-id="3bcd8-711">Recuperando entidades</span><span class="sxs-lookup"><span data-stu-id="3bcd8-711">Retrieving entities</span></span>](#retrieving-entities)  

### <a name="high-volume-delete-pattern"></a><span data-ttu-id="3bcd8-712">Padrão de exclusão de alto volume</span><span class="sxs-lookup"><span data-stu-id="3bcd8-712">High volume delete pattern</span></span>
<span data-ttu-id="3bcd8-713">Habilite a exclusão de um alto volume de entidades armazenando todas as entidades para exclusão simultânea em suas próprias tabelas separadas; você exclui as entidades excluindo a tabela.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-713">Enable the deletion of a high volume of entities by storing all the entities for simultaneous deletion in their own separate table; you delete the entities by deleting the table.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="3bcd8-714">Contexto e problema</span><span class="sxs-lookup"><span data-stu-id="3bcd8-714">Context and problem</span></span>
<span data-ttu-id="3bcd8-715">Muitos aplicativos excluem dados antigos que não precisam mais estar disponíveis para um aplicativo cliente, ou que o aplicativo tenha arquivado em outro meio de armazenamento.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-715">Many applications delete old data which no longer needs to be available to a client application, or that the application has archived to another storage medium.</span></span> <span data-ttu-id="3bcd8-716">Você geralmente identifica esses dados por uma data: por exemplo, você tem um requisição para excluir registros de todas as solicitações de logon com mais de 60 dias.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-716">You typically identify such data by a date: for example, you have a requirement to delete records of all login requests that are more than 60 days old.</span></span>  

<span data-ttu-id="3bcd8-717">Um design possível é usar a data e a hora da solicitação de logon na **RowKey**:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-717">One possible design is to use the date and time of the login request in the **RowKey**:</span></span>  

![][21]

<span data-ttu-id="3bcd8-718">Essa abordagem evita sobrecargas de partição porque o aplicativo pode inserir e excluir entidades de logon para cada usuário em uma partição separada.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-718">This approach avoids partition hotspots because the application can insert and delete login entities for each user in a separate partition.</span></span> <span data-ttu-id="3bcd8-719">No entanto, essa abordagem pode ser cara e demorada se você tiver um grande número de entidades porque primeiro é necessário executar uma verificação de tabela para identificar todas as entidades a excluir e, em seguida, excluir todas as entidades antigas.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-719">However, this approach may be costly and time consuming if you have a large number of entities because first you need to perform a table scan in order to identify all the entities to delete, and then you must delete each old entity.</span></span> <span data-ttu-id="3bcd8-720">Observe que você pode reduzir o número de viagens de ida e volta ao servidor, necessário para excluir as entidades antigas por envio em lote de várias solicitações de exclusão para as EGTs.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-720">Note that you can reduce the number of round trips to the server required to delete the old entities by batching multiple delete requests into EGTs.</span></span>  

#### <a name="solution"></a><span data-ttu-id="3bcd8-721">Solução</span><span class="sxs-lookup"><span data-stu-id="3bcd8-721">Solution</span></span>
<span data-ttu-id="3bcd8-722">Use uma tabela separada para cada dia de tentativas de logon.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-722">Use a separate table for each day of login attempts.</span></span> <span data-ttu-id="3bcd8-723">Você pode usar o design de entidade acima para evitar pontos de acesso ao inserir entidades e excluir entidades antigas agora é simplesmente uma questão de excluir uma tabela a cada dia (uma única operação de armazenamento), em vez de localizar e excluir centenas de milhares de entidades de logon individuais todos os dias.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-723">You can use the entity design above to avoid hotspots when you are inserting entities, and deleting old entities is now simply a question of deleting one table every day (a single storage operation) instead of finding and deleting hundreds and thousands of individual login entities every day.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="3bcd8-724">Problemas e considerações</span><span class="sxs-lookup"><span data-stu-id="3bcd8-724">Issues and considerations</span></span>
<span data-ttu-id="3bcd8-725">Considere os seguintes pontos ao decidir como implementar esse padrão:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-725">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="3bcd8-726">Seu design dá suporte a outras formas de uso dos dados pelo aplicativo, como pesquisa em entidades específicas, vinculação com outros dados ou geração de informações agregadas?</span><span class="sxs-lookup"><span data-stu-id="3bcd8-726">Does your design support other ways your application will use the data such as looking up specific entities, linking with other data, or generating aggregate information?</span></span>  
* <span data-ttu-id="3bcd8-727">O design evita pontos de acesso quando você está inserindo novas entidades?</span><span class="sxs-lookup"><span data-stu-id="3bcd8-727">Does your design avoid hot spots when you are inserting new entities?</span></span>  
* <span data-ttu-id="3bcd8-728">Espere um atraso, se você quiser reutilizar o mesmo nome de tabela após a exclusão.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-728">Expect a delay if you want to reuse the same table name after deleting it.</span></span> <span data-ttu-id="3bcd8-729">É melhor sempre usar nomes de tabela exclusivos.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-729">It's better to always use unique table names.</span></span>  
* <span data-ttu-id="3bcd8-730">Espere alguns limitação quando você usar pela primeira vez uma nova tabela enquanto o serviço Tabela aprende os padrões de acesso e distribui as partições entre os nós.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-730">Expect some throttling when you first use a new table while the Table service learns the access patterns and distributes the partitions across nodes.</span></span> <span data-ttu-id="3bcd8-731">Você deve considerar com que frequência precisa criar novas tabelas.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-731">You should consider how frequently you need to create new tables.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="3bcd8-732">Quando usar esse padrão</span><span class="sxs-lookup"><span data-stu-id="3bcd8-732">When to use this pattern</span></span>
<span data-ttu-id="3bcd8-733">Use esse padrão quando tiver um alto volume de entidades que devem ser excluídas ao mesmo tempo.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-733">Use this pattern when you have a high volume of entities that you must delete at the same time.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="3bcd8-734">Diretrizes e padrões relacionados</span><span class="sxs-lookup"><span data-stu-id="3bcd8-734">Related patterns and guidance</span></span>
<span data-ttu-id="3bcd8-735">Os padrões e diretrizes a seguir também podem ser relevantes ao implementar esse padrão:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-735">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="3bcd8-736">Transações do Grupo de Entidades</span><span class="sxs-lookup"><span data-stu-id="3bcd8-736">Entity Group Transactions</span></span>](#entity-group-transactions)
* [<span data-ttu-id="3bcd8-737">Modificando entidades</span><span class="sxs-lookup"><span data-stu-id="3bcd8-737">Modifying entities</span></span>](#modifying-entities)  

### <a name="data-series-pattern"></a><span data-ttu-id="3bcd8-738">Padrão de série de dados</span><span class="sxs-lookup"><span data-stu-id="3bcd8-738">Data series pattern</span></span>
<span data-ttu-id="3bcd8-739">Armazene série de dados completa em uma única entidade para minimizar o número de solicitações que você faz.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-739">Store complete data series in a single entity to minimize the number of requests you make.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="3bcd8-740">Contexto e problema</span><span class="sxs-lookup"><span data-stu-id="3bcd8-740">Context and problem</span></span>
<span data-ttu-id="3bcd8-741">Um cenário comum é um aplicativo armazenar uma série de dados que ele normalmente precisa recuperar uma só vez.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-741">A common scenario is for an application to store a series of data that it typically needs to retrieve all at once.</span></span> <span data-ttu-id="3bcd8-742">Por exemplo, seu aplicativo pode registrar a quantidade de mensagens instantâneas que cada funcionário envia por hora e usar essas informações para avaliar quantas mensagens cada usuário enviou nas 24 horas anteriores.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-742">For example, your application might record how many IM messages each employee sends every hour, and then use this information to plot how many messages each user sent over the preceding 24 hours.</span></span> <span data-ttu-id="3bcd8-743">Um design pode ser armazenar 24 entidades para cada funcionário:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-743">One design might be to store 24 entities for each employee:</span></span>  

![][22]

<span data-ttu-id="3bcd8-744">Com esse design, você pode facilmente localizar e atualizar a entidade a ser atualizada para cada funcionário sempre que o aplicativo precisar atualizar o valor de contagem das mensagem.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-744">With this design, you can easily locate and update the entity to update for each employee whenever the application needs to update the message count value.</span></span> <span data-ttu-id="3bcd8-745">No entanto, para recuperar as informações e traçar um gráfico de atividades das 24 horas anteriores, você deve recuperar 24 entidades.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-745">However, to retrieve the information to plot a chart of the activity for the preceding 24 hours, you must retrieve 24 entities.</span></span>  

#### <a name="solution"></a><span data-ttu-id="3bcd8-746">Solução</span><span class="sxs-lookup"><span data-stu-id="3bcd8-746">Solution</span></span>
<span data-ttu-id="3bcd8-747">Use o design a seguir com uma propriedade separada para armazenar a contagem de mensagens para cada hora:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-747">Use the following design with a separate property to store the message count for each hour:</span></span>  

![][23]

<span data-ttu-id="3bcd8-748">Com esse design, você pode usar uma operação de mesclagem para atualizar a contagem de mensagens de um funcionário, em uma hora específica.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-748">With this design, you can use a merge operation to update the message count for an employee for a specific hour.</span></span> <span data-ttu-id="3bcd8-749">Agora, você pode recuperar todas as informações necessárias traçar o gráfico usando uma solicitação para uma única entidade.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-749">Now, you can retrieve all the information you need to plot the chart using a request for a single entity.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="3bcd8-750">Problemas e considerações</span><span class="sxs-lookup"><span data-stu-id="3bcd8-750">Issues and considerations</span></span>
<span data-ttu-id="3bcd8-751">Considere os seguintes pontos ao decidir como implementar esse padrão:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-751">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="3bcd8-752">Se a sua série de dados completa não couber em uma única entidade (uma entidade pode ter até 252 propriedades), use um repositório de dados alternativo, como um blob.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-752">If your complete data series does not fit into a single entity (an entity can have up to 252 properties), use an alternative data store such as a blob.</span></span>  
* <span data-ttu-id="3bcd8-753">Caso você tenha vários clientes atualizando uma entidade simultaneamente, será necessário usar o **Etag** para implementar a simultaneidade otimista.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-753">If you have multiple clients updating an entity simultaneously, you will need to use the **ETag** to implement optimistic concurrency.</span></span> <span data-ttu-id="3bcd8-754">Se você tiver muitos clientes, poderá enfrentar alta contenção.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-754">If you have many clients, you may experience high contention.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="3bcd8-755">Quando usar esse padrão</span><span class="sxs-lookup"><span data-stu-id="3bcd8-755">When to use this pattern</span></span>
<span data-ttu-id="3bcd8-756">Use esse padrão quando precisar atualizar e recuperar uma série de dados associados a uma entidade individual.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-756">Use this pattern when you need to update and retrieve a data series associated with an individual entity.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="3bcd8-757">Diretrizes e padrões relacionados</span><span class="sxs-lookup"><span data-stu-id="3bcd8-757">Related patterns and guidance</span></span>
<span data-ttu-id="3bcd8-758">Os padrões e diretrizes a seguir também podem ser relevantes ao implementar esse padrão:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-758">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="3bcd8-759">Padrão de grandes entidades</span><span class="sxs-lookup"><span data-stu-id="3bcd8-759">Large entities pattern</span></span>](#large-entities-pattern)  
* [<span data-ttu-id="3bcd8-760">Mesclar ou substituir</span><span class="sxs-lookup"><span data-stu-id="3bcd8-760">Merge or replace</span></span>](#merge-or-replace)  
* <span data-ttu-id="3bcd8-761">[Padrão de transações eventualmente consistentes](#eventually-consistent-transactions-pattern) (se você estiver armazenando a série de dados em um blob)</span><span class="sxs-lookup"><span data-stu-id="3bcd8-761">[Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern) (if you are storing the data series in a blob)</span></span>  

### <a name="wide-entities-pattern"></a><span data-ttu-id="3bcd8-762">Padrão de entidades longas</span><span class="sxs-lookup"><span data-stu-id="3bcd8-762">Wide entities pattern</span></span>
<span data-ttu-id="3bcd8-763">Use várias entidades físicas para armazenar entidades lógicas com mais de 252 propriedades.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-763">Use multiple physical entities to store logical entities with more than 252 properties.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="3bcd8-764">Contexto e problema</span><span class="sxs-lookup"><span data-stu-id="3bcd8-764">Context and problem</span></span>
<span data-ttu-id="3bcd8-765">Uma entidade individual pode ter no máximo 252 propriedades (exceto as propriedades de sistema obrigatórias) e não pode armazenar mais de 1 MB de dados no total.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-765">An individual entity can have no more than 252 properties (excluding the mandatory system properties) and cannot store more than 1 MB of data in total.</span></span> <span data-ttu-id="3bcd8-766">Em um banco de dados relacional, você normalmente contornaria os limites de tamanho de uma linha adicionando uma nova tabela e impondo uma relação de 1 para 1 entre elas.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-766">In a relational database, you would typically get round any limits on the size of a row by adding a new table and enforcing a 1-to-1 relationship between them.</span></span>  

#### <a name="solution"></a><span data-ttu-id="3bcd8-767">Solução</span><span class="sxs-lookup"><span data-stu-id="3bcd8-767">Solution</span></span>
<span data-ttu-id="3bcd8-768">Usando o serviço Tabela, você pode armazenar várias entidades para representar um único objeto grande de negócios com mais de 252 propriedades.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-768">Using the Table service, you can store multiple entities to represent a single large business object with more than 252 properties.</span></span> <span data-ttu-id="3bcd8-769">Por exemplo, para armazenar uma contagem do número de mensagens instantâneas enviadas por cada funcionário nos últimos 365 dias, você poderia usar o design a seguir que usa duas entidades com diferentes esquemas:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-769">For example, if you want to store a count of the number of IM messages sent by each employee for the last 365 days, you could use the following design that uses two entities with different schemas:</span></span>  

![][24]

<span data-ttu-id="3bcd8-770">Se você precisar fazer uma alteração que requer a atualização de ambas as entidades para mantê-las sincronizadas entre si, pode usar uma EGT.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-770">If you need to make a change that requires updating both entities to keep them synchronized with each other you can use an EGT.</span></span> <span data-ttu-id="3bcd8-771">Caso contrário, você pode usar uma operação de mesclagem única para atualizar a contagem de mensagens de um dia específico.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-771">Otherwise, you can use a single merge operation to update the message count for a specific day.</span></span> <span data-ttu-id="3bcd8-772">Para recuperar todos os dados de um funcionário individual, você deverá recuperar as duas entidades, o que pode ser feito com duas solicitações eficientes que usam um valor de **PartitionKey** e um de **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-772">To retrieve all the data for an individual employee you must retrieve both entities, which you can do with two efficient requests that use both a **PartitionKey** and a **RowKey** value.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="3bcd8-773">Problemas e considerações</span><span class="sxs-lookup"><span data-stu-id="3bcd8-773">Issues and considerations</span></span>
<span data-ttu-id="3bcd8-774">Considere os seguintes pontos ao decidir como implementar esse padrão:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-774">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="3bcd8-775">A recuperação de uma entidade lógica completa envolve pelo menos duas transações de armazenamento: uma para recuperar cada entidade física.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-775">Retrieving a complete logical entity involves at least two storage transactions: one to retrieve each physical entity.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="3bcd8-776">Quando usar esse padrão</span><span class="sxs-lookup"><span data-stu-id="3bcd8-776">When to use this pattern</span></span>
<span data-ttu-id="3bcd8-777">Use esse padrão quando precisar armazenar entidades cujo tamanho ou número de propriedades excede os limites de uma entidade individual no serviço Tabela.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-777">Use this pattern when  need to store entities whose size or number of properties exceeds the limits for an individual entity in the Table service.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="3bcd8-778">Diretrizes e padrões relacionados</span><span class="sxs-lookup"><span data-stu-id="3bcd8-778">Related patterns and guidance</span></span>
<span data-ttu-id="3bcd8-779">Os padrões e diretrizes a seguir também podem ser relevantes ao implementar esse padrão:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-779">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="3bcd8-780">Transações do Grupo de Entidades</span><span class="sxs-lookup"><span data-stu-id="3bcd8-780">Entity Group Transactions</span></span>](#entity-group-transactions)
* [<span data-ttu-id="3bcd8-781">Mesclar ou substituir</span><span class="sxs-lookup"><span data-stu-id="3bcd8-781">Merge or replace</span></span>](#merge-or-replace)

### <a name="large-entities-pattern"></a><span data-ttu-id="3bcd8-782">Padrão de entidades grandes</span><span class="sxs-lookup"><span data-stu-id="3bcd8-782">Large entities pattern</span></span>
<span data-ttu-id="3bcd8-783">Use armazenamento de blobs para armazenar grandes valores de propriedade.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-783">Use blob storage to store large property values.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="3bcd8-784">Contexto e problema</span><span class="sxs-lookup"><span data-stu-id="3bcd8-784">Context and problem</span></span>
<span data-ttu-id="3bcd8-785">Uma entidade individual não pode armazenar mais de 1 MB de dados no total.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-785">An individual entity cannot store more than 1 MB of data in total.</span></span> <span data-ttu-id="3bcd8-786">Se uma ou várias de suas propriedades armazenam valores que fazem com que o tamanho total da entidade exceda esse valor, você não pode armazenar a entidade inteira no serviço Tabela.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-786">If one or several of your properties store values that cause the total size of your entity to exceed this value, you cannot store the entire entity in the Table service.</span></span>  

#### <a name="solution"></a><span data-ttu-id="3bcd8-787">Solução</span><span class="sxs-lookup"><span data-stu-id="3bcd8-787">Solution</span></span>
<span data-ttu-id="3bcd8-788">Se a entidade exceder 1 MB de tamanho porque uma ou mais propriedades contêm uma grande quantidade de dados, você poderá armazenar dados no serviço Blob e, em seguida, armazenar o endereço do blob em uma propriedade na entidade.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-788">If your entity exceeds 1 MB in size because one or more properties contain a large amount of data, you can store data in the Blob service and then store the address of the blob in a property in the entity.</span></span> <span data-ttu-id="3bcd8-789">Por exemplo, você pode armazenar a foto de um funcionário no armazenamento de blobs e armazenar um link para a foto na propriedade **Foto** da entidade funcionário:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-789">For example, you can store the photo of an employee in blob storage and store a link to the photo in the **Photo** property of your employee entity:</span></span>  

![][25]

#### <a name="issues-and-considerations"></a><span data-ttu-id="3bcd8-790">Problemas e considerações</span><span class="sxs-lookup"><span data-stu-id="3bcd8-790">Issues and considerations</span></span>
<span data-ttu-id="3bcd8-791">Considere os seguintes pontos ao decidir como implementar esse padrão:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-791">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="3bcd8-792">Para manter a consistência eventual entre a entidade do serviço Tabela e os dados no serviço Blob, use o [Padrão de transações eventualmente consistentes](#eventually-consistent-transactions-pattern) para manter suas entidades.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-792">To maintain eventual consistency between the entity in the Table service and the data in the Blob service, use the [Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern) to maintain your entities.</span></span>
* <span data-ttu-id="3bcd8-793">A recuperação de uma entidade completa envolve pelo menos duas transações de armazenamento: uma para recuperar a entidade e outra para recuperar os dados do blob.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-793">Retrieving a complete entity involves at least two storage transactions: one to retrieve the entity and one to retrieve the blob data.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="3bcd8-794">Quando usar esse padrão</span><span class="sxs-lookup"><span data-stu-id="3bcd8-794">When to use this pattern</span></span>
<span data-ttu-id="3bcd8-795">Use esse padrão quando precisar armazenar entidades cujo tamanho excede os limites de uma entidade individual no serviço Tabela.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-795">Use this pattern when you need to store entities whose size exceeds the limits for an individual entity in the Table service.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="3bcd8-796">Diretrizes e padrões relacionados</span><span class="sxs-lookup"><span data-stu-id="3bcd8-796">Related patterns and guidance</span></span>
<span data-ttu-id="3bcd8-797">Os padrões e diretrizes a seguir também podem ser relevantes ao implementar esse padrão:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-797">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="3bcd8-798">Padrão de transações eventualmente consistentes</span><span class="sxs-lookup"><span data-stu-id="3bcd8-798">Eventually consistent transactions pattern</span></span>](#eventually-consistent-transactions-pattern)  
* [<span data-ttu-id="3bcd8-799">Padrão de entidades longas</span><span class="sxs-lookup"><span data-stu-id="3bcd8-799">Wide entities pattern</span></span>](#wide-entities-pattern)

<a name="prepend-append-anti-pattern"></a>

### <a name="prependappend-anti-pattern"></a><span data-ttu-id="3bcd8-800">Antipadrão prefixar/acrescentar</span><span class="sxs-lookup"><span data-stu-id="3bcd8-800">Prepend/append anti-pattern</span></span>
<span data-ttu-id="3bcd8-801">Aumente a escalabilidade quando tiver um alto volume de inserções, distribuindo as inserções em várias partições.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-801">Increase scalability when you have a high volume of inserts by spreading the inserts across multiple partitions.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="3bcd8-802">Contexto e problema</span><span class="sxs-lookup"><span data-stu-id="3bcd8-802">Context and problem</span></span>
<span data-ttu-id="3bcd8-803">A prefixação ou o acréscimo de entidades às suas entidades armazenadas normalmente fazem com que o aplicativo adicione novas entidades à primeira ou última partição de uma sequência de partições.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-803">Prepending or appending entities to your stored entities typically results in the application adding new entities to the first or last partition of a sequence of partitions.</span></span> <span data-ttu-id="3bcd8-804">Nesse caso, todas as inserções em um determinado momento estão ocorrendo na mesma partição, criando um ponto de acesso que impede o serviço Tabela de carregar inserções de balanceamento em vários nós e possivelmente fazendo com que o aplicativo atinja as metas de escalabilidade para partição.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-804">In this case, all of the inserts at any given time are taking place in the same partition, creating a hotspot that prevents the table service from load balancing inserts across multiple nodes, and possibly causing your application to hit the scalability targets for partition.</span></span> <span data-ttu-id="3bcd8-805">Por exemplo, se você tiver um aplicativo que registre acesso a rede e recursos por funcionários, então uma estrutura de entidade, conforme mostrado a seguir, poderá fazer com que a partição de hora atual se transforme em um ponto de acesso, caso o volume de transações atinja a meta de escalabilidade de uma partição individual:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-805">For example, if you have an application that logs network and resource access by employees, then an entity structure as shown below could result in the current hour's partition becoming a hotspot if the volume of transactions reaches the scalability target for an individual partition:</span></span>  

![][26]

#### <a name="solution"></a><span data-ttu-id="3bcd8-806">Solução</span><span class="sxs-lookup"><span data-stu-id="3bcd8-806">Solution</span></span>
<span data-ttu-id="3bcd8-807">A seguinte estrutura de entidade alternativa evita um ponto de acesso em qualquer partição específica quando o aplicativo registra eventos:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-807">The following alternative entity structure avoids a hotspot on any particular partition as the application logs events:</span></span>  

![][27]

<span data-ttu-id="3bcd8-808">Observe com este exemplo como **PartitionKey** e **RowKey** são chaves compostas.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-808">Notice with this example how both the **PartitionKey** and **RowKey** are compound keys.</span></span> <span data-ttu-id="3bcd8-809">A **PartitionKey** usa a ID de funcionário e departamento para distribuir o registro em log entre várias partições.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-809">The **PartitionKey** uses both the department and employee id to distribute the logging across multiple partitions.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="3bcd8-810">Problemas e considerações</span><span class="sxs-lookup"><span data-stu-id="3bcd8-810">Issues and considerations</span></span>
<span data-ttu-id="3bcd8-811">Considere os seguintes pontos ao decidir como implementar esse padrão:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-811">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="3bcd8-812">A estrutura de chave alternativa que evita a criação de partições ativas em inserções dá suporte eficiente a consultas que o aplicativo cliente faz?</span><span class="sxs-lookup"><span data-stu-id="3bcd8-812">Does the alternative key structure that avoids creating hot partitions on inserts efficiently support the queries your client application makes?</span></span>  
* <span data-ttu-id="3bcd8-813">O volume antecipado de transações significa que você tem probabilidade de atingir as metas de escalabilidade para uma partição individual e ser limitado pelo serviço de armazenamento?</span><span class="sxs-lookup"><span data-stu-id="3bcd8-813">Does your anticipated volume of transactions mean that you are likely to reach the scalability targets for an individual partition and be throttled by the storage service?</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="3bcd8-814">Quando usar esse padrão</span><span class="sxs-lookup"><span data-stu-id="3bcd8-814">When to use this pattern</span></span>
<span data-ttu-id="3bcd8-815">Evite o antipadrão prefixar/acrescentar quando o volume de transações tenha a probabilidade de resultar em limitação pelo serviço de armazenamento quando você acessar uma partição ativa.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-815">Avoid the prepend/append anti-pattern when your volume of transactions is likely to result in throttling by the storage service when you access a hot partition.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="3bcd8-816">Diretrizes e padrões relacionados</span><span class="sxs-lookup"><span data-stu-id="3bcd8-816">Related patterns and guidance</span></span>
<span data-ttu-id="3bcd8-817">Os padrões e diretrizes a seguir também podem ser relevantes ao implementar esse padrão:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-817">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="3bcd8-818">Padrão de chave composta</span><span class="sxs-lookup"><span data-stu-id="3bcd8-818">Compound key pattern</span></span>](#compound-key-pattern)  
* [<span data-ttu-id="3bcd8-819">Padrão de final do log</span><span class="sxs-lookup"><span data-stu-id="3bcd8-819">Log tail pattern</span></span>](#log-tail-pattern)  
* [<span data-ttu-id="3bcd8-820">Modificando entidades</span><span class="sxs-lookup"><span data-stu-id="3bcd8-820">Modifying entities</span></span>](#modifying-entities)  

### <a name="log-data-anti-pattern"></a><span data-ttu-id="3bcd8-821">Antipadrão de dados de log</span><span class="sxs-lookup"><span data-stu-id="3bcd8-821">Log data anti-pattern</span></span>
<span data-ttu-id="3bcd8-822">Normalmente, você deveria usar o serviço Blob em vez do serviço Tabela para armazenar dados de log.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-822">Typically, you should use the Blob service instead of the Table service to store log data.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="3bcd8-823">Contexto e problema</span><span class="sxs-lookup"><span data-stu-id="3bcd8-823">Context and problem</span></span>
<span data-ttu-id="3bcd8-824">Um caso de uso comum de dados de log é recuperar uma seleção de entradas de log para um intervalo de data/hora específico: por exemplo, você deseja localizar todos os erros e mensagens críticas que seu aplicativo registrou entre 15:04 e 15:06 em uma data específica.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-824">A common use case for log data is to retrieve a selection of log entries for a specific date/time range: for example, you want to find all the error and critical messages that your application logged between 15:04 and 15:06 on a specific date.</span></span> <span data-ttu-id="3bcd8-825">Você não deseja usar a data e hora da mensagem de log para determinar a partição em que você salvou as entidades de log: isso resulta em uma partição ativa porque, a qualquer momento, todas as entidades de log compartilharão o mesmo valor **PartitionKey** (confira a seção [Antipadrão de prefixação/acréscimo](#prepend-append-anti-pattern)).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-825">You do not want to use the date and time of the log message to determine the partition you save log entities to: that results in a hot partition because at any given time, all the log entities will share the same **PartitionKey** value (see the section [Prepend/append anti-pattern](#prepend-append-anti-pattern)).</span></span> <span data-ttu-id="3bcd8-826">Por exemplo, o seguinte esquema de entidade para uma mensagem de log resulta em uma partição ativa porque o aplicativo grava todas as mensagens de log na partição para a data e hora atual:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-826">For example, the following entity schema for a log message results in a hot partition because the application writes all log messages to the partition for the current date and hour:</span></span>  

![][28]

<span data-ttu-id="3bcd8-827">Neste exemplo, a **RowKey** inclui a data e hora da mensagem de log para garantir que as mensagens de log sejam armazenadas classificadas em ordem de data/hora; inclui também uma ID de mensagem, caso várias mensagens de log compartilhem a mesma data e hora.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-827">In this example, the **RowKey** includes the date and time of the log message to ensure that log messages are stored sorted in date/time order, and includes a message id in case multiple log messages share the same date and time.</span></span>  

<span data-ttu-id="3bcd8-828">Outra abordagem é usar uma **PartitionKey** que garanta que o aplicativo grave mensagens em uma variedade de partições.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-828">Another approach is to use a **PartitionKey** that ensures that the application writes messages across a range of partitions.</span></span> <span data-ttu-id="3bcd8-829">Por exemplo, se a origem da mensagem de log fornecer uma maneira de distribuir mensagens através de várias partições, você pode usar o seguinte esquema de entidade:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-829">For example, if the source of the log message provides a way to distribute messages across many partitions, you could use the following entity schema:</span></span>  

![][29]

<span data-ttu-id="3bcd8-830">No entanto, o problema com esse esquema é que para recuperar todas as mensagens de log para um período de tempo específico você deve pesquisar cada partição na tabela.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-830">However, the problem with this schema is that to retrieve all the log messages for a specific time span you must search every partition in the table.</span></span>

#### <a name="solution"></a><span data-ttu-id="3bcd8-831">Solução</span><span class="sxs-lookup"><span data-stu-id="3bcd8-831">Solution</span></span>
<span data-ttu-id="3bcd8-832">A seção anterior realçou o problema de uma tentativa de usar o serviço Tabela para armazenar entradas de log e sugeriu dois designs insatisfatórios.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-832">The previous section highlighted the problem of trying to use the Table service to store log entries and suggested two, unsatisfactory, designs.</span></span> <span data-ttu-id="3bcd8-833">Uma solução resultou em uma partição ativa com o risco de mau desempenho ao gravar mensagens de log; a outra solução resultou em mau desempenho de consulta por causa do requisito de verificar cada partição da tabela para recuperar mensagens de log de um período específico.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-833">One solution led to a hot partition with the risk of poor performance writing log messages; the other solution resulted in poor query performance because of the requirement to scan every partition in the table to retrieve log messages for a specific time span.</span></span> <span data-ttu-id="3bcd8-834">O Armazenamento de blob oferece uma solução melhor para esse tipo de cenário e é assim que o Azure Storage Analytics armazena os dados de log que coleta.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-834">Blob storage offers a better solution for this type of scenario and this is how Azure Storage Analytics stores the log data it collects.</span></span>  

<span data-ttu-id="3bcd8-835">Esta seção descreve como o Storage Analytics armazena dados de log no armazenamento de blobs como uma ilustração dessa abordagem de armazenamento de dados que você normalmente consulta por intervalo.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-835">This section outlines how Storage Analytics stores log data in blob storage as an illustration of this approach to storing data that you typically query by range.</span></span>  

<span data-ttu-id="3bcd8-836">O Storage Analytics armazena mensagens de log em um formato delimitado em vários blobs.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-836">Storage Analytics stores log messages in a delimited format in multiple blobs.</span></span> <span data-ttu-id="3bcd8-837">O formato delimitado facilita para um aplicativo cliente analisar os dados na mensagem de log.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-837">The delimited format makes it easy for a client application to parse the data in the log message.</span></span>  

<span data-ttu-id="3bcd8-838">O Storage Analytics usa uma convenção de nomenclatura para blobs que permite que você localize o blob (ou blobs) que contêm as mensagens de log que você está pesquisando.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-838">Storage Analytics uses a naming convention for blobs that enables you to locate the blob (or blobs) that contain the log messages for which you are searching.</span></span> <span data-ttu-id="3bcd8-839">Por exemplo, um blob denominado "queue/2014/07/31/1800/000001.log" contém mensagens de log que se relacionam com o serviço Fila para a hora de início às 18:00 em 31 de julho de 2014.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-839">For example, a blob named "queue/2014/07/31/1800/000001.log" contains log messages that relate to the queue service for the hour starting at 18:00 on 31 July 2014.</span></span> <span data-ttu-id="3bcd8-840">"000001" indica que este é o primeiro arquivo de log para esse período.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-840">The "000001" indicates that this is the first log file for this period.</span></span> <span data-ttu-id="3bcd8-841">O Storage Analytics também registra carimbos de data/hora das últimas e primeiras mensagens de log armazenadas no arquivo como parte dos metadados do blob.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-841">Storage Analytics also records the timestamps of the first and last log messages stored in the file as part of the blob's metadata.</span></span> <span data-ttu-id="3bcd8-842">A API do armazenamento ativo permite localizar blobs em um contêiner com base em um prefixo de nome: para localizar todos os blobs que contêm dados de log na fila para o horário com início às 18:00, você pode usar o prefixo "queue/2014/07/31/1800."</span><span class="sxs-lookup"><span data-stu-id="3bcd8-842">The API for blob storage enables you locate blobs in a container based on a name prefix: to locate all the blobs that contain queue log data for the hour starting at 18:00, you can use the prefix "queue/2014/07/31/1800."</span></span>  

<span data-ttu-id="3bcd8-843">O Storage Analytics armazena em buffer as mensagens de log internamente, e periodicamente atualiza o blob apropriado ou cria um novo com o último lote de entradas de log.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-843">Storage Analytics buffers log messages internally and then periodically updates the appropriate blob or creates a new one with the latest batch of log entries.</span></span> <span data-ttu-id="3bcd8-844">Isso reduz o número de gravações que ele deve realizar para o serviço Blob.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-844">This reduces the number of writes it must perform to the blob service.</span></span>  

<span data-ttu-id="3bcd8-845">Se você estiver implementando uma solução semelhante em seu próprio aplicativo, deve considerar como gerenciar a compensação entre a confiabilidade (gravar todas as entradas de log no armazenamento de blobs à medida que ocorre) e o custo e a escalabilidade (armazenar as atualizações em buffer em seu aplicativo e gravá-las no armazenamento de blobs em lotes).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-845">If you are implementing a similar solution in your own application, you must consider how to manage the trade-off between reliability (writing every log entry to blob storage as it happens) and cost and scalability (buffering updates in your application and writing them to blob storage in batches).</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="3bcd8-846">Problemas e considerações</span><span class="sxs-lookup"><span data-stu-id="3bcd8-846">Issues and considerations</span></span>
<span data-ttu-id="3bcd8-847">Considere os seguintes pontos ao decidir como armazenar dados de log:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-847">Consider the following points when deciding how to store log data:</span></span>  

* <span data-ttu-id="3bcd8-848">Se você criar um design de tabela que evita potenciais partições ativas, verá que não pode acessar os dados do log com eficiência.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-848">If you create a table design that avoids potential hot partitions, you may find that you cannot access your log data efficiently.</span></span>  
* <span data-ttu-id="3bcd8-849">Para processar dados de log, um cliente normalmente precisa carregar vários registros.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-849">To process log data, a client often needs to load many records.</span></span>  
* <span data-ttu-id="3bcd8-850">Embora os dados de log sejam geralmente estruturados, o armazenamento de blobs pode ser uma solução melhor.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-850">Although log data is often structured, blob storage may be a better solution.</span></span>  

### <a name="implementation-considerations"></a><span data-ttu-id="3bcd8-851">Considerações sobre a implementação</span><span class="sxs-lookup"><span data-stu-id="3bcd8-851">Implementation considerations</span></span>
<span data-ttu-id="3bcd8-852">Esta seção discute algumas das considerações a serem lembradas ao implementar os padrões descritos nas seções anteriores.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-852">This section discusses some of the considerations to bear in mind when you implement the patterns described in the previous sections.</span></span> <span data-ttu-id="3bcd8-853">Grande parte dessa seção usa exemplos escritos em c# que usam a Biblioteca de Cliente de Armazenamento (versão 4.3.0 no momento da redação).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-853">Most of this section uses examples written in C# that use the Storage Client Library (version 4.3.0 at the time of writing).</span></span>  

### <a name="retrieving-entities"></a><span data-ttu-id="3bcd8-854">Recuperando entidades</span><span class="sxs-lookup"><span data-stu-id="3bcd8-854">Retrieving entities</span></span>
<span data-ttu-id="3bcd8-855">Conforme discutido na seção [Design para consulta](#design-for-querying), a consulta mais eficiente é uma consulta de ponto.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-855">As discussed in the section [Design for querying](#design-for-querying), the most efficient query is a point query.</span></span> <span data-ttu-id="3bcd8-856">Entretanto, em alguns cenários talvez seja necessário recuperar várias entidades.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-856">However, in some scenarios you may need to retrieve multiple entities.</span></span> <span data-ttu-id="3bcd8-857">Esta seção descreve algumas abordagens comuns para recuperar entidades usando a Biblioteca de Cliente de Armazenamento.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-857">This section describes some common approaches to retrieving entities using the Storage Client Library.</span></span>  

#### <a name="executing-a-point-query-using-the-storage-client-library"></a><span data-ttu-id="3bcd8-858">Executando uma consulta de ponto usando a Biblioteca de Cliente de Armazenamento</span><span class="sxs-lookup"><span data-stu-id="3bcd8-858">Executing a point query using the Storage Client Library</span></span>
<span data-ttu-id="3bcd8-859">A maneira mais fácil de executar uma consulta de ponto é usar a operação da tabela **Recuperar**, conforme mostrado no trecho de código de C# a seguir, que recupera uma entidade com uma **PartitionKey** de valor "Vendas" e uma **RowKey** de valor "212":</span><span class="sxs-lookup"><span data-stu-id="3bcd8-859">The easiest way to execute a point query is to use the **Retrieve** table operation as shown in the following C# code snippet that retrieves an entity with a **PartitionKey** of value "Sales" and a **RowKey** of value "212":</span></span>  

```csharp
TableOperation retrieveOperation = TableOperation.Retrieve<EmployeeEntity>("Sales", "212");
var retrieveResult = employeeTable.Execute(retrieveOperation);
if (retrieveResult.Result != null)
{
    EmployeeEntity employee = (EmployeeEntity)retrieveResult.Result;
    ...
}  
```

<span data-ttu-id="3bcd8-860">Observe como esse exemplo espera que a entidade recuperada seja do tipo **EmployeeEntity**.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-860">Notice how this example expects the entity it retrieves to be of type **EmployeeEntity**.</span></span>  

#### <a name="retrieving-multiple-entities-using-linq"></a><span data-ttu-id="3bcd8-861">Recuperando várias entidades usando LINQ</span><span class="sxs-lookup"><span data-stu-id="3bcd8-861">Retrieving multiple entities using LINQ</span></span>
<span data-ttu-id="3bcd8-862">Você pode recuperar várias entidades usando LINQ com a Biblioteca de cliente de armazenamento e especificando uma consulta com uma cláusula **where** .</span><span class="sxs-lookup"><span data-stu-id="3bcd8-862">You can retrieve multiple entities by using LINQ with Storage Client Library and specifying a query with a **where** clause.</span></span> <span data-ttu-id="3bcd8-863">Para evitar uma verificação de tabela, você sempre deve incluir o valor de **PartitionKey** na cláusula where e, se possível, o valor de **RowKey** para evitar verificações de tabela e de partição.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-863">To avoid a table scan, you should always include the **PartitionKey** value in the where clause, and if possible the **RowKey** value to avoid table and partition scans.</span></span> <span data-ttu-id="3bcd8-864">O serviço Tabela dá suporte a um conjunto limitado de operadores de comparação (maior que, maior que ou igual a, menor que, menor que ou igual a, igual a, e diferente de) para usar na cláusula where.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-864">The table service supports a limited set of comparison operators (greater than, greater than or equal, less than, less than or equal, equal, and not equal) to use in the where clause.</span></span> <span data-ttu-id="3bcd8-865">O seguinte trecho de código em C# localiza todos os funcionários cujo sobrenome começa com "B" (supondo que **RowKey** armazena o sobrenome) no departamento de vendas (supondo que **PartitionKey** armazena o nome do departamento):</span><span class="sxs-lookup"><span data-stu-id="3bcd8-865">The following C# code snippet finds all the employees whose last name starts with "B" (assuming that the **RowKey** stores the last name) in the sales department (assuming the **PartitionKey** stores the department name):</span></span>  

```csharp
TableQuery<EmployeeEntity> employeeQuery = employeeTable.CreateQuery<EmployeeEntity>();
var query = (from employee in employeeQuery
            where employee.PartitionKey == "Sales" &&
            employee.RowKey.CompareTo("B") >= 0 &&
            employee.RowKey.CompareTo("C") < 0
            select employee).AsTableQuery();
var employees = query.Execute();  
```

<span data-ttu-id="3bcd8-866">Observe como a consulta especifica uma **RowKey** e também uma **PartitionKey** para garantir um melhor desempenho.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-866">Notice how the query specifies both a **RowKey** and a **PartitionKey** to ensure better performance.</span></span>  

<span data-ttu-id="3bcd8-867">O exemplo de código a seguir mostra a funcionalidade equivalente usando a API fluente (para saber mais sobre APIs fluentes em geral, confira [Práticas recomendadas para a criação de uma API fluente](http://visualstudiomagazine.com/articles/2013/12/01/best-practices-for-designing-a-fluent-api.aspx)):</span><span class="sxs-lookup"><span data-stu-id="3bcd8-867">The following code sample shows equivalent functionality using the fluent API (for more information about fluent APIs in general, see [Best Practices for Designing a Fluent API](http://visualstudiomagazine.com/articles/2013/12/01/best-practices-for-designing-a-fluent-api.aspx)):</span></span>  

```csharp
TableQuery<EmployeeEntity> employeeQuery = new TableQuery<EmployeeEntity>().Where(
    TableQuery.CombineFilters(
    TableQuery.CombineFilters(
        TableQuery.GenerateFilterCondition(
    "PartitionKey", QueryComparisons.Equal, "Sales"),
    TableOperators.And,
    TableQuery.GenerateFilterCondition(
    "RowKey", QueryComparisons.GreaterThanOrEqual, "B")
),
TableOperators.And,
TableQuery.GenerateFilterCondition("RowKey", QueryComparisons.LessThan, "C")
    )
);
var employees = employeeTable.ExecuteQuery(employeeQuery);  
```

> [!NOTE]
> <span data-ttu-id="3bcd8-868">O exemplo aninha vários métodos **CombineFilters** para incluir as três condições de filtro.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-868">The sample nests multiple **CombineFilters** methods to include the three filter conditions.</span></span>  
> 
> 

#### <a name="retrieving-large-numbers-of-entities-from-a-query"></a><span data-ttu-id="3bcd8-869">Recuperando grande número de entidades de uma consulta</span><span class="sxs-lookup"><span data-stu-id="3bcd8-869">Retrieving large numbers of entities from a query</span></span>
<span data-ttu-id="3bcd8-870">Uma consulta ideal retorna uma entidade individual com base em um valor de **PartitionKey** e um valor de **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-870">An optimal query returns an individual entity based on a **PartitionKey** value and a **RowKey** value.</span></span> <span data-ttu-id="3bcd8-871">No entanto, em alguns cenários, você pode precisar retornar muitas entidades da mesma partição ou até mesmo de várias partições.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-871">However, in some scenarios you may have a requirement to return many entities from the same partition or even from many partitions.</span></span>  

<span data-ttu-id="3bcd8-872">Você deve sempre testar totalmente o desempenho do seu aplicativo nesses cenários.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-872">You should always fully test the performance of your application in such scenarios.</span></span>  

<span data-ttu-id="3bcd8-873">Uma consulta no serviço Tabela pode retornar um máximo de 1.000 entidades de uma só vez e ser executada por um máximo de cinco segundos.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-873">A query against the table service may return a maximum of 1,000 entities at one time and may execute for a maximum of five seconds.</span></span> <span data-ttu-id="3bcd8-874">Se o conjunto de resultados contiver mais de 1.000 entidades, se a consulta não for concluída em até cinco segundos, ou se a consulta ultrapassar o limite da partição, o serviço Tabela retornará um token de continuação para habilitar o aplicativo cliente a solicitar o próximo conjunto de entidades.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-874">If the result set contains more than 1,000 entities, if the query did not complete within five seconds, or if the query crosses the partition boundary, the Table service returns a continuation token to enable the client application to request the next set of entities.</span></span> <span data-ttu-id="3bcd8-875">Para saber mais sobre como funcionam os tokens de continuação, confira [Tempo limite e paginação de consulta](http://msdn.microsoft.com/library/azure/dd135718.aspx).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-875">For more information about how continuation tokens work, see [Query Timeout and Pagination](http://msdn.microsoft.com/library/azure/dd135718.aspx).</span></span>  

<span data-ttu-id="3bcd8-876">Se você estiver usando a Biblioteca de Cliente de Armazenamento, ela pode automaticamente controlar os tokens de continuação para você, à medida que retorna entidades do serviço Tabela.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-876">If you are using the Storage Client Library, it can automatically handle continuation tokens for you as it returns entities from the Table service.</span></span> <span data-ttu-id="3bcd8-877">O seguinte exemplo de código C# usando a Biblioteca de cliente de armazenamento trata automaticamente os tokens de continuação, se o serviço Tabela retorná-los em uma resposta:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-877">The following C# code sample using the Storage Client Library automatically handles continuation tokens if the table service returns them in a response:</span></span>  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

var employees = employeeTable.ExecuteQuery(employeeQuery);
foreach (var emp in employees)
{
        ...
}  
```

<span data-ttu-id="3bcd8-878">O código c# a seguir trata os tokens de continuação explicitamente:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-878">The following C# code handles continuation tokens explicitly:</span></span>  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

TableContinuationToken continuationToken = null;

do
{
        var employees = employeeTable.ExecuteQuerySegmented(
        employeeQuery, continuationToken);
    foreach (var emp in employees)
    {
    ...
    }
    continuationToken = employees.ContinuationToken;
} while (continuationToken != null);  
```

<span data-ttu-id="3bcd8-879">Usando tokens de continuação explicitamente, você pode controlar quando o aplicativo recupera o próximo segmento de dados.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-879">By using continuation tokens explicitly, you can control when your application retrieves the next segment of data.</span></span> <span data-ttu-id="3bcd8-880">Por exemplo, se seu aplicativo cliente habilitar os usuários a percorrer as entidades armazenadas em uma tabela, um usuário poderá decidir não percorrer todas as entidades recuperadas pela consulta para que seu aplicativo só use um token de continuação para recuperar o próximo segmento quando o usuário tive terminado a paginação de todas as entidades no segmento atual.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-880">For example, if your client application enables users to page through the entities stored in a table, a user may decide not to page through all the entities retrieved by the query so your application would only use a continuation token to retrieve the next segment when the user had finished paging through all the entities in the current segment.</span></span> <span data-ttu-id="3bcd8-881">Essa abordagem tem vários benefícios:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-881">This approach has several benefits:</span></span>  

* <span data-ttu-id="3bcd8-882">Ela permite que você limite a quantidade de dados a ser recuperada do serviço Tabela e mover pela rede.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-882">It enables you to limit the amount of data to retrieve from the Table service and that you move over the network.</span></span>  
* <span data-ttu-id="3bcd8-883">Ela permite que você execute E/s assíncrona no .NET.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-883">It enables you to perform asynchronous IO in .NET.</span></span>  
* <span data-ttu-id="3bcd8-884">Ela permite que você serialize o token de acompanhamento para o armazenamento persistente para que você possa continuar caso um aplicativo falhe.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-884">It enables you to serialize the continuation token to persistent storage so you can continue in the event of an application crash.</span></span>  

> [!NOTE]
> <span data-ttu-id="3bcd8-885">Um token de continuação normalmente retorna um segmento que contém 1.000 entidades, embora possa ser menos.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-885">A continuation token typically returns a segment containing 1,000 entities, although it may be fewer.</span></span> <span data-ttu-id="3bcd8-886">Este também será o caso se você limitar o número de entradas que uma consulta retorna, usando **Take** para retornar as primeiras n entidades que correspondem aos seus critérios de pesquisa: o serviço Tabela pode retornar um segmento contendo menos de n entidades, junto com um token de continuação para permitir que você recupere as entidades restantes.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-886">This is also the case if you limit the number of entries a query returns by using **Take** to return the first n entities that match your lookup criteria: the table service may return a segment containing fewer than n entities along with a continuation token to enable you to retrieve the remaining entities.</span></span>  
> 
> 

<span data-ttu-id="3bcd8-887">O código c# a seguir mostra como modificar o número de entidades retornadas dentro de um segmento:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-887">The following C# code shows how to modify the number of entities returned inside a segment:</span></span>  

```csharp
employeeQuery.TakeCount = 50;  
```

#### <a name="server-side-projection"></a><span data-ttu-id="3bcd8-888">Projeção do lado do servidor</span><span class="sxs-lookup"><span data-stu-id="3bcd8-888">Server-side projection</span></span>
<span data-ttu-id="3bcd8-889">Uma única entidade pode ter até 255 propriedades e até 1 MB de tamanho.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-889">A single entity can have up to 255 properties and be up to 1 MB in size.</span></span> <span data-ttu-id="3bcd8-890">Ao consultar a tabela e recuperar entidades, você talvez não precise de todas as propriedades e pode evitar a transferência desnecessária de dados (para ajudar a reduzir a latência e custo).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-890">When you query the table and retrieve entities, you may not need all the properties and can avoid transferring data unnecessarily (to help reduce latency and cost).</span></span> <span data-ttu-id="3bcd8-891">Você pode usar a projeção do lado do servidor para transferir apenas as propriedades que precisa.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-891">You can use server-side projection to transfer just the properties you need.</span></span> <span data-ttu-id="3bcd8-892">O exemplo a seguir recupera apenas a propriedade **Email** (com **PartitionKey**, **RowKey**, **Timestamp** e **ETag**) das entidades selecionadas pela consulta.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-892">The following example is retrieves just the **Email** property (along with **PartitionKey**, **RowKey**, **Timestamp**, and **ETag**) from the entities selected by the query.</span></span>  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
List<string> columns = new List<string>() { "Email" };
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter).Select(columns);

var entities = employeeTable.ExecuteQuery(employeeQuery);
foreach (var e in entities)
{
        Console.WriteLine("RowKey: {0}, EmployeeEmail: {1}", e.RowKey, e.Email);
}  
```

<span data-ttu-id="3bcd8-893">Observe como o valor **RowKey** fica disponível, mesmo que não tenha sido incluído na lista de propriedades para recuperação.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-893">Notice how the **RowKey** value is available even though it was not included in the list of properties to retrieve.</span></span>  

### <a name="modifying-entities"></a><span data-ttu-id="3bcd8-894">Modificando entidades</span><span class="sxs-lookup"><span data-stu-id="3bcd8-894">Modifying entities</span></span>
<span data-ttu-id="3bcd8-895">A Biblioteca de Cliente de Armazenamento permite que você modifique suas entidades armazenadas no serviço Tabela, inserindo, excluindo e atualizando entidades.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-895">The Storage Client Library enables you to modify your entities stored in the table service by inserting, deleting, and updating entities.</span></span> <span data-ttu-id="3bcd8-896">Você pode usar EGTs para várias operações de inserção, atualização e exclusão para reduzir o número de viagens de ida e volta necessárias e melhorar o desempenho da solução.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-896">You can use EGTs to batch multiple insert, update, and delete operations together to reduce the number of round trips required and improve the performance of your solution.</span></span>  

<span data-ttu-id="3bcd8-897">Observe que as exceções geradas quando a Biblioteca de Cliente de Armazenamento executa uma EGT normalmente incluem o índice da entidade que causou a falha no lote.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-897">Note that exceptions thrown when the Storage Client Library executes an EGT typically include the index of the entity that caused the batch to fail.</span></span> <span data-ttu-id="3bcd8-898">Isso é útil quando você está depurando código que usa EGTs.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-898">This is helpful when you are debugging code that uses EGTs.</span></span>  

<span data-ttu-id="3bcd8-899">Você também deve considerar como seu design afeta a forma de tratamento, por parte do cliente, das operações de simultaneidade e atualização.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-899">You should also consider how your design affects how your client application handles concurrency and update operations.</span></span>  

#### <a name="managing-concurrency"></a><span data-ttu-id="3bcd8-900">Gerenciando simultaneidade</span><span class="sxs-lookup"><span data-stu-id="3bcd8-900">Managing concurrency</span></span>
<span data-ttu-id="3bcd8-901">Por padrão, o serviço Tabela implementa verificações de simultaneidade otimista no nível de entidades individuais para as operações **Inserir**, **Mesclar** e **Excluir**, embora um cliente possa forçar o serviço Tabela a ignorar essas verificações.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-901">By default, the table service implements optimistic concurrency checks at the level of individual entities for **Insert**, **Merge**, and **Delete** operations, although it is possible for a client to force the table service to bypass these checks.</span></span> <span data-ttu-id="3bcd8-902">Para obter mais informações sobre como o serviço Tabela gerencia a simultaneidade, confira [Gerenciando a simultaneidade no Armazenamento do Microsoft Azure](storage-concurrency.md).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-902">For more information about how the table service manages concurrency, see  [Managing Concurrency in Microsoft Azure Storage](storage-concurrency.md).</span></span>  

#### <a name="merge-or-replace"></a><span data-ttu-id="3bcd8-903">Mesclar ou substituir</span><span class="sxs-lookup"><span data-stu-id="3bcd8-903">Merge or replace</span></span>
<span data-ttu-id="3bcd8-904">O método **Replace** da classe **TableOperation** sempre substitui a entidade completa no serviço Tabela.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-904">The **Replace** method of the **TableOperation** class always replaces the complete entity in the Table service.</span></span> <span data-ttu-id="3bcd8-905">Se você não incluir uma propriedade na solicitação quando essa propriedade existe na entidade armazenada, a solicitação removerá a propriedade da entidade armazenada.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-905">If you do not include a property in the request when that property exists in the stored entity, the request removes that property from the stored entity.</span></span> <span data-ttu-id="3bcd8-906">A menos que você queira remover uma propriedade explicitamente de uma entidade armazenada, você deve incluir todas as propriedades na solicitação.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-906">Unless you want to remove a property explicitly from a stored entity, you must include every property in the request.</span></span>  

<span data-ttu-id="3bcd8-907">Você pode usar o método **Merge** da classe **TableOperation** para reduzir a quantidade de dados enviados para o serviço Tabela quando quiser atualizar uma entidade.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-907">You can use the **Merge** method of the **TableOperation** class to reduce the amount of data that you send to the Table service when you want to update an entity.</span></span> <span data-ttu-id="3bcd8-908">O método **Mesclar** substitui todas as propriedades na entidade armazenada por valores de propriedade da entidade incluída na solicitação, mas deixa intactas quaisquer eventuais propriedades na entidade armazenada que não estejam incluídas na solicitação.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-908">The **Merge** method replaces any properties in the stored entity with property values from the entity included in the request, but leaves intact any properties in the stored entity that are not included in the request.</span></span> <span data-ttu-id="3bcd8-909">Isso é útil se você tiver grandes entidades e só precisar atualizar um pequeno número de propriedades em uma solicitação.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-909">This is useful if you have large entities and only need to update a small number of properties in a request.</span></span>  

> [!NOTE]
> <span data-ttu-id="3bcd8-910">Os métodos **Replace** e **Merge** falharão se a entidade não existir.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-910">The **Replace** and **Merge** methods fail if the entity does not exist.</span></span> <span data-ttu-id="3bcd8-911">Como alternativa, você pode usar os métodos **InsertOrReplace** e **InsertOrMerge**, que criam uma nova entidade se ela não existir.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-911">As an alternative, you can use the **InsertOrReplace** and **InsertOrMerge** methods that create a new entity if it doesn't exist.</span></span>  
> 
> 

### <a name="working-with-heterogeneous-entity-types"></a><span data-ttu-id="3bcd8-912">Trabalhando com tipos de entidade heterogênea</span><span class="sxs-lookup"><span data-stu-id="3bcd8-912">Working with heterogeneous entity types</span></span>
<span data-ttu-id="3bcd8-913">O serviço Tabela é um armazenamento de tabela *sem esquema* , o que significa que uma única tabela pode armazenar entidades de vários tipos, fornecendo grande flexibilidade no design.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-913">The Table service is a *schema-less* table store that means that a single table can store entities of multiple types providing great flexibility in your design.</span></span> <span data-ttu-id="3bcd8-914">O exemplo a seguir ilustra uma tabela que armazena as entidades funcionário e departamento:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-914">The following example illustrates a table storing both employee and department entities:</span></span>  

<table>
<tr>
<th><span data-ttu-id="3bcd8-915">PartitionKey</span><span class="sxs-lookup"><span data-stu-id="3bcd8-915">PartitionKey</span></span></th>
<th><span data-ttu-id="3bcd8-916">RowKey</span><span class="sxs-lookup"><span data-stu-id="3bcd8-916">RowKey</span></span></th>
<th><span data-ttu-id="3bcd8-917">Timestamp</span><span class="sxs-lookup"><span data-stu-id="3bcd8-917">Timestamp</span></span></th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="3bcd8-918">Nome</span><span class="sxs-lookup"><span data-stu-id="3bcd8-918">FirstName</span></span></th>
<th><span data-ttu-id="3bcd8-919">Sobrenome</span><span class="sxs-lookup"><span data-stu-id="3bcd8-919">LastName</span></span></th>
<th><span data-ttu-id="3bcd8-920">Idade</span><span class="sxs-lookup"><span data-stu-id="3bcd8-920">Age</span></span></th>
<th><span data-ttu-id="3bcd8-921">Email</span><span class="sxs-lookup"><span data-stu-id="3bcd8-921">Email</span></span></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="3bcd8-922">Nome</span><span class="sxs-lookup"><span data-stu-id="3bcd8-922">FirstName</span></span></th>
<th><span data-ttu-id="3bcd8-923">Sobrenome</span><span class="sxs-lookup"><span data-stu-id="3bcd8-923">LastName</span></span></th>
<th><span data-ttu-id="3bcd8-924">Idade</span><span class="sxs-lookup"><span data-stu-id="3bcd8-924">Age</span></span></th>
<th><span data-ttu-id="3bcd8-925">Email</span><span class="sxs-lookup"><span data-stu-id="3bcd8-925">Email</span></span></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="3bcd8-926">DepartmentName</span><span class="sxs-lookup"><span data-stu-id="3bcd8-926">DepartmentName</span></span></th>
<th><span data-ttu-id="3bcd8-927">EmployeeCount</span><span class="sxs-lookup"><span data-stu-id="3bcd8-927">EmployeeCount</span></span></th>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="3bcd8-928">Nome</span><span class="sxs-lookup"><span data-stu-id="3bcd8-928">FirstName</span></span></th>
<th><span data-ttu-id="3bcd8-929">Sobrenome</span><span class="sxs-lookup"><span data-stu-id="3bcd8-929">LastName</span></span></th>
<th><span data-ttu-id="3bcd8-930">Idade</span><span class="sxs-lookup"><span data-stu-id="3bcd8-930">Age</span></span></th>
<th><span data-ttu-id="3bcd8-931">Email</span><span class="sxs-lookup"><span data-stu-id="3bcd8-931">Email</span></span></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

<span data-ttu-id="3bcd8-932">Observe que cada entidade deve ter ainda os valores de **PartitionKey**, **RowKey** e **Timestamp**, mas pode ter qualquer conjunto de propriedades.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-932">Note that each entity must still have **PartitionKey**, **RowKey**, and **Timestamp** values, but may have any set of properties.</span></span> <span data-ttu-id="3bcd8-933">Além disso, não há nada para indicar o tipo de uma entidade, a menos que você opte por armazenar essa informação em algum lugar.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-933">Furthermore, there is nothing to indicate the type of an entity unless you choose to store that information somewhere.</span></span> <span data-ttu-id="3bcd8-934">Há duas opções para identificar o tipo de entidade:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-934">There are two options for identifying the entity type:</span></span>  

* <span data-ttu-id="3bcd8-935">Prefixe o tipo de entidade à **RowKey** (ou possivelmente à **PartitionKey**).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-935">Prepend the entity type to the **RowKey** (or possibly the **PartitionKey**).</span></span> <span data-ttu-id="3bcd8-936">Por exemplo, **EMPLOYEE_000123** ou **DEPARTMENT_SALES** como valores de **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-936">For example, **EMPLOYEE_000123** or **DEPARTMENT_SALES** as **RowKey** values.</span></span>  
* <span data-ttu-id="3bcd8-937">Use uma propriedade separada para registrar o tipo de entidade, conforme mostrado na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-937">Use a separate property to record the entity type as shown in the table below.</span></span>  

<table>
<tr>
<th><span data-ttu-id="3bcd8-938">PartitionKey</span><span class="sxs-lookup"><span data-stu-id="3bcd8-938">PartitionKey</span></span></th>
<th><span data-ttu-id="3bcd8-939">RowKey</span><span class="sxs-lookup"><span data-stu-id="3bcd8-939">RowKey</span></span></th>
<th><span data-ttu-id="3bcd8-940">Timestamp</span><span class="sxs-lookup"><span data-stu-id="3bcd8-940">Timestamp</span></span></th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="3bcd8-941">EntityType</span><span class="sxs-lookup"><span data-stu-id="3bcd8-941">EntityType</span></span></th>
<th><span data-ttu-id="3bcd8-942">Nome</span><span class="sxs-lookup"><span data-stu-id="3bcd8-942">FirstName</span></span></th>
<th><span data-ttu-id="3bcd8-943">Sobrenome</span><span class="sxs-lookup"><span data-stu-id="3bcd8-943">LastName</span></span></th>
<th><span data-ttu-id="3bcd8-944">Idade</span><span class="sxs-lookup"><span data-stu-id="3bcd8-944">Age</span></span></th>
<th><span data-ttu-id="3bcd8-945">Email</span><span class="sxs-lookup"><span data-stu-id="3bcd8-945">Email</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="3bcd8-946">Funcionário</span><span class="sxs-lookup"><span data-stu-id="3bcd8-946">Employee</span></span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="3bcd8-947">EntityType</span><span class="sxs-lookup"><span data-stu-id="3bcd8-947">EntityType</span></span></th>
<th><span data-ttu-id="3bcd8-948">Nome</span><span class="sxs-lookup"><span data-stu-id="3bcd8-948">FirstName</span></span></th>
<th><span data-ttu-id="3bcd8-949">Sobrenome</span><span class="sxs-lookup"><span data-stu-id="3bcd8-949">LastName</span></span></th>
<th><span data-ttu-id="3bcd8-950">Idade</span><span class="sxs-lookup"><span data-stu-id="3bcd8-950">Age</span></span></th>
<th><span data-ttu-id="3bcd8-951">Email</span><span class="sxs-lookup"><span data-stu-id="3bcd8-951">Email</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="3bcd8-952">Funcionário</span><span class="sxs-lookup"><span data-stu-id="3bcd8-952">Employee</span></span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="3bcd8-953">EntityType</span><span class="sxs-lookup"><span data-stu-id="3bcd8-953">EntityType</span></span></th>
<th><span data-ttu-id="3bcd8-954">DepartmentName</span><span class="sxs-lookup"><span data-stu-id="3bcd8-954">DepartmentName</span></span></th>
<th><span data-ttu-id="3bcd8-955">EmployeeCount</span><span class="sxs-lookup"><span data-stu-id="3bcd8-955">EmployeeCount</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="3bcd8-956">department</span><span class="sxs-lookup"><span data-stu-id="3bcd8-956">Department</span></span></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="3bcd8-957">EntityType</span><span class="sxs-lookup"><span data-stu-id="3bcd8-957">EntityType</span></span></th>
<th><span data-ttu-id="3bcd8-958">Nome</span><span class="sxs-lookup"><span data-stu-id="3bcd8-958">FirstName</span></span></th>
<th><span data-ttu-id="3bcd8-959">Sobrenome</span><span class="sxs-lookup"><span data-stu-id="3bcd8-959">LastName</span></span></th>
<th><span data-ttu-id="3bcd8-960">Idade</span><span class="sxs-lookup"><span data-stu-id="3bcd8-960">Age</span></span></th>
<th><span data-ttu-id="3bcd8-961">Email</span><span class="sxs-lookup"><span data-stu-id="3bcd8-961">Email</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="3bcd8-962">Funcionário</span><span class="sxs-lookup"><span data-stu-id="3bcd8-962">Employee</span></span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

<span data-ttu-id="3bcd8-963">A primeira opção, prefixar o tipo de entidade a **RowKey**, é útil quando há uma possibilidade de que duas entidades de tipos diferentes possam ter o mesmo valor de chave.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-963">The first option, prepending the entity type to the **RowKey**, is useful if there is a possibility that two entities of different types might have the same key value.</span></span> <span data-ttu-id="3bcd8-964">Ela também agrupa entidades do mesmo tipo juntas na partição.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-964">It also groups entities of the same type together in the partition.</span></span>  

<span data-ttu-id="3bcd8-965">As técnicas discutidas nesta seção são importantes principalmente para a discussão sobre [Relações de herança](#inheritance-relationships), anteriormente neste guia, na seção [Relações de modelagem](#modelling-relationships).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-965">The techniques discussed in this section are especially relevant to the discussion [Inheritance relationships](#inheritance-relationships) earlier in this guide in the section [Modelling relationships](#modelling-relationships).</span></span>  

> [!NOTE]
> <span data-ttu-id="3bcd8-966">Você deve considerar a inclusão do número de versão no valor do tipo de entidade para habilitar aplicativos clientes a desenvolverem objetos POCO e trabalhem com diferentes versões.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-966">You should consider including a version number in the entity type value to enable client applications to evolve POCO objects and work with different versions.</span></span>  
> 
> 

<span data-ttu-id="3bcd8-967">O restante desta seção descreve alguns dos recursos na Biblioteca de Cliente de Armazenamento que facilitam o trabalho com vários tipos de entidade na mesma tabela.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-967">The remainder of this section describes some of the features in the Storage Client Library that facilitate working with multiple entity types in the same table.</span></span>  

#### <a name="retrieving-heterogeneous-entity-types"></a><span data-ttu-id="3bcd8-968">Recuperando tipos de entidade heterogênea</span><span class="sxs-lookup"><span data-stu-id="3bcd8-968">Retrieving heterogeneous entity types</span></span>
<span data-ttu-id="3bcd8-969">Se você estiver usando a Biblioteca de Cliente de Armazenamento, tem três opções para trabalhar com vários tipos de entidade.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-969">If you are using the Storage Client Library, you have three options for working with multiple entity types.</span></span>  

<span data-ttu-id="3bcd8-970">Se souber o tipo de entidade armazenado com determinados valores de **RowKey** e **PartitionKey**, você poderá especificar o tipo de entidade ao recuperar a entidade, conforme mostrado nos dois exemplos anteriores que recuperam entidades do tipo **EmployeeEntity**: [Executando uma consulta de ponto usando a Biblioteca de Cliente de Armazenamento](#executing-a-point-query-using-the-storage-client-library) e [Recuperando várias entidades usando LINQ](#retrieving-multiple-entities-using-linq).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-970">If you know the type of the entity stored with a specific **RowKey** and **PartitionKey** values, then you can specify the entity type when you retrieve the entity as shown in the previous two examples that retrieve entities of type **EmployeeEntity**: [Executing a point query using the Storage Client Library](#executing-a-point-query-using-the-storage-client-library) and [Retrieving multiple entities using LINQ](#retrieving-multiple-entities-using-linq).</span></span>  

<span data-ttu-id="3bcd8-971">A segunda opção é usar o tipo **DynamicTableEntity** (um recipiente de propriedades), em vez de um tipo concreto de entidade POCO (essa opção também pode melhorar o desempenho, porque não é necessário serializar e desserializar a entidade para tipos .NET).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-971">The second option is to use the **DynamicTableEntity** type (a property bag) instead of a concrete POCO entity type (this option may also improve performance because there is no need to serialize and deserialize the entity to .NET types).</span></span> <span data-ttu-id="3bcd8-972">O código C# a seguir recupera potencialmente várias entidades de diferentes tipos de tabela, mas retorna todas as entidades como instâncias **DynamicTableEntity** .</span><span class="sxs-lookup"><span data-stu-id="3bcd8-972">The following C# code potentially retrieves multiple entities of different types from the table, but returns all entities as **DynamicTableEntity** instances.</span></span> <span data-ttu-id="3bcd8-973">Ele usa a propriedade **EntityType** para determinar o tipo de cada entidade:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-973">It then uses the **EntityType** property to determine the type of each entity:</span></span>  

```csharp
string filter = TableQuery.CombineFilters(
    TableQuery.GenerateFilterCondition("PartitionKey",
    QueryComparisons.Equal, "Sales"),
    TableOperators.And,
    TableQuery.CombineFilters(
    TableQuery.GenerateFilterCondition("RowKey",
                    QueryComparisons.GreaterThanOrEqual, "B"),
        TableOperators.And,
        TableQuery.GenerateFilterCondition("RowKey",
        QueryComparisons.LessThan, "F")
    )
);
TableQuery<DynamicTableEntity> entityQuery =
    new TableQuery<DynamicTableEntity>().Where(filter);
var employees = employeeTable.ExecuteQuery(entityQuery);

IEnumerable<DynamicTableEntity> entities = employeeTable.ExecuteQuery(entityQuery);
foreach (var e in entities)
{
EntityProperty entityTypeProperty;
if (e.Properties.TryGetValue("EntityType", out entityTypeProperty))
{
    if (entityTypeProperty.StringValue == "Employee")
    {
        // Use entityTypeProperty, RowKey, PartitionKey, Etag, and Timestamp
        }
    }
}  
```

<span data-ttu-id="3bcd8-974">Observe que para recuperar outras propriedades, você deve usar o método **TryGetValue** na propriedade **Properties** da classe **DynamicTableEntity**.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-974">Note that to retrieve other properties you must use the **TryGetValue** method on the **Properties** property of the **DynamicTableEntity** class.</span></span>  

<span data-ttu-id="3bcd8-975">Uma terceira opção é combinar o uso do tipo **DynamicTableEntity** e uma instância **EntityResolver**.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-975">A third option is to combine using the **DynamicTableEntity** type and an **EntityResolver** instance.</span></span> <span data-ttu-id="3bcd8-976">Isso permite que você resolver para vários tipos POCO na mesma consulta.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-976">This enables you to resolve to multiple POCO types in the same query.</span></span> <span data-ttu-id="3bcd8-977">Neste exemplo, o **EntityResolver** delegado usa a propriedade **EntityType** para distinguir entre os dois tipos de entidade retornados pela consulta.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-977">In this example, the **EntityResolver** delegate is using the **EntityType** property to distinguish between the two types of entity that the query returns.</span></span> <span data-ttu-id="3bcd8-978">O método **Resolve** usa o **resolvedor** delegado para resolver instâncias **DynamicTableEntity** para instâncias **TableEntity**.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-978">The **Resolve** method uses the **resolver** delegate to resolve **DynamicTableEntity** instances to **TableEntity** instances.</span></span>  

```csharp
EntityResolver<TableEntity> resolver = (pk, rk, ts, props, etag) =>
{

        TableEntity resolvedEntity = null;
        if (props["EntityType"].StringValue == "Department")
        {
        resolvedEntity = new DepartmentEntity();
        }
        else if (props["EntityType"].StringValue == "Employee")
        {
        resolvedEntity = new EmployeeEntity();
        }
        else throw new ArgumentException("Unrecognized entity", "props");

        resolvedEntity.PartitionKey = pk;
        resolvedEntity.RowKey = rk;
        resolvedEntity.Timestamp = ts;
        resolvedEntity.ETag = etag;
        resolvedEntity.ReadEntity(props, null);
        return resolvedEntity;
};

string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<DynamicTableEntity> entityQuery =
        new TableQuery<DynamicTableEntity>().Where(filter);

var entities = employeeTable.ExecuteQuery(entityQuery, resolver);
foreach (var e in entities)
{
        if (e is DepartmentEntity)
        {
    ...
        }
        if (e is EmployeeEntity)
        {
    ...
        }
}  
```

#### <a name="modifying-heterogeneous-entity-types"></a><span data-ttu-id="3bcd8-979">Modificando tipos de entidade heterogênea</span><span class="sxs-lookup"><span data-stu-id="3bcd8-979">Modifying heterogeneous entity types</span></span>
<span data-ttu-id="3bcd8-980">Você não precisa saber o tipo de uma entidade para excluí-la, e você sempre sabe o tipo de uma entidade quando a insere.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-980">You do not need to know the type of an entity to delete it, and you always know the type of an entity when you insert it.</span></span> <span data-ttu-id="3bcd8-981">No entanto, você pode usar o tipo **DynamicTableEntity** para atualizar uma entidade sem saber seu tipo e sem usar uma classe de entidade POCO.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-981">However, you can use **DynamicTableEntity** type to update an entity without knowing its type and without using a POCO entity class.</span></span> <span data-ttu-id="3bcd8-982">O exemplo de código a seguir recupera uma única entidade e verifica se a propriedade **EmployeeCount** existe antes de atualizá-la.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-982">The following code sample retrieves a single entity, and checks the **EmployeeCount** property exists before updating it.</span></span>  

```csharp
TableResult result =
        employeeTable.Execute(TableOperation.Retrieve(partitionKey, rowKey));
DynamicTableEntity department = (DynamicTableEntity)result.Result;

EntityProperty countProperty;

if (!department.Properties.TryGetValue("EmployeeCount", out countProperty))
{
        throw new
        InvalidOperationException("Invalid entity, EmployeeCount property not found.");
}
countProperty.Int32Value += 1;
employeeTable.Execute(TableOperation.Merge(department));  
```

### <a name="controlling-access-with-shared-access-signatures"></a><span data-ttu-id="3bcd8-983">Controlando o acesso com assinaturas de acesso compartilhado</span><span class="sxs-lookup"><span data-stu-id="3bcd8-983">Controlling access with Shared Access Signatures</span></span>
<span data-ttu-id="3bcd8-984">Você pode usar tokens de SAS (Assinatura de Acesso Compartilhado) para habilitar aplicativos cliente a modificarem (e consultarem) diretamente, sem a necessidade de autenticação direta no serviço Tabela.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-984">You can use Shared Access Signature (SAS) tokens to enable client applications to modify (and query) table entities directly without the need to authenticate directly with the table service.</span></span> <span data-ttu-id="3bcd8-985">Normalmente, há três benefícios principais para usar SAS em seu aplicativo:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-985">Typically, there are three main benefits to using SAS in your application:</span></span>  

* <span data-ttu-id="3bcd8-986">Você não precisa distribuir sua chave de conta de armazenamento para uma plataforma insegura (como um dispositivo móvel) para permitir que esse dispositivo acesse e modifique entidades no serviço Tabela.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-986">You do not need to distribute your storage account key to an insecure platform (such as a mobile device) in order to allow that device to access and modify entities in the Table service.</span></span>  
* <span data-ttu-id="3bcd8-987">Você pode descarregar parte do trabalho que as funções Web e de trabalho desempenham no gerenciamento de suas entidades em dispositivos clientes, como computadores de usuários finais e dispositivos móveis.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-987">You can offload some of the work that web and worker roles perform in managing your entities to client devices such as end-user computers and mobile devices.</span></span>  
* <span data-ttu-id="3bcd8-988">Você pode atribuir um conjunto de permissões restrito e de tempo limitado a um cliente (como acesso somente leitura a recursos específicos).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-988">You can assign a constrained and time limited set of permissions to a client (such as allowing read-only access to specific resources).</span></span>  

<span data-ttu-id="3bcd8-989">Para obter mais informações sobre como usar tokens SAS com o serviço Tabela, consulte [Uso de SAS (Assinaturas de Acesso Compartilhado)](storage-dotnet-shared-access-signature-part-1.md).</span><span class="sxs-lookup"><span data-stu-id="3bcd8-989">For more information about using SAS tokens with the Table service, see [Using Shared Access Signatures (SAS)](storage-dotnet-shared-access-signature-part-1.md).</span></span>  

<span data-ttu-id="3bcd8-990">No entanto, você ainda deve gerar os tokens SAS que concedem a um aplicativo cliente para as entidades no serviço Tabela: você deve fazer isso em um ambiente com acesso seguro às chaves de conta de armazenamento.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-990">However, you must still generate the SAS tokens that grant a client application to the entities in the table service: you should do this in an environment that has secure access to your storage account keys.</span></span> <span data-ttu-id="3bcd8-991">Geralmente, você usa uma função de trabalho ou Web para gerar tokens SAS e enviá-los aos aplicativos clientes que precisam acessar suas entidades.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-991">Typically, you use a web or worker role to generate the SAS tokens and deliver them to the client applications that need access to your entities.</span></span> <span data-ttu-id="3bcd8-992">Como ainda há uma sobrecarga envolvida na geração e fornecimento de tokens SAS aos clientes, você deve considerar a melhor maneira de reduzir essa sobrecarga, especialmente em cenários de alto volume.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-992">Because there is still an overhead involved in generating and delivering SAS tokens to clients, you should consider how best to reduce this overhead, especially in high-volume scenarios.</span></span>  

<span data-ttu-id="3bcd8-993">É possível gerar um token SAS que conceda acesso a um subconjunto de entidades em uma tabela.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-993">It is possible to generate a SAS token that grants access to a subset of the entities in a table.</span></span> <span data-ttu-id="3bcd8-994">Por padrão, você cria um token SAS para uma tabela inteira, mas também é possível especificar que o token SAS conceda acesso a um intervalo de valores de **PartitionKey** ou a um intervalo de valores de **PartitionKey** e **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-994">By default, you create a SAS token for an entire table, but it is also possible to specify that the SAS token grant access to either a range of **PartitionKey** values, or a range of **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="3bcd8-995">Você pode optar por gerar tokens SAS para usuários individuais do sistema, de modo que o token SAS de cada usuário só permita acesso às suas próprias entidades no serviço Tabela.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-995">You might choose to generate SAS tokens for individual users of your system such that each user's SAS token only allows them access to their own entities in the table service.</span></span>  

### <a name="asynchronous-and-parallel-operations"></a><span data-ttu-id="3bcd8-996">Operações paralelas e assíncronas</span><span class="sxs-lookup"><span data-stu-id="3bcd8-996">Asynchronous and parallel operations</span></span>
<span data-ttu-id="3bcd8-997">Desde que você esteja distribuindo suas solicitações por várias partições, pode melhorar a capacidade de resposta do cliente e a taxa de transferência usando consultas assíncronas ou paralelas.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-997">Provided you are spreading your requests across multiple partitions, you can improve throughput and client responsiveness by using asynchronous or parallel queries.</span></span>
<span data-ttu-id="3bcd8-998">Por exemplo, você pode ter duas ou mais instâncias de função de trabalho acessando suas tabelas em paralelo.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-998">For example, you might have two or more worker role instances accessing your tables in parallel.</span></span> <span data-ttu-id="3bcd8-999">Você pode ter funções de trabalho individuais responsáveis por determinados conjuntos de partições ou simplesmente ter várias instâncias de função de trabalho, cada uma capaz de acessar todas as partições em uma tabela.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-999">You could have individual worker roles responsible for particular sets of partitions, or simply have multiple worker role instances, each able to access all the partitions in a table.</span></span>  

<span data-ttu-id="3bcd8-1000">Dentro de uma instância do cliente, você pode melhorar o desempenho executando operações de armazenamento de forma assíncrona.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-1000">Within a client instance, you can improve throughput by executing storage operations asynchronously.</span></span> <span data-ttu-id="3bcd8-1001">A Biblioteca de Cliente de Armazenamento facilita a gravação de consultas e modificações assíncronas.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-1001">The Storage Client Library makes it easy to write asynchronous queries and modifications.</span></span> <span data-ttu-id="3bcd8-1002">Por exemplo, você pode começar com o método síncrono que recupera todas as entidades em uma partição, como mostra o código c# a seguir:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-1002">For example, you might start with the synchronous method that retrieves all the entities in a partition as shown in the following C# code:</span></span>  

```csharp
private static void ManyEntitiesQuery(CloudTable employeeTable, string department)
{
        string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

        TableContinuationToken continuationToken = null;

        do
        {
        var employees = employeeTable.ExecuteQuerySegmented(
                employeeQuery, continuationToken);
        foreach (var emp in employees)
    {
        ...
    }
        continuationToken = employees.ContinuationToken;
        } while (continuationToken != null);
}  
```

<span data-ttu-id="3bcd8-1003">Você pode facilmente modificar esse código para que a consulta seja executada de forma assíncrona, da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-1003">You can easily modify this code so that the query runs asynchronously as follows:</span></span>  

```csharp
private static async Task ManyEntitiesQueryAsync(CloudTable employeeTable, string department)
{
        string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);
        TableContinuationToken continuationToken = null;

        do
        {
        var employees = await employeeTable.ExecuteQuerySegmentedAsync(
                employeeQuery, continuationToken);
        foreach (var emp in employees)
        {
            ...
        }
        continuationToken = employees.ContinuationToken;
            } while (continuationToken != null);
}  
```

<span data-ttu-id="3bcd8-1004">Neste exemplo assíncrono, você pode ver as seguintes alterações da versão síncrona:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-1004">In this asynchronous example, you can see the following changes from the synchronous version:</span></span>  

* <span data-ttu-id="3bcd8-1005">A assinatura do método agora inclui o modificador **async** e retorna uma instância **Task**.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-1005">The method signature now includes the **async** modifier and returns a **Task** instance.</span></span>  
* <span data-ttu-id="3bcd8-1006">Em vez de chamar o método **ExecuteSegmented** para recuperar os resultados, agora o método chama o método **ExecuteSegmentedAsync** e usa o modificador **await** para recuperar resultados de forma assíncrona.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-1006">Instead of calling the **ExecuteSegmented** method to retrieve results, the method now calls the **ExecuteSegmentedAsync** method and uses the **await** modifier to retrieve results asynchronously.</span></span>  

<span data-ttu-id="3bcd8-1007">O aplicativo cliente pode chamar esse método várias vezes (com valores diferentes para o parâmetro **department** ) e cada consulta será executada em um thread separado.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-1007">The client application can call this method multiple times (with different values for the **department** parameter), and each query will run on a separate thread.</span></span>  

<span data-ttu-id="3bcd8-1008">Observe que não há qualquer versão assíncrona do método **Execute** na classe **TableQuery**, pois a interface **IEnumerable** não dá suporte à enumeração assíncrona.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-1008">Note that there is no asynchronous version of the **Execute** method in the **TableQuery** class because the **IEnumerable** interface does not support asynchronous enumeration.</span></span>  

<span data-ttu-id="3bcd8-1009">Você também pode inserir, atualizar e excluir entidades de forma assíncrona.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-1009">You can also insert, update, and delete entities asynchronously.</span></span> <span data-ttu-id="3bcd8-1010">O exemplo c# a seguir mostra um método síncrono simples para inserir ou substituir uma entidade funcionário:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-1010">The following C# example shows a simple, synchronous method to insert or replace an employee entity:</span></span>  

```csharp
private static void SimpleEmployeeUpsert(CloudTable employeeTable,
        EmployeeEntity employee)
{
        TableResult result = employeeTable
        .Execute(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
}  
```

<span data-ttu-id="3bcd8-1011">Você pode modificar este código facilmente para que a atualização seja executada de forma assíncrona da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-1011">You can easily modify this code so that the update runs asynchronously as follows:</span></span>  

```csharp
private static async Task SimpleEmployeeUpsertAsync(CloudTable employeeTable,
        EmployeeEntity employee)
{
        TableResult result = await employeeTable
        .ExecuteAsync(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
}  
```

<span data-ttu-id="3bcd8-1012">Neste exemplo assíncrono, você pode ver as seguintes alterações da versão síncrona:</span><span class="sxs-lookup"><span data-stu-id="3bcd8-1012">In this asynchronous example, you can see the following changes from the synchronous version:</span></span>  

* <span data-ttu-id="3bcd8-1013">A assinatura do método agora inclui o modificador **async** e retorna uma instância **Task**.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-1013">The method signature now includes the **async** modifier and returns a **Task** instance.</span></span>  
* <span data-ttu-id="3bcd8-1014">Em vez de chamar o método **Execute** para atualizar a entidade, agora o método chama o método **ExecuteAsync** e usa o modificador **await** para recuperar resultados de modo assíncrono.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-1014">Instead of calling the **Execute** method to update the entity, the method now calls the **ExecuteAsync** method and uses the **await** modifier to retrieve results asynchronously.</span></span>  

<span data-ttu-id="3bcd8-1015">O aplicativo cliente pode chamar vários métodos assíncronos como esse, e cada invocação de método será executado em um thread separado.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-1015">The client application can call multiple asynchronous methods like this one, and each method invocation will run on a separate thread.</span></span>  

### <a name="credits"></a><span data-ttu-id="3bcd8-1016">Credits</span><span class="sxs-lookup"><span data-stu-id="3bcd8-1016">Credits</span></span>
<span data-ttu-id="3bcd8-1017">Gostaríamos de agradecer os seguintes membros da equipe do Azure por suas contribuições: Dominic Betts, Jason Hogg, Jean Ghanem, Jai Haridas, Jeff Irwin, Vamshidhar Kommineni, Vinay Shah e Serdar Ozler, bem como Tom Hollander da Microsoft DX.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-1017">We would like to thank the following members of the Azure team for their contributions: Dominic Betts, Jason Hogg, Jean Ghanem, Jai Haridas, Jeff Irwin, Vamshidhar Kommineni, Vinay Shah and Serdar Ozler as well as  Tom Hollander from Microsoft DX.</span></span> 

<span data-ttu-id="3bcd8-1018">Também gostaríamos de agradecer aos seguintes MVPs da Microsoft por seus valiosos comentários durante os ciclos de revisão: Igor Papirov e Edward Bakker.</span><span class="sxs-lookup"><span data-stu-id="3bcd8-1018">We would also like to thank the following Microsoft MVP's for their valuable feedback during review cycles: Igor Papirov and Edward Bakker.</span></span>

[1]: ./media/storage-table-design-guide/storage-table-design-IMAGE01.png
[2]: ./media/storage-table-design-guide/storage-table-design-IMAGE02.png
[3]: ./media/storage-table-design-guide/storage-table-design-IMAGE03.png
[4]: ./media/storage-table-design-guide/storage-table-design-IMAGE04.png
[5]: ./media/storage-table-design-guide/storage-table-design-IMAGE05.png
[6]: ./media/storage-table-design-guide/storage-table-design-IMAGE06.png
[7]: ./media/storage-table-design-guide/storage-table-design-IMAGE07.png
[8]: ./media/storage-table-design-guide/storage-table-design-IMAGE08.png
[9]: ./media/storage-table-design-guide/storage-table-design-IMAGE09.png
[10]: ./media/storage-table-design-guide/storage-table-design-IMAGE10.png
[11]: ./media/storage-table-design-guide/storage-table-design-IMAGE11.png
[12]: ./media/storage-table-design-guide/storage-table-design-IMAGE12.png
[13]: ./media/storage-table-design-guide/storage-table-design-IMAGE13.png
[14]: ./media/storage-table-design-guide/storage-table-design-IMAGE14.png
[15]: ./media/storage-table-design-guide/storage-table-design-IMAGE15.png
[16]: ./media/storage-table-design-guide/storage-table-design-IMAGE16.png
[17]: ./media/storage-table-design-guide/storage-table-design-IMAGE17.png
[18]: ./media/storage-table-design-guide/storage-table-design-IMAGE18.png
[19]: ./media/storage-table-design-guide/storage-table-design-IMAGE19.png
[20]: ./media/storage-table-design-guide/storage-table-design-IMAGE20.png
[21]: ./media/storage-table-design-guide/storage-table-design-IMAGE21.png
[22]: ./media/storage-table-design-guide/storage-table-design-IMAGE22.png
[23]: ./media/storage-table-design-guide/storage-table-design-IMAGE23.png
[24]: ./media/storage-table-design-guide/storage-table-design-IMAGE24.png
[25]: ./media/storage-table-design-guide/storage-table-design-IMAGE25.png
[26]: ./media/storage-table-design-guide/storage-table-design-IMAGE26.png
[27]: ./media/storage-table-design-guide/storage-table-design-IMAGE27.png
[28]: ./media/storage-table-design-guide/storage-table-design-IMAGE28.png
[29]: ./media/storage-table-design-guide/storage-table-design-IMAGE29.png


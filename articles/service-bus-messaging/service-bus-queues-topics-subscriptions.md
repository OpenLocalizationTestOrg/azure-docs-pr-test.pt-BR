---
title: "Visão geral das filas de mensagens, tópicos e assinaturas do Barramento de Serviço do Azure | Microsoft Docs"
description: "Visão geral de entidades do sistema de mensagens do Barramento de Serviço."
services: service-bus-messaging
documentationcenter: na
author: sethmanheim
manager: timlt
editor: 
ms.assetid: a306ced4-74e9-47c6-990a-d9c47efa31d5
ms.service: service-bus-messaging
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 06/28/2017
ms.author: sethm
ms.openlocfilehash: 00f9f38fbae028486270053dedb4df580a3f1a44
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/18/2017
---
# <a name="service-bus-queues-topics-and-subscriptions"></a><span data-ttu-id="de1f0-103">Filas, tópicos e assinaturas do Barramento de Serviço</span><span class="sxs-lookup"><span data-stu-id="de1f0-103">Service Bus queues, topics, and subscriptions</span></span>

<span data-ttu-id="de1f0-104">O Barramento de Serviço do Microsoft Azure oferece suporte a um conjunto de tecnologias middleware orientado a mensagens, baseado em nuvem, incluindo o serviço de enfileiramento de mensagens confiável e o sistema de mensagens de publicação/assinatura durável.</span><span class="sxs-lookup"><span data-stu-id="de1f0-104">Microsoft Azure Service Bus supports a set of cloud-based, message-oriented middleware technologies including reliable message queuing and durable publish/subscribe messaging.</span></span> <span data-ttu-id="de1f0-105">Esses recursos do sistema de mensagens "agenciado" podem ser considerados como recursos do sistema de mensagens separados que dão suporte a cenários de assinatura de publicação, de desacoplamento temporal e de balanceamento de carga usando a malha do sistema de mensagens do Barramento de Serviço.</span><span class="sxs-lookup"><span data-stu-id="de1f0-105">These "brokered" messaging capabilities can be thought of as decoupled messaging features that support publish-subscribe, temporal decoupling, and load balancing scenarios using the Service Bus messaging fabric.</span></span> <span data-ttu-id="de1f0-106">A comunicação desacoplada tem diversas vantagens; por exemplo, clientes e servidores podem se conectar como necessário e executar as operações deles de forma assíncrona.</span><span class="sxs-lookup"><span data-stu-id="de1f0-106">Decoupled communication has many advantages; for example, clients and servers can connect as needed and perform their operations in an asynchronous fashion.</span></span>

<span data-ttu-id="de1f0-107">As entidades de mensagens que formam o núcleo dos recursos do sistema de mensagens agenciado no Barramento de Serviço são filas, tópicos e assinaturas, e regras/ações.</span><span class="sxs-lookup"><span data-stu-id="de1f0-107">The messaging entities that form the core of the messaging capabilities in Service Bus are queues, topics and subscriptions, and rules/actions.</span></span>

## <a name="queues"></a><span data-ttu-id="de1f0-108">Filas</span><span class="sxs-lookup"><span data-stu-id="de1f0-108">Queues</span></span>

<span data-ttu-id="de1f0-109">As filas oferecem entrega de mensagem do tipo *FIFO (primeiro a entrar, primeiro a sair)* para um ou mais consumidores concorrentes.</span><span class="sxs-lookup"><span data-stu-id="de1f0-109">Queues offer *First In, First Out* (FIFO) message delivery to one or more competing consumers.</span></span> <span data-ttu-id="de1f0-110">Ou seja, normalmente espera-se que as mensagens sejam recebidas e processadas pelos receptores na ordem em que foram adicionadas à fila, sendo que cada mensagem é recebida e processada por apenas um consumidor de mensagem.</span><span class="sxs-lookup"><span data-stu-id="de1f0-110">That is, messages are typically expected to be received and processed by the receivers in the order in which they were added to the queue, and each message is received and processed by only one message consumer.</span></span> <span data-ttu-id="de1f0-111">Um dos principais benefícios da utilização de filas é obter o “desacoplamento temporal” de componentes do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="de1f0-111">A key benefit of using queues is to achieve "temporal decoupling" of application components.</span></span> <span data-ttu-id="de1f0-112">Em outras palavras, os produtores (remetentes) e os consumidores (receptores) não precisam enviar e receber mensagens ao mesmo tempo porque as mensagens são armazenadas de forma duradoura na fila.</span><span class="sxs-lookup"><span data-stu-id="de1f0-112">In other words, the producers (senders) and consumers (receivers) do not have to be sending and receiving messages at the same time, because messages are stored durably in the queue.</span></span> <span data-ttu-id="de1f0-113">Além disso, o produtor não precisa esperar por uma resposta do consumidor a fim de continuar a processar e enviar mensagens.</span><span class="sxs-lookup"><span data-stu-id="de1f0-113">Furthermore, the producer does not have to wait for a reply from the consumer in order to continue to process and send messages.</span></span>

<span data-ttu-id="de1f0-114">Um benefício relacionado é o “nivelamento de carga”, que permite que produtores e consumidores enviem e recebam mensagens em taxas diferentes.</span><span class="sxs-lookup"><span data-stu-id="de1f0-114">A related benefit is "load leveling," which enables producers and consumers to send and receive messages at different rates.</span></span> <span data-ttu-id="de1f0-115">Em muitos aplicativos, a carga do sistema varia ao longo do tempo; no entanto, o tempo de processamento necessário para cada unidade de trabalho normalmente é constante.</span><span class="sxs-lookup"><span data-stu-id="de1f0-115">In many applications, the system load varies over time; however, the processing time required for each unit of work is typically constant.</span></span> <span data-ttu-id="de1f0-116">A intermediação de produtores e de consumidores de mensagem com uma fila significa que o aplicativo que está consumindo só precisa ser provisionado para poder lidar com a carga média em vez da carga de pico.</span><span class="sxs-lookup"><span data-stu-id="de1f0-116">Intermediating message producers and consumers with a queue means that the consuming application only has to be provisioned to be able to handle average load instead of peak load.</span></span> <span data-ttu-id="de1f0-117">A profundidade da fila aumentará e diminuirá conforme a carga de entrada variar.</span><span class="sxs-lookup"><span data-stu-id="de1f0-117">The depth of the queue grows and contracts as the incoming load varies.</span></span> <span data-ttu-id="de1f0-118">Isso economiza dinheiro diretamente em termos da quantidade de infraestrutura necessária para atender à carga do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="de1f0-118">This directly saves money with regard to the amount of infrastructure required to service the application load.</span></span> <span data-ttu-id="de1f0-119">À medida que a carga aumenta, mais processos de trabalho poderão ser adicionados à leitura da fila.</span><span class="sxs-lookup"><span data-stu-id="de1f0-119">As the load increases, more worker processes can be added to read from the queue.</span></span> <span data-ttu-id="de1f0-120">Cada mensagem é processada por apenas umdos processos de trabalho.</span><span class="sxs-lookup"><span data-stu-id="de1f0-120">Each message is processed by only one of the worker processes.</span></span> <span data-ttu-id="de1f0-121">Além disso, esse balanceamento de carga baseado em pull permite o uso ideal dos computadores de trabalho, mesmo se os computadores de trabalho forem diferentes em relação à capacidade de processamento, já que eles receberá as mensagens por pull em sua própria taxa máxima.</span><span class="sxs-lookup"><span data-stu-id="de1f0-121">Furthermore, this pull-based load balancing allows for optimum use of the worker computers even if the worker computers differ with regard to processing power, as they will pull messages at their own maximum rate.</span></span> <span data-ttu-id="de1f0-122">Esse padrão geralmente é chamado de padrão de "consumidor concorrente".</span><span class="sxs-lookup"><span data-stu-id="de1f0-122">This pattern is often termed the "competing consumer" pattern.</span></span>

<span data-ttu-id="de1f0-123">A utilização de filas para intermediar entre produtores e consumidores oferece um acoplamento flexível inerente entre os componentes.</span><span class="sxs-lookup"><span data-stu-id="de1f0-123">Using queues to intermediate between message producers and consumers provides an inherent loose coupling between the components.</span></span> <span data-ttu-id="de1f0-124">Como produtores e consumidores não têm conhecimento uns dos outros, um consumidor poderá ser atualizado sem afetar o produtor.</span><span class="sxs-lookup"><span data-stu-id="de1f0-124">Because producers and consumers are not aware of each other, a consumer can be upgraded without having any effect on the producer.</span></span>

<span data-ttu-id="de1f0-125">A criação de uma fila é um processo de várias etapas.</span><span class="sxs-lookup"><span data-stu-id="de1f0-125">Creating a queue is a multi-step process.</span></span> <span data-ttu-id="de1f0-126">Você executa operações de gerenciamento para entidades de mensagens do Barramento de Serviço (filas e tópicos) por meio da classe [Microsoft.ServiceBus.NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager#microsoft_servicebus_namespacemanager), que é construída por meio do fornecimento do endereço básico do namespace do Barramento de Serviço e das credenciais do usuário.</span><span class="sxs-lookup"><span data-stu-id="de1f0-126">You perform management operations for Service Bus messaging entities (both queues and topics) via the [Microsoft.ServiceBus.NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager#microsoft_servicebus_namespacemanager) class, which is constructed by supplying the base address of the Service Bus namespace and the user credentials.</span></span> <span data-ttu-id="de1f0-127">O [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager#microsoft_servicebus_namespacemanager) oferece métodos para a criação, a enumeração e a exclusão de entidades do sistema de mensagens.</span><span class="sxs-lookup"><span data-stu-id="de1f0-127">[NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager#microsoft_servicebus_namespacemanager) provides methods to create, enumerate and delete messaging entities.</span></span> <span data-ttu-id="de1f0-128">Após a criação de um objeto [Microsoft.ServiceBus.TokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider#microsoft_servicebus_tokenprovider) desde o nome e a chave SAS, e de um objeto de gerenciamento de namespace de serviço, você poderá usar o método [Microsoft.ServiceBus.NamespaceManager.CreateQueue](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateQueue_System_String_) para criar a fila.</span><span class="sxs-lookup"><span data-stu-id="de1f0-128">After creating a [Microsoft.ServiceBus.TokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider#microsoft_servicebus_tokenprovider) object from the SAS name and key, and a service namespace management object, you can use the [Microsoft.ServiceBus.NamespaceManager.CreateQueue](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateQueue_System_String_) method to create the queue.</span></span> <span data-ttu-id="de1f0-129">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="de1f0-129">For example:</span></span>

```csharp
// Create management credentials
TokenProvider credentials = TokenProvider.CreateSharedAccessSignatureTokenProvider(sasKeyName,sasKeyValue);
// Create namespace client
NamespaceManager namespaceClient = new NamespaceManager(ServiceBusEnvironment.CreateServiceUri("sb", ServiceNamespace, string.Empty), credentials);
```

<span data-ttu-id="de1f0-130">Você pode criar um objeto de fila e uma fábrica do sistema de mensagens com o URI do Barramento de Serviço como um argumento.</span><span class="sxs-lookup"><span data-stu-id="de1f0-130">You can then create a queue object and a messaging factory with the Service Bus URI as an argument.</span></span> <span data-ttu-id="de1f0-131">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="de1f0-131">For example:</span></span>

```csharp
QueueDescription myQueue;
myQueue = namespaceClient.CreateQueue("TestQueue");
MessagingFactory factory = MessagingFactory.Create(ServiceBusEnvironment.CreateServiceUri("sb", ServiceNamespace, string.Empty), credentials); 
QueueClient myQueueClient = factory.CreateQueueClient("TestQueue");
```

<span data-ttu-id="de1f0-132">Em seguida, você poderá enviar mensagens para a fila.</span><span class="sxs-lookup"><span data-stu-id="de1f0-132">You can then send messages to the queue.</span></span> <span data-ttu-id="de1f0-133">Por exemplo, se você tiver uma lista de mensagens agenciadas chamada `MessageList`, o código será semelhante a este:</span><span class="sxs-lookup"><span data-stu-id="de1f0-133">For example, if you have a list of brokered messages called `MessageList`, the code appears similar to the following:</span></span>

```csharp
for (int count = 0; count < 6; count++)
{
    var issue = MessageList[count];
    issue.Label = issue.Properties["IssueTitle"].ToString();
    myQueueClient.Send(issue);
}
```

<span data-ttu-id="de1f0-134">Você recebe mensagens da fila como a seguir:</span><span class="sxs-lookup"><span data-stu-id="de1f0-134">You then receive messages from the queue as follows:</span></span>

```csharp
while ((message = myQueueClient.Receive(new TimeSpan(hours: 0, minutes: 0, seconds: 5))) != null)
    {
        Console.WriteLine(string.Format("Message received: {0}, {1}, {2}", message.SequenceNumber, message.Label, message.MessageId));
        message.Complete();

        Console.WriteLine("Processing message (sleeping...)");
        Thread.Sleep(1000);
    }
```

<span data-ttu-id="de1f0-135">No modo [ReceiveAndDelete](/dotnet/api/microsoft.servicebus.messaging.receivemode), a operação de recebimento é única; ou seja, quando o Barramento de Serviço receber a solicitação, marcará a mensagem como sendo consumida e a retornará ao aplicativo.</span><span class="sxs-lookup"><span data-stu-id="de1f0-135">In the [ReceiveAndDelete](/dotnet/api/microsoft.servicebus.messaging.receivemode) mode, the receive operation is single-shot; that is, when Service Bus receives the request, it marks the message as being consumed and returns it to the application.</span></span> <span data-ttu-id="de1f0-136">O modo **ReceiveAndDelete** é o modelo mais simples e funciona melhor em cenários nos quais o aplicativo pode tolerar o não processamento de uma mensagem em caso de falha.</span><span class="sxs-lookup"><span data-stu-id="de1f0-136">**ReceiveAndDelete** mode is the simplest model and works best for scenarios in which the application can tolerate not processing a message in the event of a failure.</span></span> <span data-ttu-id="de1f0-137">Para compreender isso, considere um cenário no qual o consumidor emite a solicitação de recebimento e então falha antes de processá-la.</span><span class="sxs-lookup"><span data-stu-id="de1f0-137">To understand this, consider a scenario in which the consumer issues the receive request and then crashes before processing it.</span></span> <span data-ttu-id="de1f0-138">Como o Barramento de Serviço marca a mensagem como sendo consumida, quando o aplicativo for reiniciado e começar a consumir mensagens novamente, ele terá perdido a mensagem consumida antes da falha.</span><span class="sxs-lookup"><span data-stu-id="de1f0-138">Because Service Bus marks the message as being consumed, when the application restarts and begins consuming messages again, it will have missed the message that was consumed prior to the crash.</span></span>

<span data-ttu-id="de1f0-139">No modo [PeekLock](/dotnet/api/microsoft.servicebus.messaging.receivemode), a operação de recebimento se torna uma operação de dois estágios, o que possibilita o suporte aos aplicativos que não podem tolerar mensagens ausentes.</span><span class="sxs-lookup"><span data-stu-id="de1f0-139">In [PeekLock](/dotnet/api/microsoft.servicebus.messaging.receivemode) mode, the receive operation becomes two-stage, which makes it possible to support applications that cannot tolerate missing messages.</span></span> <span data-ttu-id="de1f0-140">Quando o Barramento de Serviço recebe a solicitação, ele localiza a próxima mensagem a ser consumida, bloqueia-a para evitar que outros consumidores a recebam e, em seguida, retorna-a para o aplicativo.</span><span class="sxs-lookup"><span data-stu-id="de1f0-140">When Service Bus receives the request, it finds the next message to be consumed, locks it to prevent other consumers from receiving it, and then returns it to the application.</span></span> <span data-ttu-id="de1f0-141">Depois que o aplicativo conclui o processamento da mensagem (ou a armazena de forma segura para processamento futuro), ele conclui a segunda etapa do processo de recebimento chamando [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) na mensagem recebida.</span><span class="sxs-lookup"><span data-stu-id="de1f0-141">After the application finishes processing the message (or stores it reliably for future processing), it completes the second stage of the receive process by calling [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) on the received message.</span></span> <span data-ttu-id="de1f0-142">Quando o Barramento de Serviço vê a chamada a **Complete**, marca a mensagem como sendo consumida.</span><span class="sxs-lookup"><span data-stu-id="de1f0-142">When Service Bus sees the **Complete** call, it marks the message as being consumed.</span></span>

<span data-ttu-id="de1f0-143">Se o aplicativo receptor não for capaz de processar a mensagem por algum motivo, ele chamará o método [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) na mensagem recebida (em vez do método [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete)).</span><span class="sxs-lookup"><span data-stu-id="de1f0-143">If the application is unable to process the message for some reason, it can call the [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) method on the received message (instead of [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete)).</span></span> <span data-ttu-id="de1f0-144">Isso permitirá ,que o Barramento de Serviço desbloqueie a mensagem na fila e disponibilize-a para que ela possa ser recebida novamente pelo mesmo consumidor ou por outro consumidor concorrente.</span><span class="sxs-lookup"><span data-stu-id="de1f0-144">This enables Service Bus to unlock the message and make it available to be received again, either by the same consumer or by another competing consumer.</span></span> <span data-ttu-id="de1f0-145">Em segundo lugar, há um tempo limite associado a um bloqueio e, se houver falha no processamento da mensagem pelo aplicativo da expiração do tempo limite de bloqueio (por exemplo, se o aplicativo travar), o Barramento de Serviço desbloqueará a mensagem e a disponibilizará para ser recebida novamente (basicamente executando uma operação [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) por padrão).</span><span class="sxs-lookup"><span data-stu-id="de1f0-145">Secondly, there is a timeout associated with the lock and if the application fails to process the message before the lock timeout expires (for example, if the application crashes), then Service Bus unlocks the message and makes it available to be received again (essentially performing an [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) operation by default).</span></span>

<span data-ttu-id="de1f0-146">Observe que, se houver falha do aplicativo após o processamento da mensagem, mas antes de a solicitação **Complete** ser emitida, a mensagem será entregue novamente ao aplicativo quando ele reiniciar.</span><span class="sxs-lookup"><span data-stu-id="de1f0-146">Note that in the event that the application crashes after processing the message, but before the **Complete** request is issued, the message is redelivered to the application when it restarts.</span></span> <span data-ttu-id="de1f0-147">Com frequência, isso é chamado de processamento *Pelo menos uma vez*; ou seja, cada mensagem é processada pelo menos uma vez.</span><span class="sxs-lookup"><span data-stu-id="de1f0-147">This is often called *At Least Once* processing; that is, each message is processed at least once.</span></span> <span data-ttu-id="de1f0-148">No entanto, em determinadas situações a mesma mensagem poderá ser entregue novamente.</span><span class="sxs-lookup"><span data-stu-id="de1f0-148">However, in certain situations the same message may be redelivered.</span></span> <span data-ttu-id="de1f0-149">Se o cenário não tolerar processamento duplicado, será necessária uma lógica adicional no aplicativo para detectar duplicadas que poderão ser obtidas com base na propriedade **MessageId** da mensagem, que permanece constante nas tentativas da entrega.</span><span class="sxs-lookup"><span data-stu-id="de1f0-149">If the scenario cannot tolerate duplicate processing, then additional logic is required in the application to detect duplicates which can be achieved based upon the **MessageId** property of the message, which remains constant across delivery attempts.</span></span> <span data-ttu-id="de1f0-150">Isso é conhecido como processamento *Exatamente Uma Vez*.</span><span class="sxs-lookup"><span data-stu-id="de1f0-150">This is known as *Exactly Once* processing.</span></span>

## <a name="topics-and-subscriptions"></a><span data-ttu-id="de1f0-151">Tópicos e assinaturas</span><span class="sxs-lookup"><span data-stu-id="de1f0-151">Topics and subscriptions</span></span>
<span data-ttu-id="de1f0-152">Em contraste com as filas, em que cada mensagem é processada por um único consumidor, *tópicos* e *assinaturas* fornecem uma forma de comunicação de um para muitos em um padrão de *publicação/assinatura*.</span><span class="sxs-lookup"><span data-stu-id="de1f0-152">In contrast to queues, in which each message is processed by a single consumer, *topics* and *subscriptions* provide a one-to-many form of communication, in a *publish/subscribe* pattern.</span></span> <span data-ttu-id="de1f0-153">Útil para o dimensionamento para grandes números de destinatários, cada mensagem publicada é disponibilizada para cada assinatura registrada com o tópico.</span><span class="sxs-lookup"><span data-stu-id="de1f0-153">Useful for scaling to very large numbers of recipients, each published message is made available to each subscription registered with the topic.</span></span> <span data-ttu-id="de1f0-154">As mensagens são enviadas a um tópico e entregues a uma ou mais assinaturas associadas, dependendo das regras de filtro que puderem ser definidas por assinatura.</span><span class="sxs-lookup"><span data-stu-id="de1f0-154">Messages are sent to a topic and delivered to one or more associated subscriptions, depending on filter rules that can be set on a per-subscription basis.</span></span> <span data-ttu-id="de1f0-155">As assinaturas podem usar filtros adicionais para restringir as mensagens que desejam receber.</span><span class="sxs-lookup"><span data-stu-id="de1f0-155">The subscriptions can use additional filters to restrict the messages that they want to receive.</span></span> <span data-ttu-id="de1f0-156">As mensagens são enviadas a um tópico da mesma forma como são enviadas para uma fila, mas as mensagens não são recebidas diretamente do tópico.</span><span class="sxs-lookup"><span data-stu-id="de1f0-156">Messages are sent to a topic in the same way they are sent to a queue, but messages are not received from the topic directly.</span></span> <span data-ttu-id="de1f0-157">Em vez disso, elas são recebidas de assinaturas.</span><span class="sxs-lookup"><span data-stu-id="de1f0-157">Instead, they are received from subscriptions.</span></span> <span data-ttu-id="de1f0-158">Uma assinatura de tópico é semelhante a uma fila virtual que recebe cópias das mensagens enviadas para o tópico.</span><span class="sxs-lookup"><span data-stu-id="de1f0-158">A topic subscription resembles a virtual queue that receives copies of the messages that are sent to the topic.</span></span> <span data-ttu-id="de1f0-159">As mensagens são recebidas de uma assinatura de forma idêntica à maneira como são recebidas de uma fila.</span><span class="sxs-lookup"><span data-stu-id="de1f0-159">Messages are received from a subscription identically to the way they are received from a queue.</span></span>

<span data-ttu-id="de1f0-160">Por comparação, a funcionalidade de envio de mensagens de uma fila é diretamente mapeada para um tópico e sua funcionalidade de recebimento de mensagens é mapeada para uma assinatura.</span><span class="sxs-lookup"><span data-stu-id="de1f0-160">By way of comparison, the message-sending functionality of a queue maps directly to a topic and its message-receiving functionality maps to a subscription.</span></span> <span data-ttu-id="de1f0-161">Entre outras coisas, isso significa que as assinaturas dão suporte aos mesmos padrões descritos anteriormente nesta seção em relação a filas: consumidor concorrente, desacoplamento temporal, nivelamento de carga e balanceamento de carga.</span><span class="sxs-lookup"><span data-stu-id="de1f0-161">Among other things, this means that subscriptions support the same patterns described earlier in this section with regard to queues: competing consumer, temporal decoupling, load leveling, and load balancing.</span></span>

<span data-ttu-id="de1f0-162">A criação de um tópico é semelhante à criação de uma fila, como mostrado no exemplo da seção anterior.</span><span class="sxs-lookup"><span data-stu-id="de1f0-162">Creating a topic is similar to creating a queue, as shown in the example in the previous section.</span></span> <span data-ttu-id="de1f0-163">Crie o URI do serviço e, em seguida, use a classe [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) para criar o cliente de namespace.</span><span class="sxs-lookup"><span data-stu-id="de1f0-163">Create the service URI, and then use the [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) class to create the namespace client.</span></span> <span data-ttu-id="de1f0-164">Você pode criar um tópico usando o método [CreateTopic](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateTopic_System_String_).</span><span class="sxs-lookup"><span data-stu-id="de1f0-164">You can then create a topic using the [CreateTopic](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateTopic_System_String_) method.</span></span> <span data-ttu-id="de1f0-165">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="de1f0-165">For example:</span></span>

```csharp
TopicDescription dataCollectionTopic = namespaceClient.CreateTopic("DataCollectionTopic");
```

<span data-ttu-id="de1f0-166">Em seguida, adicione assinaturas como desejado:</span><span class="sxs-lookup"><span data-stu-id="de1f0-166">Next, add subscriptions as desired:</span></span>

```csharp
SubscriptionDescription myAgentSubscription = namespaceClient.CreateSubscription(myTopic.Path, "Inventory");
SubscriptionDescription myAuditSubscription = namespaceClient.CreateSubscription(myTopic.Path, "Dashboard");
```

<span data-ttu-id="de1f0-167">Então, você poderá criar um cliente de tópico.</span><span class="sxs-lookup"><span data-stu-id="de1f0-167">You can then create a topic client.</span></span> <span data-ttu-id="de1f0-168">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="de1f0-168">For example:</span></span>

```csharp
MessagingFactory factory = MessagingFactory.Create(serviceUri, tokenProvider);
TopicClient myTopicClient = factory.CreateTopicClient(myTopic.Path)
```

<span data-ttu-id="de1f0-169">Usando o remetente da mensagem, você pode enviar e receber mensagens de e para o tópico, como mostrado na seção anterior.</span><span class="sxs-lookup"><span data-stu-id="de1f0-169">Using the message sender, you can send and receive messages to and from the topic, as shown in the previous section.</span></span> <span data-ttu-id="de1f0-170">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="de1f0-170">For example:</span></span>

```csharp
foreach (BrokeredMessage message in messageList)
{
    myTopicClient.Send(message);
    Console.WriteLine(
    string.Format("Message sent: Id = {0}, Body = {1}", message.MessageId, message.GetBody<string>()));
}
```

<span data-ttu-id="de1f0-171">De forma semelhante ao que acontece às filas, as mensagens são recebidas de uma assinatura usando um objeto [SubscriptionClient](/dotnet/api/microsoft.servicebus.messaging.subscriptionclient) em vez de um objeto [QueueClient](/dotnet/api/microsoft.servicebus.messaging.queueclient).</span><span class="sxs-lookup"><span data-stu-id="de1f0-171">Similar to queues, messages are received from a subscription using a [SubscriptionClient](/dotnet/api/microsoft.servicebus.messaging.subscriptionclient) object instead of a [QueueClient](/dotnet/api/microsoft.servicebus.messaging.queueclient) object.</span></span> <span data-ttu-id="de1f0-172">Crie o cliente de assinatura, passando o nome do tópico, o nome da assinatura e (opcionalmente) o modo de recebimento como parâmetros.</span><span class="sxs-lookup"><span data-stu-id="de1f0-172">Create the subscription client, passing the name of the topic, the name of the subscription, and (optionally) the receive mode as parameters.</span></span> <span data-ttu-id="de1f0-173">Por exemplo, com a assinatura de **Inventory**:</span><span class="sxs-lookup"><span data-stu-id="de1f0-173">For example, with the **Inventory** subscription:</span></span>

```csharp
// Create the subscription client
MessagingFactory factory = MessagingFactory.Create(serviceUri, tokenProvider); 

SubscriptionClient agentSubscriptionClient = factory.CreateSubscriptionClient("IssueTrackingTopic", "Inventory", ReceiveMode.PeekLock);
SubscriptionClient auditSubscriptionClient = factory.CreateSubscriptionClient("IssueTrackingTopic", "Dashboard", ReceiveMode.ReceiveAndDelete); 

while ((message = agentSubscriptionClient.Receive(TimeSpan.FromSeconds(5))) != null)
{
    Console.WriteLine("\nReceiving message from Inventory...");
    Console.WriteLine(string.Format("Message received: Id = {0}, Body = {1}", message.MessageId, message.GetBody<string>()));
    message.Complete();
}          

// Create a receiver using ReceiveAndDelete mode
while ((message = auditSubscriptionClient.Receive(TimeSpan.FromSeconds(5))) != null)
{
    Console.WriteLine("\nReceiving message from Dashboard...");
    Console.WriteLine(string.Format("Message received: Id = {0}, Body = {1}", message.MessageId, message.GetBody<string>()));
}
```

### <a name="rules-and-actions"></a><span data-ttu-id="de1f0-174">Regras e ações</span><span class="sxs-lookup"><span data-stu-id="de1f0-174">Rules and actions</span></span>
<span data-ttu-id="de1f0-175">Em muitos cenários, as mensagens com características específicas precisam ser processadas de maneiras diferentes.</span><span class="sxs-lookup"><span data-stu-id="de1f0-175">In many scenarios, messages that have specific characteristics must be processed in different ways.</span></span> <span data-ttu-id="de1f0-176">Para habilitar isso, você pode configurar assinaturas para localizar as mensagens com as propriedades desejáveis e, em seguida, realizar determinadas modificações nessas propriedades.</span><span class="sxs-lookup"><span data-stu-id="de1f0-176">To enable this, you can configure subscriptions to find messages that have desired properties and then perform certain modifications to those properties.</span></span> <span data-ttu-id="de1f0-177">Embora as assinaturas do Barramento de Serviço vejam todas as mensagens enviadas para o tópico, você só poderá copiar um subconjunto dessas mensagens para a fila de assinatura virtual.</span><span class="sxs-lookup"><span data-stu-id="de1f0-177">While Service Bus subscriptions see all messages sent to the topic, you can only copy a subset of those messages to the virtual subscription queue.</span></span> <span data-ttu-id="de1f0-178">Isso é feito usando filtros de assinatura.</span><span class="sxs-lookup"><span data-stu-id="de1f0-178">This is accomplished using subscription filters.</span></span> <span data-ttu-id="de1f0-179">Tais modificações são chamadas de *ações de filtro*.</span><span class="sxs-lookup"><span data-stu-id="de1f0-179">Such modifications are called *filter actions*.</span></span> <span data-ttu-id="de1f0-180">Quando uma assinatura for criada, você poderá fornecer uma expressão de filtro que funcione nas propriedades da mensagem, as propriedades do sistema (por exemplo, **Label**) e as propriedades personalizadas do aplicativo (por exemplo, **StoreName**). A expressão de filtro SQL é opcional neste caso; sem uma expressão de filtro SQL, qualquer ação de filtro definida em uma assinatura será executada em todas as mensagens para essa assinatura.</span><span class="sxs-lookup"><span data-stu-id="de1f0-180">When a subscription is created, you can supply a filter expression that operates on the properties of the message, both the system properties (for example, **Label**) and custom application properties (for example, **StoreName**.) The SQL filter expression is optional in this case; without a SQL filter expression, any filter action defined on a subscription will be performed on all the messages for that subscription.</span></span>

<span data-ttu-id="de1f0-181">Usando o exemplo anterior, para filtrar as mensagens que venham apenas de **Store1**, você deverá criar a assinatura de Painel da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="de1f0-181">Using the previous example, to filter messages coming only from **Store1**, you would create the Dashboard subscription as follows:</span></span>

```csharp
namespaceManager.CreateSubscription("IssueTrackingTopic", "Dashboard", new SqlFilter("StoreName = 'Store1'"));
```

<span data-ttu-id="de1f0-182">Com esse filtro de assinatura ativado, somente as mensagens com a propriedade `StoreName` definida como `Store1` são copiadas para a fila virtual para a assinatura de `Dashboard`.</span><span class="sxs-lookup"><span data-stu-id="de1f0-182">With this subscription filter in place, only messages that have the `StoreName` property set to `Store1` are copied to the virtual queue for the `Dashboard` subscription.</span></span>

<span data-ttu-id="de1f0-183">Para saber mais sobre possíveis valores de filtro, consulte a documentação das classes [SqlFilter](/dotnet/api/microsoft.servicebus.messaging.sqlfilter) e [SqlRuleAction](/dotnet/api/microsoft.servicebus.messaging.sqlruleaction).</span><span class="sxs-lookup"><span data-stu-id="de1f0-183">For more information about possible filter values, see the documentation for the [SqlFilter](/dotnet/api/microsoft.servicebus.messaging.sqlfilter) and [SqlRuleAction](/dotnet/api/microsoft.servicebus.messaging.sqlruleaction) classes.</span></span> <span data-ttu-id="de1f0-184">Além disso, veja os exemplos [Brokered Messaging: Advanced Filters (Sistema de mensagens agenciado: filtros avançados)](http://code.msdn.microsoft.com/Brokered-Messaging-6b0d2749) e [Topic Filters (Filtros do tópico)](https://github.com/Azure-Samples/azure-servicebus-messaging-samples/tree/master/TopicFilters).</span><span class="sxs-lookup"><span data-stu-id="de1f0-184">Also, see the [Brokered Messaging: Advanced Filters](http://code.msdn.microsoft.com/Brokered-Messaging-6b0d2749) and [Topic Filters](https://github.com/Azure-Samples/azure-servicebus-messaging-samples/tree/master/TopicFilters) samples.</span></span>

## <a name="next-steps"></a><span data-ttu-id="de1f0-185">Próximas etapas</span><span class="sxs-lookup"><span data-stu-id="de1f0-185">Next steps</span></span>
<span data-ttu-id="de1f0-186">Consulte os tópicos avançados a seguir para saber mais e obter exemplos de como usar o sistema de mensagens agenciado do Barramento de Serviço.</span><span class="sxs-lookup"><span data-stu-id="de1f0-186">See the following advanced topics for more information and examples of using Service Bus messaging.</span></span>

* [<span data-ttu-id="de1f0-187">Visão geral de mensagens do Barramento de Serviço</span><span class="sxs-lookup"><span data-stu-id="de1f0-187">Service Bus messaging overview</span></span>](service-bus-messaging-overview.md)
* [<span data-ttu-id="de1f0-188">Tutorial do .NET do sistema de mensagens agenciado do Barramento de Serviço</span><span class="sxs-lookup"><span data-stu-id="de1f0-188">Service Bus brokered messaging .NET tutorial</span></span>](service-bus-brokered-tutorial-dotnet.md)
* [<span data-ttu-id="de1f0-189">Tutorial REST do sistema de mensagens agenciado do Barramento de Serviço</span><span class="sxs-lookup"><span data-stu-id="de1f0-189">Service Bus brokered messaging REST tutorial</span></span>](service-bus-brokered-tutorial-rest.md)
* [<span data-ttu-id="de1f0-190">Exemplo de filtros do tópico</span><span class="sxs-lookup"><span data-stu-id="de1f0-190">Topic Filters sample </span></span>](https://github.com/Azure/azure-service-bus/tree/master/samples/DotNet/Microsoft.ServiceBus.Messaging/TopicFilters)
* [<span data-ttu-id="de1f0-191">Sistema de mensagens agenciado: filtros avançados</span><span class="sxs-lookup"><span data-stu-id="de1f0-191">Brokered Messaging: Advanced Filters sample</span></span>](http://code.msdn.microsoft.com/Brokered-Messaging-6b0d2749)


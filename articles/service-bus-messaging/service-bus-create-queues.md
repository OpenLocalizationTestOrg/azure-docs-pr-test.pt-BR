---
title: "Criar aplicativos que usam as filas do Barramento de Serviço do Azure | Microsoft Docs"
description: "Como gravar um aplicativo simples baseado em filas que usa o Barramento de Serviço do Azure."
services: service-bus-messaging
documentationcenter: na
author: sethmanheim
manager: timlt
editor: 
ms.assetid: 754d91b3-1426-405e-84b4-fd36d65b114a
ms.service: service-bus-messaging
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 08/07/2017
ms.author: sethm
ms.openlocfilehash: 419caff7e8ceeb419c89a2ef9a6614c1accf3e52
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/18/2017
---
# <a name="create-applications-that-use-service-bus-queues"></a><span data-ttu-id="44f8f-103">Criar aplicativos que usem as filas do Barramento de Serviço</span><span class="sxs-lookup"><span data-stu-id="44f8f-103">Create applications that use Service Bus queues</span></span>
<span data-ttu-id="44f8f-104">Este tópico descreve as filas do Barramento de Serviço e mostra como gravar um aplicativo simples baseado em filas que usa o Barramento de Serviço.</span><span class="sxs-lookup"><span data-stu-id="44f8f-104">This topic describes Service Bus queues and shows how to write a simple queue-based application that uses Service Bus.</span></span>

<span data-ttu-id="44f8f-105">Considere um cenário do mundo de varejo no qual os dados de vendas de terminais de PDV (Ponto de Venda) individuais devem ser roteados para um sistema de gerenciamento de estoque que usa esses dados para determinar quando o estoque deverá ser reabastecido.</span><span class="sxs-lookup"><span data-stu-id="44f8f-105">Consider a scenario from the world of retail in which sales data from individual Point-of-Sale (POS) terminals must be routed to an inventory management system that uses the data to determine when stock has to be replenished.</span></span> <span data-ttu-id="44f8f-106">Esta solução usa o sistema de mensagens do Barramento de Serviço para a comunicação entre os terminais e o sistema de gerenciamento de estoque, como ilustrado na figura a seguir:</span><span class="sxs-lookup"><span data-stu-id="44f8f-106">This solution uses Service Bus messaging for the communication between the terminals and the inventory management system, as illustrated in the following figure:</span></span>

![Filas de Barramento de Serviço imagem 1](./media/service-bus-create-queues/IC657161.gif)

<span data-ttu-id="44f8f-108">Cada terminal de PDV reporta seus dados de vendas enviando mensagens para a **DataCollectionQueue**.</span><span class="sxs-lookup"><span data-stu-id="44f8f-108">Each POS terminal reports its sales data by sending messages to the **DataCollectionQueue**.</span></span> <span data-ttu-id="44f8f-109">Essas mensagens permanecerão nessa fila até que sejam recuperadas pelo sistema de gerenciamento de estoque.</span><span class="sxs-lookup"><span data-stu-id="44f8f-109">These messages remain in this queue until they are retrieved by the inventory management system.</span></span> <span data-ttu-id="44f8f-110">Geralmente, esse padrão é chamado de *mensagens assíncronas*, porque o terminal de PDV não precisa esperar por uma resposta do sistema de gerenciamento de estoque para continuar o processamento.</span><span class="sxs-lookup"><span data-stu-id="44f8f-110">This pattern is often termed *asynchronous messaging*, because the POS terminal does not have to wait for a reply from the inventory management system to continue processing.</span></span>

## <a name="why-queuing"></a><span data-ttu-id="44f8f-111">Por que usar filas?</span><span class="sxs-lookup"><span data-stu-id="44f8f-111">Why queuing?</span></span>
<span data-ttu-id="44f8f-112">Antes de examinarmos o código que é necessário para configurar este aplicativo, considere as vantagens de usar uma fila neste cenário em vez de ter os terminais de PDV se comunicando diretamente (de forma síncrona) com o sistema de gerenciamento de estoque.</span><span class="sxs-lookup"><span data-stu-id="44f8f-112">Before we look at the code that is required to set up this application, consider the advantages of using a queue in this scenario instead of having the POS terminals talk directly (synchronously) to the inventory management system.</span></span>

### <a name="temporal-decoupling"></a><span data-ttu-id="44f8f-113">Desacoplamento temporal</span><span class="sxs-lookup"><span data-stu-id="44f8f-113">Temporal decoupling</span></span>
<span data-ttu-id="44f8f-114">Com o padrão de mensagens assíncrono, os produtores e consumidores não precisam estar online ao mesmo tempo.</span><span class="sxs-lookup"><span data-stu-id="44f8f-114">With the asynchronous messaging pattern, producers and consumers do not have to be online at the same time.</span></span> <span data-ttu-id="44f8f-115">A infraestrutura do sistema de mensagens armazena mensagens até que a parte consumidora esteja pronta para recebê-las.</span><span class="sxs-lookup"><span data-stu-id="44f8f-115">The messaging infrastructure reliably stores messages until the consuming party is ready to receive them.</span></span> <span data-ttu-id="44f8f-116">Isso significa que os componentes do aplicativo distribuído podem ser desconectados, voluntariamente, para manutenção, por exemplo, ou devido a uma falha de componente, sem afetar o sistema inteiro.</span><span class="sxs-lookup"><span data-stu-id="44f8f-116">This means the components of the distributed application can be disconnected, either voluntarily; for example, for maintenance, or due to a component crash, without affecting the whole system.</span></span> <span data-ttu-id="44f8f-117">Além disso, o aplicativo de consumo só precisará ficar online durante determinados momentos do dia.</span><span class="sxs-lookup"><span data-stu-id="44f8f-117">Furthermore, the consuming application may only have to be online during certain times of the day.</span></span> <span data-ttu-id="44f8f-118">Por exemplo, neste cenário de varejo, é possível que o sistema de gerenciamento de estoque só precise ficar online no final do dia útil.</span><span class="sxs-lookup"><span data-stu-id="44f8f-118">For example, in this retail scenario, the inventory management system may only have to come online after the end of the business day.</span></span>

### <a name="load-leveling"></a><span data-ttu-id="44f8f-119">Nivelamento de carga</span><span class="sxs-lookup"><span data-stu-id="44f8f-119">Load leveling</span></span>
<span data-ttu-id="44f8f-120">Em muitos aplicativos, a carga do sistema varia ao longo do tempo enquanto o tempo de processamento necessário para cada unidade de trabalho é normalmente constante.</span><span class="sxs-lookup"><span data-stu-id="44f8f-120">In many applications system load varies over time, whereas the processing time required for each unit of work is typically constant.</span></span> <span data-ttu-id="44f8f-121">Intermediar produtores de mensagem e consumidores com uma fila significa que o aplicativo de consumo (o trabalho) só precisa ser provisionado para servir uma carga média em vez de uma carga de pico.</span><span class="sxs-lookup"><span data-stu-id="44f8f-121">Intermediating message producers and consumers with a queue means that the consuming application (the worker) only has to be provisioned to service an average load rather than a peak load.</span></span> <span data-ttu-id="44f8f-122">A profundidade da fila crescerá e contrairá conforme a carga de entradavariar.</span><span class="sxs-lookup"><span data-stu-id="44f8f-122">The depth of the queue will grow and contract as the incoming load varies.</span></span> <span data-ttu-id="44f8f-123">Isso economiza dinheiro diretamente em termos da quantidade de infraestrutura necessária para atender à carga do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="44f8f-123">This directly saves money with regard to the amount of infrastructure required to service the application load.</span></span>

![Filas de Barramento de Serviço imagem 2](./media/service-bus-create-queues/IC657162.gif)

### <a name="load-balancing"></a><span data-ttu-id="44f8f-125">Balanceamento de carga</span><span class="sxs-lookup"><span data-stu-id="44f8f-125">Load balancing</span></span>
<span data-ttu-id="44f8f-126">À medida que a carga aumenta, mais processos de trabalho poderão ser adicionados à leitura da fila de trabalho.</span><span class="sxs-lookup"><span data-stu-id="44f8f-126">As the load increases, more worker processes can be added to read from the worker queue.</span></span> <span data-ttu-id="44f8f-127">Cada mensagem é processada por apenas umdos processos de trabalho.</span><span class="sxs-lookup"><span data-stu-id="44f8f-127">Each message is processed by only one of the worker processes.</span></span> <span data-ttu-id="44f8f-128">Além disso, esse balanceamento de carga baseado em pull permite o uso ideal dos computadores de trabalho, mesmo se os computadores de trabalho forem diferentes em relação à capacidade de processamento, já que eles receberão as mensagens por pull em sua própria taxa máxima.</span><span class="sxs-lookup"><span data-stu-id="44f8f-128">Furthermore, this pull-based load balancing allows for optimum usage of the worker computers even if the worker computers differ with regard to processing power, as they will pull messages at their own maximum rate.</span></span> <span data-ttu-id="44f8f-129">Esse padrão geralmente échamado de padrão de consumidor concorrente.</span><span class="sxs-lookup"><span data-stu-id="44f8f-129">This pattern is often termed the competing consumer pattern.</span></span>

![Filas de Barramento de Serviço imagem 3](./media/service-bus-create-queues/IC657163.gif)

### <a name="loose-coupling"></a><span data-ttu-id="44f8f-131">Acoplamento flexível</span><span class="sxs-lookup"><span data-stu-id="44f8f-131">Loose coupling</span></span>
<span data-ttu-id="44f8f-132">A utilização de filas de mensagens para intermediar entre produtores de mensagens e consumidores oferece um acoplamento flexível intrínseco entre os componentes.</span><span class="sxs-lookup"><span data-stu-id="44f8f-132">Using message queuing to intermediate between message producers and consumers provides an intrinsic loose coupling between the components.</span></span> <span data-ttu-id="44f8f-133">Como produtores e consumidores não têm conhecimento uns dos outros, um consumidor poderá ser atualizado sem afetar o produtor.</span><span class="sxs-lookup"><span data-stu-id="44f8f-133">Because producers and consumers are not aware of each other, a consumer can be upgraded without having any effect on the producer.</span></span> <span data-ttu-id="44f8f-134">Além disso, a topologia do sistema de mensagens poderá evoluir sem afetar os pontos de extremidade existentes.</span><span class="sxs-lookup"><span data-stu-id="44f8f-134">Furthermore, the messaging topology can evolve without affecting the existing endpoints.</span></span> <span data-ttu-id="44f8f-135">Discutiremos um pouco mais desse assunto quando falarmos sobre publicação/assinatura.</span><span class="sxs-lookup"><span data-stu-id="44f8f-135">We’ll discuss this more when we talk about publish/subscribe.</span></span>

## <a name="show-me-the-code"></a><span data-ttu-id="44f8f-136">Mostrar-me o código</span><span class="sxs-lookup"><span data-stu-id="44f8f-136">Show me the code</span></span>
<span data-ttu-id="44f8f-137">A seção a seguir mostra como usar o Barramento de Serviço para criar esse aplicativo.</span><span class="sxs-lookup"><span data-stu-id="44f8f-137">The following section shows how to use Service Bus to build this application.</span></span>

### <a name="sign-up-for-an-azure-account"></a><span data-ttu-id="44f8f-138">Inscrever-se em uma conta do Azure</span><span class="sxs-lookup"><span data-stu-id="44f8f-138">Sign up for an Azure account</span></span>
<span data-ttu-id="44f8f-139">Você precisará de uma conta do Azure para começar a trabalhar com o Barramento de Serviço.</span><span class="sxs-lookup"><span data-stu-id="44f8f-139">You’ll need an Azure account in order to start working with Service Bus.</span></span> <span data-ttu-id="44f8f-140">Se você ainda não tiver uma assinatura, poderá se inscrever em uma conta gratuita [aqui](https://azure.microsoft.com/pricing/free-trial/?WT.mc_id=A85619ABF).</span><span class="sxs-lookup"><span data-stu-id="44f8f-140">If you do not already have one, you can sign up for a free account [here](https://azure.microsoft.com/pricing/free-trial/?WT.mc_id=A85619ABF).</span></span>

### <a name="create-a-namespace"></a><span data-ttu-id="44f8f-141">Criar um namespace</span><span class="sxs-lookup"><span data-stu-id="44f8f-141">Create a namespace</span></span>
<span data-ttu-id="44f8f-142">Quando tiver uma assinatura, você poderá [criar um novo namespace](service-bus-create-namespace-portal.md).</span><span class="sxs-lookup"><span data-stu-id="44f8f-142">Once you have a subscription, you can [create a service namespace](service-bus-create-namespace-portal.md).</span></span> <span data-ttu-id="44f8f-143">Cada namespace age como um contêiner de escopo para um conjunto de entidades do Barramento de Serviço.</span><span class="sxs-lookup"><span data-stu-id="44f8f-143">Each namespace acts as a scoping container for a set of Service Bus entities.</span></span> <span data-ttu-id="44f8f-144">Dê um nome exclusivo ao seu novo namespace em todas as contas do Barramento de Serviço.</span><span class="sxs-lookup"><span data-stu-id="44f8f-144">Give your new namespace a unique name across all Service Bus accounts.</span></span> 

### <a name="install-the-nuget-package"></a><span data-ttu-id="44f8f-145">Instalar o pacote NuGet</span><span class="sxs-lookup"><span data-stu-id="44f8f-145">Install the NuGet package</span></span>
<span data-ttu-id="44f8f-146">Para usar o namespace do Barramento de Serviço, um aplicativo deverá fazer referência ao assembly do Barramento de Serviço, especificamente, Microsoft.ServiceBus.dll.</span><span class="sxs-lookup"><span data-stu-id="44f8f-146">To use the Service Bus namespace, an application must reference the Service Bus assembly, specifically Microsoft.ServiceBus.dll.</span></span> <span data-ttu-id="44f8f-147">Esse assembly pode ser encontrado como parte do SDK do Microsoft Azure e o download está disponível na [página de download do SDK do Azure](https://azure.microsoft.com/downloads/).</span><span class="sxs-lookup"><span data-stu-id="44f8f-147">You can find this assembly as part of the Microsoft Azure SDK, and the download is available at the [Azure SDK download page](https://azure.microsoft.com/downloads/).</span></span> <span data-ttu-id="44f8f-148">Entretanto, o [pacote NuGet do Barramento de Serviço](https://www.nuget.org/packages/WindowsAzure.ServiceBus) é a maneira mais fácil de obter a API do Barramento de Serviço e de configurar seu aplicativo com todas as dependências do Barramento de Serviço.</span><span class="sxs-lookup"><span data-stu-id="44f8f-148">However, the [Service Bus NuGet package](https://www.nuget.org/packages/WindowsAzure.ServiceBus) is the easiest way to get the Service Bus API and to configure your application with all of the Service Bus dependencies.</span></span>

### <a name="create-the-queue"></a><span data-ttu-id="44f8f-149">Criar a fila</span><span class="sxs-lookup"><span data-stu-id="44f8f-149">Create the queue</span></span>
<span data-ttu-id="44f8f-150">As operações de gerenciamento para as entidades do sistema de mensagens do Barramento de Serviço (filas e tópicos de publicação/assinatura) são executadas por meio da classe [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager).</span><span class="sxs-lookup"><span data-stu-id="44f8f-150">Management operations for Service Bus messaging entities (queues and publish/subscribe topics) are performed via the [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) class.</span></span> <span data-ttu-id="44f8f-151">O Barramento de Serviço usa um modelo de segurança baseado na [Assinatura de Acesso Compartilhado (SAS)](service-bus-sas.md).</span><span class="sxs-lookup"><span data-stu-id="44f8f-151">Service Bus uses a [Shared Access Signature (SAS)](service-bus-sas.md) based security model.</span></span> <span data-ttu-id="44f8f-152">A classe [TokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider) representa um provedor de token de segurança com métodos de fábrica internos que retornam alguns provedores de token conhecidos.</span><span class="sxs-lookup"><span data-stu-id="44f8f-152">The [TokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider) class represents a security token provider with built-in factory methods returning some well-known token providers.</span></span> <span data-ttu-id="44f8f-153">Usaremos um método [CreateSharedAccessSignatureTokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider#Microsoft_ServiceBus_TokenProvider_CreateSharedAccessSignatureTokenProvider_System_String_) para armazenar as credenciais SAS.</span><span class="sxs-lookup"><span data-stu-id="44f8f-153">We’ll use a [CreateSharedAccessSignatureTokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider#Microsoft_ServiceBus_TokenProvider_CreateSharedAccessSignatureTokenProvider_System_String_) method to hold the SAS credentials.</span></span> <span data-ttu-id="44f8f-154">Assim, a instância de [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) é construída com o endereço base do namespace do Barramento de Serviço e do provedor de token.</span><span class="sxs-lookup"><span data-stu-id="44f8f-154">The [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) instance is then constructed with the base address of the Service Bus namespace and the token provider.</span></span>

<span data-ttu-id="44f8f-155">A classe [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) oferece métodos para criar, enumerar e excluir entidades do sistema de mensagens.</span><span class="sxs-lookup"><span data-stu-id="44f8f-155">The [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) class provides methods to create, enumerate and delete messaging entities.</span></span> <span data-ttu-id="44f8f-156">O código exibido aqui mostra como a instância de [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) é criada e usada para criar a fila **DataCollectionQueue**.</span><span class="sxs-lookup"><span data-stu-id="44f8f-156">The code that is shown here shows how the [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) instance is created and used to create the **DataCollectionQueue** queue.</span></span>

```csharp
Uri uri = ServiceBusEnvironment.CreateServiceUri("sb", 
                "test-blog", string.Empty);
string name = "RootManageSharedAccessKey";
string key = "abcdefghijklmopqrstuvwxyz";

TokenProvider tokenProvider = 
    TokenProvider.CreateSharedAccessSignatureTokenProvider(name, key);
NamespaceManager namespaceManager = 
    new NamespaceManager(uri, tokenProvider);
namespaceManager.CreateQueue("DataCollectionQueue");
```

<span data-ttu-id="44f8f-157">Observe que há sobrecargas do método [CreateQueue](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateQueue_System_String_) que permitem que as propriedades da fila sejam ajustadas.</span><span class="sxs-lookup"><span data-stu-id="44f8f-157">Note that there are overloads of the [CreateQueue](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateQueue_System_String_) method that enable properties of the queue to be tuned.</span></span> <span data-ttu-id="44f8f-158">Por exemplo, você pode definir o valor padrão da vida útil (TTL) para as mensagens enviadas para a fila.</span><span class="sxs-lookup"><span data-stu-id="44f8f-158">For example, you can set the default time-to-live (TTL) value for messages sent to the queue.</span></span>

### <a name="send-messages-to-the-queue"></a><span data-ttu-id="44f8f-159">Enviar mensagens para a fila</span><span class="sxs-lookup"><span data-stu-id="44f8f-159">Send messages to the queue</span></span>
<span data-ttu-id="44f8f-160">Para operações de tempo de execução em entidades do Barramento de Serviço; por exemplo, para enviar e receber mensagens, primeiro um aplicativo deverá criar um objeto [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory).</span><span class="sxs-lookup"><span data-stu-id="44f8f-160">For run-time operations on Service Bus entities; for example, sending and receiving messages, an application must first create a [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) object.</span></span> <span data-ttu-id="44f8f-161">Semelhante à classe [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager), a instância [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) será criada do endereço base do namespace de serviço e do provedor de token.</span><span class="sxs-lookup"><span data-stu-id="44f8f-161">Similar to the [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) class, the [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) instance is created from the base address of the service namespace and the token provider.</span></span>

```csharp
 BrokeredMessage bm = new BrokeredMessage(salesData);
 bm.Label = "SalesReport";
 bm.Properties["StoreName"] = "Redmond";
 bm.Properties["MachineID"] = "POS_1";
```

<span data-ttu-id="44f8f-162">As mensagens enviadas para (e recebidas de) filas de Barramento de Serviço são instâncias da classe [BrokeredMessage](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage) .</span><span class="sxs-lookup"><span data-stu-id="44f8f-162">Messages sent to, and received from Service Bus queues are instances of the [BrokeredMessage](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage) class.</span></span> <span data-ttu-id="44f8f-163">Essa classe consiste em um conjunto de propriedades padrão (como [Label](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Label) e [TimeToLive](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_TimeToLive)), um dicionário usado para manter as propriedades do aplicativo e um corpo de dados de aplicativo arbitrários.</span><span class="sxs-lookup"><span data-stu-id="44f8f-163">This class consists of a set of standard properties (such as [Label](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Label) and [TimeToLive](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_TimeToLive)), a dictionary that is used to hold application properties, and a body of arbitrary application data.</span></span> <span data-ttu-id="44f8f-164">Um aplicativo pode definir o corpo passando qualquer objeto serializável (o exemplo a seguir passa um objeto **SalesData** que representa os dados de vendas do terminal de PDV), que usará o [DataContractSerializer](https://msdn.microsoft.com/library/system.runtime.serialization.datacontractserializer.aspx) para serializar o objeto.</span><span class="sxs-lookup"><span data-stu-id="44f8f-164">An application can set the body by passing in any serializable object (the following example passes in a **SalesData** object that represents the sales data from the POS terminal), which will use the [DataContractSerializer](https://msdn.microsoft.com/library/system.runtime.serialization.datacontractserializer.aspx) to serialize the object.</span></span> <span data-ttu-id="44f8f-165">Como alternativa, poderá ser fornecido um objeto [Stream](https://msdn.microsoft.com/library/system.io.stream.aspx).</span><span class="sxs-lookup"><span data-stu-id="44f8f-165">Alternatively, a [Stream](https://msdn.microsoft.com/library/system.io.stream.aspx) object can be provided.</span></span>

<span data-ttu-id="44f8f-166">A maneira mais fácil de enviar mensagens para uma determinada fila, no nosso caso, **DataCollectionQueue**, é usar [CreateMessageSender](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageSender_System_String_) para criar um objeto [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) diretamente da instância de [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory).</span><span class="sxs-lookup"><span data-stu-id="44f8f-166">The easiest way to send messages to a given queue, in our case the **DataCollectionQueue**, is to use [CreateMessageSender](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageSender_System_String_) to create a [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) object directly from the [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) instance.</span></span>

```csharp
MessageSender sender = factory.CreateMessageSender("DataCollectionQueue");
sender.Send(bm);
```

### <a name="receiving-messages-from-the-queue"></a><span data-ttu-id="44f8f-167">Recebendo mensagens da fila</span><span class="sxs-lookup"><span data-stu-id="44f8f-167">Receiving messages from the queue</span></span>
<span data-ttu-id="44f8f-168">Para receber mensagens da fila, você pode usar um objeto [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver), que pode ser criado diretamente de [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) usando [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_).</span><span class="sxs-lookup"><span data-stu-id="44f8f-168">To receive messages from the queue, you can use a [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) object which you create directly from the [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) using [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_).</span></span> <span data-ttu-id="44f8f-169">Os receptores da mensagem poderão trabalhar em dois modos diferentes: **ReceiveAndDelete** e **PeekLock**.</span><span class="sxs-lookup"><span data-stu-id="44f8f-169">Message receivers can work in two different modes: **ReceiveAndDelete** and **PeekLock**.</span></span> <span data-ttu-id="44f8f-170">O [ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode) é definido quando o receptor da mensagem é criado como um parâmetro para a chamada a [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory?redirectedfrom=MSDN#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_Microsoft_ServiceBus_Messaging_ReceiveMode_).</span><span class="sxs-lookup"><span data-stu-id="44f8f-170">The [ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode) is set when the message receiver is created, as a parameter to the [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory?redirectedfrom=MSDN#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_Microsoft_ServiceBus_Messaging_ReceiveMode_) call.</span></span>

<span data-ttu-id="44f8f-171">Ao usar o modo **ReceiveAndDelete**, o recebimento é uma operação única, isto é, quando o Barramento de Serviço recebe uma solicitação de leitura de uma mensagem, ele marca a mensagem como sendo consumida e a retorna para o aplicativo.</span><span class="sxs-lookup"><span data-stu-id="44f8f-171">When using the **ReceiveAndDelete** mode, the receive is a single-shot operation; that is, when Service Bus receives the request, it marks the message as being consumed and returns it to the application.</span></span> <span data-ttu-id="44f8f-172">O modo **ReceiveAndDelete** é o modelo mais simples e funciona melhor em cenários nos quais o aplicativo pode tolerar o não processamento de uma mensagem caso ocorra uma falha.</span><span class="sxs-lookup"><span data-stu-id="44f8f-172">**ReceiveAndDelete** mode is the simplest model and works best for scenarios in which the application can tolerate not processing a message if a failure were to occur.</span></span> <span data-ttu-id="44f8f-173">Para compreender isso, considere um cenário no qual o consumidor emite a solicitação de recebimento e então falha antes de processá-la.</span><span class="sxs-lookup"><span data-stu-id="44f8f-173">To understand this, consider a scenario in which the consumer issues the receive request and then crashes before processing it.</span></span> <span data-ttu-id="44f8f-174">Já que o Barramento de Serviço marcou a mensagem como consumida, quando o aplicativo for reiniciado e começar a consumir mensagens novamente, terá perdido a mensagem consumida antes da falha.</span><span class="sxs-lookup"><span data-stu-id="44f8f-174">Since Service Bus marked the message as being consumed, when the application restarts and starts consuming messages again, it will have missed the message that was consumed before the crash.</span></span>

<span data-ttu-id="44f8f-175">No modo **PeekLock**, o recebimento de uma mensagem se torna uma operação de dois estágios, o que possibilita o suporte aos aplicativos que não podem tolerar mensagens ausentes.</span><span class="sxs-lookup"><span data-stu-id="44f8f-175">In **PeekLock** mode, the receive becomes a two-stage operation, which makes it possible to support applications that cannot tolerate missing messages.</span></span> <span data-ttu-id="44f8f-176">Quando o Barramento de Serviço recebe a solicitação, ele encontra a próxima mensagem a ser consumida, a bloqueia para evitar que outros clientes a recebam e a retorna para o aplicativo.</span><span class="sxs-lookup"><span data-stu-id="44f8f-176">When Service Bus receives the request, it finds the next message to be consumed, locks it to prevent other consumers receiving it, and then returns it to the application.</span></span> <span data-ttu-id="44f8f-177">Depois que o aplicativo conclui o processamento da mensagem (ou a armazena de forma segura para processamento futuro), ele conclui a segunda etapa do processo de recebimento chamando [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) na mensagem recebida.</span><span class="sxs-lookup"><span data-stu-id="44f8f-177">After the application finishes processing the message (or stores it reliably for future processing), it completes the second stage of the receive process by calling [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) on the received message.</span></span> <span data-ttu-id="44f8f-178">Quando o Barramento de Serviço vê a chamada a [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete), marca a mensagem como sendo consumida.</span><span class="sxs-lookup"><span data-stu-id="44f8f-178">When Service Bus sees the [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) call, it marks the message as being consumed.</span></span>

<span data-ttu-id="44f8f-179">Dois outros resultados são possíveis.</span><span class="sxs-lookup"><span data-stu-id="44f8f-179">Two other outcomes are possible.</span></span> <span data-ttu-id="44f8f-180">Primeiro, se o aplicativo não for capaz de processar a mensagem por algum motivo, ele chamará [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) na mensagem recebida (em vez do método [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete)).</span><span class="sxs-lookup"><span data-stu-id="44f8f-180">First, if the application is unable to process the message for some reason, it can call [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) on the received message (instead of [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete)).</span></span> <span data-ttu-id="44f8f-181">Isso fará com que o Barramento de Serviço desbloqueie a mensagem na fila e disponibilize-a para que ela possa ser recebida novamente pelo mesmo consumidor ou por outro consumidor concorrente.</span><span class="sxs-lookup"><span data-stu-id="44f8f-181">This causes Service Bus to unlock the message and make it available to be received again, either by the same consumer or by another completing consumer.</span></span> <span data-ttu-id="44f8f-182">Em segundo lugar, há um tempo limite associado a um bloqueio e, se o aplicativo não conseguir processar a mensagem antes da expiração do tempo limite de bloqueio (por exemplo, se o aplicativo falhar), o Barramento de Serviço desbloqueará a mensagem e a disponibilizará para ser recebida novamente (basicamente executando uma operação [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) por padrão).</span><span class="sxs-lookup"><span data-stu-id="44f8f-182">Second, there is a time-out associated with the lock and if the application cannot process the message before the lock time-out expires (for example, if the application crashes), then Service Bus will unlock the message and make it available to be received again (essentially performing an [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) operation by default).</span></span>

<span data-ttu-id="44f8f-183">Observe que, se houver falha do aplicativo após o processamento da mensagem, mas antes da solicitação [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) ser emitida, a mensagem será entregue novamente ao aplicativo quando ele reiniciar.</span><span class="sxs-lookup"><span data-stu-id="44f8f-183">Note that if the application crashes after it processes the message but before the [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) request was issued, the message will be redelivered to the application when it restarts.</span></span> <span data-ttu-id="44f8f-184">Isso é geralmente denominado * pelo menos uma vez * processamento.</span><span class="sxs-lookup"><span data-stu-id="44f8f-184">This is often termed *At Least Once * processing.</span></span> <span data-ttu-id="44f8f-185">Isso significa que cada mensagem será processada pelo menos uma vez mas, em determinadas situações, a mesma mensagem poderá ser entregue novamente.</span><span class="sxs-lookup"><span data-stu-id="44f8f-185">This means that each message will be processed at least once but in certain situations the same message may be redelivered.</span></span> <span data-ttu-id="44f8f-186">Se o cenário não tolerar o processamento duplicado, será necessária lógica adicional no aplicativo para detectar duplicatas.</span><span class="sxs-lookup"><span data-stu-id="44f8f-186">If the scenario cannot tolerate duplicate processing, then additional logic is required in the application to detect duplicates.</span></span> <span data-ttu-id="44f8f-187">Isso pode ser feito com base na propriedade [MessageId](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_MessageId) da mensagem.</span><span class="sxs-lookup"><span data-stu-id="44f8f-187">This can be achieved based on the [MessageId](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_MessageId) property of the message.</span></span> <span data-ttu-id="44f8f-188">O valor dessa propriedade permanece constante nas tentativas de entrega.</span><span class="sxs-lookup"><span data-stu-id="44f8f-188">The value of this property remains constant across delivery attempts.</span></span> <span data-ttu-id="44f8f-189">Isso é conhecido como processamento *Exatamente Uma Vez*.</span><span class="sxs-lookup"><span data-stu-id="44f8f-189">This is termed *Exactly Once* processing.</span></span>

<span data-ttu-id="44f8f-190">O código que é mostrado aqui recebe e processa uma mensagem usando o modo **PeekLock**, que será o padrão caso nenhum valor [ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode) seja explicitamente fornecido.</span><span class="sxs-lookup"><span data-stu-id="44f8f-190">The code that is shown here receives and processes a message using the **PeekLock** mode, which is the default if no [ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode) value is explicitly provided.</span></span>

```csharp
MessageReceiver receiver = factory.CreateMessageReceiver("DataCollectionQueue");
BrokeredMessage receivedMessage = receiver.Receive();
try
{
    ProcessMessage(receivedMessage);
    receivedMessage.Complete();
}
catch (Exception e)
{
    receivedMessage.Abandon();
}
```

### <a name="use-the-queue-client"></a><span data-ttu-id="44f8f-191">Usar o cliente de fila</span><span class="sxs-lookup"><span data-stu-id="44f8f-191">Use the queue client</span></span>
<span data-ttu-id="44f8f-192">Os exemplos anteriores desta seção criaram objetos [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) e [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) diretamente da [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) para enviar e receber mensagens da fila, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="44f8f-192">The examples earlier in this section created [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) and [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) objects directly from the [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) to send and receive messages from the queue, respectively.</span></span> <span data-ttu-id="44f8f-193">Uma abordagem alternativa é usar um objeto [QueueClient](/dotnet/api/microsoft.servicebus.messaging.queueclient), que dá suporte a operações de envio e de recebimento, além de recursos mais avançados, como as sessões.</span><span class="sxs-lookup"><span data-stu-id="44f8f-193">An alternative approach is to use a [QueueClient](/dotnet/api/microsoft.servicebus.messaging.queueclient) object, which supports both send and receive operations in addition to more advanced features, such as sessions.</span></span>

```csharp
QueueClient queueClient = factory.CreateQueueClient("DataCollectionQueue");
queueClient.Send(bm);

BrokeredMessage message = queueClient.Receive();

try
{
    ProcessMessage(message);
    message.Complete();
}
catch (Exception e)
{
    message.Abandon();
} 
```

## <a name="next-steps"></a><span data-ttu-id="44f8f-194">Próximas etapas</span><span class="sxs-lookup"><span data-stu-id="44f8f-194">Next steps</span></span>
<span data-ttu-id="44f8f-195">Agora que você aprendeu os conceitos básicos sobre filas, confira [Criar aplicativos que usam os tópicos e as assinaturas do Barramento de Serviço](service-bus-create-topics-subscriptions.md) para continuar essa discussão usando as funcionalidades de publicação/assinatura dos tópicos e das assinaturas do Barramento de Serviço.</span><span class="sxs-lookup"><span data-stu-id="44f8f-195">Now that you've learned the basics of queues, see [Create applications that use Service Bus topics and subscriptions](service-bus-create-topics-subscriptions.md) to continue this discussion using the publish/subscribe capabilities of Service Bus topics and subscriptions.</span></span>


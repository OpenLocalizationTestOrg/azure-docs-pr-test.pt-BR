---
title: "Visão geral do ciclo de vida do Azure Service Fabric Reliable Services | Microsoft Docs"
description: Saiba mais sobre os diferentes eventos de ciclo de vida no Service Fabric Reliable Services
services: Service-Fabric
documentationcenter: .net
author: masnider
manager: timlt
editor: vturecek;
ms.assetid: 
ms.service: Service-Fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 08/18/2017
ms.author: masnider
ms.openlocfilehash: 16021ca72a2f10070b6409417ff0d88009591331
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/18/2017
---
# <a name="reliable-services-lifecycle-overview"></a><span data-ttu-id="859e4-103">Visão geral do ciclo de vida do Reliable Services</span><span class="sxs-lookup"><span data-stu-id="859e4-103">Reliable services lifecycle overview</span></span>
> [!div class="op_single_selector"]
> * [<span data-ttu-id="859e4-104">C# em Windows</span><span class="sxs-lookup"><span data-stu-id="859e4-104">C# on Windows</span></span>](service-fabric-reliable-services-lifecycle.md)
> * [<span data-ttu-id="859e4-105">Java no Linux</span><span class="sxs-lookup"><span data-stu-id="859e4-105">Java on Linux</span></span>](service-fabric-reliable-services-lifecycle-java.md)
>
>

<span data-ttu-id="859e4-106">Ao pensar sobre os ciclos de vida do Reliable Services, os conceitos básicos são os mais importantes.</span><span class="sxs-lookup"><span data-stu-id="859e4-106">When thinking about the lifecycles of Reliable Services, the basics of the lifecycle are the most important.</span></span> <span data-ttu-id="859e4-107">Em geral:</span><span class="sxs-lookup"><span data-stu-id="859e4-107">In general:</span></span>

- <span data-ttu-id="859e4-108">Durante a inicialização</span><span class="sxs-lookup"><span data-stu-id="859e4-108">During Startup</span></span>
  - <span data-ttu-id="859e4-109">Serviços são construídos</span><span class="sxs-lookup"><span data-stu-id="859e4-109">Services are constructed</span></span>
  - <span data-ttu-id="859e4-110">Eles têm a oportunidade de construir e retornar zero ou mais ouvintes</span><span class="sxs-lookup"><span data-stu-id="859e4-110">They have an opportunity to construct and return zero or more listeners</span></span>
  - <span data-ttu-id="859e4-111">Todos os ouvintes retornados são abertos, permitindo a comunicação com o serviço</span><span class="sxs-lookup"><span data-stu-id="859e4-111">Any returned listeners are opened, allowing communication with the service</span></span>
  - <span data-ttu-id="859e4-112">O método RunAsync do serviço é chamado, possibilitando um serviço de longa execução ou trabalho em segundo plano</span><span class="sxs-lookup"><span data-stu-id="859e4-112">The Service's RunAsync method is called, allowing the service to do long running or background work</span></span>
- <span data-ttu-id="859e4-113">Durante o desligamento</span><span class="sxs-lookup"><span data-stu-id="859e4-113">During shutdown</span></span>
  - <span data-ttu-id="859e4-114">O token de cancelamento passado para RunAsync é cancelado e os ouvintes são fechados</span><span class="sxs-lookup"><span data-stu-id="859e4-114">The cancellation token passed to RunAsync is canceled, and the listeners are closed</span></span>
  - <span data-ttu-id="859e4-115">Assim que estiver concluído, o objeto do serviço será destruído</span><span class="sxs-lookup"><span data-stu-id="859e4-115">Once that is complete, the service object itself is destructed</span></span>

<span data-ttu-id="859e4-116">Há detalhes sobre a ordem exata desses eventos.</span><span class="sxs-lookup"><span data-stu-id="859e4-116">There are details around the exact ordering of these events.</span></span> <span data-ttu-id="859e4-117">Em especial, a ordem de eventos pode mudar um pouco dependendo se o Reliable Service tem estado ou não.</span><span class="sxs-lookup"><span data-stu-id="859e4-117">In particular, the order of events may change slightly depending on whether the Reliable Service is Stateless or Stateful.</span></span> <span data-ttu-id="859e4-118">Além disso, para serviços com estado, temos de lidar com o cenário de troca primário.</span><span class="sxs-lookup"><span data-stu-id="859e4-118">In addition, for stateful services, we have to deal with the Primary swap scenario.</span></span> <span data-ttu-id="859e4-119">Durante esta sequência, a função da Primária é transferida para outra réplica (ou retorna) sem o desligamento do serviço.</span><span class="sxs-lookup"><span data-stu-id="859e4-119">During this sequence, the role of Primary is transferred to another replica (or comes back) without the service shutting down.</span></span> <span data-ttu-id="859e4-120">Por fim, temos de pensar sobre as condições de erro ou falha.</span><span class="sxs-lookup"><span data-stu-id="859e4-120">Finally, we have to think about error or failure conditions.</span></span>

## <a name="stateless-service-startup"></a><span data-ttu-id="859e4-121">Inicialização de serviço sem estado</span><span class="sxs-lookup"><span data-stu-id="859e4-121">Stateless service startup</span></span>
<span data-ttu-id="859e4-122">O ciclo de vida de um serviço sem estado é bastante simples.</span><span class="sxs-lookup"><span data-stu-id="859e4-122">The lifecycle of a stateless service is fairly straightforward.</span></span> <span data-ttu-id="859e4-123">Aqui está a ordem de eventos:</span><span class="sxs-lookup"><span data-stu-id="859e4-123">Here's the order of events:</span></span>

1. <span data-ttu-id="859e4-124">O Serviço foi construído</span><span class="sxs-lookup"><span data-stu-id="859e4-124">The Service is constructed</span></span>
2. <span data-ttu-id="859e4-125">Em seguida, ocorrem duas coisas em paralelo:</span><span class="sxs-lookup"><span data-stu-id="859e4-125">Then, in parallel two things happen:</span></span>
    - <span data-ttu-id="859e4-126">`StatelessService.CreateServiceInstanceListeners()` é invocado e todos os ouvintes retornados são Abertos.</span><span class="sxs-lookup"><span data-stu-id="859e4-126">`StatelessService.CreateServiceInstanceListeners()` is invoked and any returned listeners are Opened.</span></span> <span data-ttu-id="859e4-127">`ICommunicationListener.OpenAsync()` é chamado em cada ouvinte</span><span class="sxs-lookup"><span data-stu-id="859e4-127">`ICommunicationListener.OpenAsync()` is called on each listener</span></span>
    - <span data-ttu-id="859e4-128">O método `StatelessService.RunAsync()` do serviço é chamado</span><span class="sxs-lookup"><span data-stu-id="859e4-128">The service's `StatelessService.RunAsync()` method is called</span></span>
3. <span data-ttu-id="859e4-129">Se estiver presente, o método `StatelessService.OnOpenAsync()` do serviço será chamado.</span><span class="sxs-lookup"><span data-stu-id="859e4-129">If present, the service's `StatelessService.OnOpenAsync()` method is called.</span></span> <span data-ttu-id="859e4-130">Essa não é uma substituição comum, mas está disponível.</span><span class="sxs-lookup"><span data-stu-id="859e4-130">This is an uncommon override, but it is available.</span></span>

<span data-ttu-id="859e4-131">É importante observar que não há nenhuma ordem entre as chamadas para criar e abrir os ouvintes e o RunAsync.</span><span class="sxs-lookup"><span data-stu-id="859e4-131">It is important to note that there is no ordering between the calls to create and open the listeners and RunAsync.</span></span> <span data-ttu-id="859e4-132">Os ouvintes podem ser abertos antes de RunAsync ser iniciado.</span><span class="sxs-lookup"><span data-stu-id="859e4-132">The listeners may open before RunAsync is started.</span></span> <span data-ttu-id="859e4-133">Da mesma forma, RunAsync pode acabar sendo invocado antes que os ouvintes de comunicação sejam abertos ou até mesmo antes de serem construídos.</span><span class="sxs-lookup"><span data-stu-id="859e4-133">Similarly, RunAsync may end up invoked before the communication listeners are open or have even been constructed.</span></span> <span data-ttu-id="859e4-134">Se nenhuma sincronização for necessária, isso será deixado como um exercício para o implementador.</span><span class="sxs-lookup"><span data-stu-id="859e4-134">If any synchronization is required, it is left as an exercise to the implementer.</span></span> <span data-ttu-id="859e4-135">Soluções comuns:</span><span class="sxs-lookup"><span data-stu-id="859e4-135">Common solutions:</span></span>

  - <span data-ttu-id="859e4-136">Algumas vezes os ouvintes não funcionam até que outras informações sejam criadas ou algum trabalho seja realizado.</span><span class="sxs-lookup"><span data-stu-id="859e4-136">Sometimes listeners can't function until some other information is created or work done.</span></span> <span data-ttu-id="859e4-137">Para serviços sem estado, esse trabalho geralmente pode ser feito em outros locais, como:</span><span class="sxs-lookup"><span data-stu-id="859e4-137">For stateless services that work can usually be done in other locations, such as:</span></span> 
    - <span data-ttu-id="859e4-138">no construtor do serviço</span><span class="sxs-lookup"><span data-stu-id="859e4-138">in the service's constructor</span></span>
    - <span data-ttu-id="859e4-139">durante a chamada de `CreateServiceInstanceListeners()`</span><span class="sxs-lookup"><span data-stu-id="859e4-139">during the `CreateServiceInstanceListeners()` call</span></span>
    - <span data-ttu-id="859e4-140">como parte da construção do ouvinte em si</span><span class="sxs-lookup"><span data-stu-id="859e4-140">as a part of the construction of the listener itself</span></span>
  - <span data-ttu-id="859e4-141">Às vezes, o código em RunAsync não é iniciado até que os ouvintes estejam abertos.</span><span class="sxs-lookup"><span data-stu-id="859e4-141">Sometimes the code in RunAsync does not want to start until the listeners are open.</span></span> <span data-ttu-id="859e4-142">Nesse caso, coordenação adicional será necessária.</span><span class="sxs-lookup"><span data-stu-id="859e4-142">In this case additional coordination is necessary.</span></span> <span data-ttu-id="859e4-143">Uma solução comum é uma sinalização nos ouvintes, indicando quando eles foram concluídos.</span><span class="sxs-lookup"><span data-stu-id="859e4-143">One common solution is some flag within the listeners indicating when they have completed.</span></span> <span data-ttu-id="859e4-144">Esse sinalizador é verificado no RunAsync antes da continuação do trabalho real.</span><span class="sxs-lookup"><span data-stu-id="859e4-144">This flag is then checked in RunAsync before continuing to actual work.</span></span>

## <a name="stateless-service-shutdown"></a><span data-ttu-id="859e4-145">Desligamento de serviço sem estado</span><span class="sxs-lookup"><span data-stu-id="859e4-145">Stateless service shutdown</span></span>
<span data-ttu-id="859e4-146">Ao desligar um serviço sem estado, o mesmo padrão é seguido, porém na ordem inversa:</span><span class="sxs-lookup"><span data-stu-id="859e4-146">When shutting down a stateless service, the same pattern is followed, just in reverse:</span></span>

1. <span data-ttu-id="859e4-147">Em paralelo</span><span class="sxs-lookup"><span data-stu-id="859e4-147">In parallel</span></span>
    - <span data-ttu-id="859e4-148">Todos os ouvintes abertos são Fechados.</span><span class="sxs-lookup"><span data-stu-id="859e4-148">Any open listeners are Closed.</span></span> <span data-ttu-id="859e4-149">`ICommunicationListener.CloseAsync()` é chamado em cada ouvinte.</span><span class="sxs-lookup"><span data-stu-id="859e4-149">`ICommunicationListener.CloseAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="859e4-150">O token de cancelamento passado para `RunAsync()` é cancelado.</span><span class="sxs-lookup"><span data-stu-id="859e4-150">The cancellation token passed to `RunAsync()` is canceled.</span></span> <span data-ttu-id="859e4-151">A verificação da propriedade `IsCancellationRequested` do token de cancelamento retorna true e, se chamado, o método `ThrowIfCancellationRequested` do token vai lançar `OperationCanceledException`.</span><span class="sxs-lookup"><span data-stu-id="859e4-151">Checking the cancellation token's `IsCancellationRequested` property returns true, and if called the token's `ThrowIfCancellationRequested` method throws an `OperationCanceledException`.</span></span>
2. <span data-ttu-id="859e4-152">Uma vez que `CloseAsync()` é concluído em cada ouvinte e `RunAsync()` também é finalizado, o método `StatelessService.OnCloseAsync()` do serviço será chamado, se estiver presente.</span><span class="sxs-lookup"><span data-stu-id="859e4-152">Once `CloseAsync()` completes on each listener and `RunAsync()` also completes, the service's `StatelessService.OnCloseAsync()` method is called, if present.</span></span> <span data-ttu-id="859e4-153">Não é comum substituir `StatelessService.OnCloseAsync()`.</span><span class="sxs-lookup"><span data-stu-id="859e4-153">It is uncommon to override `StatelessService.OnCloseAsync()`.</span></span>
3. <span data-ttu-id="859e4-154">Depois da conclusão de `StatelessService.OnCloseAsync()`, o objeto de serviço é destruído</span><span class="sxs-lookup"><span data-stu-id="859e4-154">After `StatelessService.OnCloseAsync()` completes, the service object is destructed</span></span>

## <a name="stateful-service-startup"></a><span data-ttu-id="859e4-155">Inicialização de serviço com estado</span><span class="sxs-lookup"><span data-stu-id="859e4-155">Stateful service Startup</span></span>
<span data-ttu-id="859e4-156">Serviços com estado têm um padrão semelhante aos serviços sem monitoração de estado, com algumas alterações.</span><span class="sxs-lookup"><span data-stu-id="859e4-156">Stateful services have a similar pattern to stateless services, with a few changes.</span></span> <span data-ttu-id="859e4-157">Ao iniciar um serviço com estado, a ordem de eventos é a seguinte:</span><span class="sxs-lookup"><span data-stu-id="859e4-157">When starting up a stateful service, the order of events is as follows:</span></span>

1. <span data-ttu-id="859e4-158">O Serviço foi construído</span><span class="sxs-lookup"><span data-stu-id="859e4-158">The Service is constructed</span></span>
2. <span data-ttu-id="859e4-159">`StatefulServiceBase.OnOpenAsync()` é chamado.</span><span class="sxs-lookup"><span data-stu-id="859e4-159">`StatefulServiceBase.OnOpenAsync()` is called.</span></span> <span data-ttu-id="859e4-160">Isso raramente é substituído no serviço.</span><span class="sxs-lookup"><span data-stu-id="859e4-160">This is uncommonly overridden in the service.</span></span>
3. <span data-ttu-id="859e4-161">As seguintes ações ocorrem paralelamente</span><span class="sxs-lookup"><span data-stu-id="859e4-161">The following things happen in parallel</span></span>
    - <span data-ttu-id="859e4-162">`StatefulServiceBase.CreateServiceReplicaListeners()` é invocado</span><span class="sxs-lookup"><span data-stu-id="859e4-162">`StatefulServiceBase.CreateServiceReplicaListeners()` is invoked</span></span> 
      - <span data-ttu-id="859e4-163">Se o serviço for Primário, todos os ouvintes retornados serão Abertos.</span><span class="sxs-lookup"><span data-stu-id="859e4-163">If the service is a Primary all returned listeners are Opened.</span></span> <span data-ttu-id="859e4-164">`ICommunicationListener.OpenAsync()` é chamado em cada ouvinte.</span><span class="sxs-lookup"><span data-stu-id="859e4-164">`ICommunicationListener.OpenAsync()` is called on each listener.</span></span>
      - <span data-ttu-id="859e4-165">Se o serviço for um Secundário, somente esses ouvintes marcados como `ListenOnSecondary = true` serão abertos.</span><span class="sxs-lookup"><span data-stu-id="859e4-165">If the service is a Secondary, only those listeners marked as `ListenOnSecondary = true` are opened.</span></span> <span data-ttu-id="859e4-166">Ter ouvintes que estão abertos em Secundários é menos comum.</span><span class="sxs-lookup"><span data-stu-id="859e4-166">Having listeners that are open on Secondaries is less common.</span></span>
    - <span data-ttu-id="859e4-167">Se, no momento, o serviço for um Primário, o método `StatefulServiceBase.RunAsync()` do serviço será chamado</span><span class="sxs-lookup"><span data-stu-id="859e4-167">The if the Service is currently a Primary, the service's `StatefulServiceBase.RunAsync()` method is called</span></span>
4. <span data-ttu-id="859e4-168">Depois que todas as chamadas a `OpenAsync()` do ouvinte da réplica forem concluídas e `RunAsync()` for chamado, `StatefulServiceBase.OnChangeRoleAsync()` será chamado.</span><span class="sxs-lookup"><span data-stu-id="859e4-168">Once all the replica listener's `OpenAsync()` calls complete and `RunAsync()` is called, `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="859e4-169">Isso raramente é substituído no serviço.</span><span class="sxs-lookup"><span data-stu-id="859e4-169">This is uncommonly overridden in the service.</span></span>

<span data-ttu-id="859e4-170">Semelhante aos serviços sem estado, não há coordenação entre a ordem em que os ouvintes são criados e abertos e quando RunAsync é chamado.</span><span class="sxs-lookup"><span data-stu-id="859e4-170">Similarly to stateless services, there's no coordination between the order in which the listeners are created and opened and when RunAsync is called.</span></span> <span data-ttu-id="859e4-171">Se você precisar de coordenação, as soluções são muito parecidas.</span><span class="sxs-lookup"><span data-stu-id="859e4-171">If you need coordination, the solutions are much the same.</span></span> <span data-ttu-id="859e4-172">Há um caso adicional: digamos que as chamadas que chegam aos ouvintes de comunicação exijam que as informações sejam mantidas em algumas [Coleções Confiáveis](service-fabric-reliable-services-reliable-collections.md).</span><span class="sxs-lookup"><span data-stu-id="859e4-172">THere is one additional case: say that the calls arriving at the communication listeners require information kept inside some [Reliable Collections](service-fabric-reliable-services-reliable-collections.md).</span></span> <span data-ttu-id="859e4-173">Como os ouvintes de comunicação podem ser abertos antes que as coleções confiáveis fiquem legíveis ou graváveis e antes de RunAsync ser iniciado, é necessário realizar a coordenação.</span><span class="sxs-lookup"><span data-stu-id="859e4-173">Because the communication listeners could open before the reliable collections are readable or writeable, and before RunAsync could start, some additional coordination is necessary.</span></span> <span data-ttu-id="859e4-174">A solução mais simples e mais comum é os ouvintes de comunicação retornarem um código de erro que o cliente usa para repetir a solicitação.</span><span class="sxs-lookup"><span data-stu-id="859e4-174">The simplest and most common solution is for the communication listeners to return some error code that the client uses to know to retry the request.</span></span>

## <a name="stateful-service-shutdown"></a><span data-ttu-id="859e4-175">Desligamento de serviço com estado</span><span class="sxs-lookup"><span data-stu-id="859e4-175">Stateful service Shutdown</span></span>
<span data-ttu-id="859e4-176">Da mesma forma que os serviços sem monitoração de estado, os eventos de ciclo de vida durante o desligamento são os mesmos que durante a inicialização, porém invertidos.</span><span class="sxs-lookup"><span data-stu-id="859e4-176">Similarly to Stateless services, the lifecycle events during shutdown are the same as during startup, but reversed.</span></span> <span data-ttu-id="859e4-177">Quando um serviço com estado está sendo desligado, ocorrem os seguintes eventos:</span><span class="sxs-lookup"><span data-stu-id="859e4-177">When a stateful service is being shut down, the following events occur:</span></span>

1. <span data-ttu-id="859e4-178">Em paralelo</span><span class="sxs-lookup"><span data-stu-id="859e4-178">In parallel</span></span>
    - <span data-ttu-id="859e4-179">Todos os ouvintes abertos são Fechados.</span><span class="sxs-lookup"><span data-stu-id="859e4-179">Any open listeners are Closed.</span></span> <span data-ttu-id="859e4-180">`ICommunicationListener.CloseAsync()` é chamado em cada ouvinte.</span><span class="sxs-lookup"><span data-stu-id="859e4-180">`ICommunicationListener.CloseAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="859e4-181">O token de cancelamento passado para `RunAsync()` é cancelado.</span><span class="sxs-lookup"><span data-stu-id="859e4-181">The cancellation token passed to `RunAsync()` is canceled.</span></span> <span data-ttu-id="859e4-182">A verificação da propriedade `IsCancellationRequested` do token de cancelamento retorna true e, se chamado, o método `ThrowIfCancellationRequested` do token vai lançar `OperationCanceledException`.</span><span class="sxs-lookup"><span data-stu-id="859e4-182">Checking the cancellation token's `IsCancellationRequested` property returns true, and if called the token's `ThrowIfCancellationRequested` method throws an `OperationCanceledException`.</span></span>
2. <span data-ttu-id="859e4-183">Uma vez que `CloseAsync()` é concluído em cada ouvinte e `RunAsync()` também é finalizado, o `StatefulServiceBase.OnChangeRoleAsync()` do serviço é chamado.</span><span class="sxs-lookup"><span data-stu-id="859e4-183">Once `CloseAsync()` completes on each listener and `RunAsync()` also completes, the service's `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="859e4-184">(Isso raramente é substituído no serviço.)</span><span class="sxs-lookup"><span data-stu-id="859e4-184">(This is uncommonly overridden in the service.)</span></span>
    - <span data-ttu-id="859e4-185">Aguardar a conclusão de RunAsync só será necessário se essa réplica de serviço for um Primário.</span><span class="sxs-lookup"><span data-stu-id="859e4-185">Waiting for RunAsync to complete is only necessary if this service replica was a Primary.</span></span>
3. <span data-ttu-id="859e4-186">Depois que o método `StatefulServiceBase.OnChangeRoleAsync()` for concluído, o método `StatefulServiceBase.OnCloseAsync()` será chamado.</span><span class="sxs-lookup"><span data-stu-id="859e4-186">Once the `StatefulServiceBase.OnChangeRoleAsync()` method completes, the `StatefulServiceBase.OnCloseAsync()` method is called.</span></span> <span data-ttu-id="859e4-187">Essa não é uma substituição comum, mas está disponível.</span><span class="sxs-lookup"><span data-stu-id="859e4-187">This is an uncommon override, but it is available.</span></span>
3. <span data-ttu-id="859e4-188">Depois da conclusão de `StatefulServiceBase.OnCloseAsync()`, o objeto de serviço é destruído.</span><span class="sxs-lookup"><span data-stu-id="859e4-188">After `StatefulServiceBase.OnCloseAsync()` completes, the service object is destructed.</span></span>

## <a name="stateful-service-primary-swaps"></a><span data-ttu-id="859e4-189">Trocas de primária do serviço com estado</span><span class="sxs-lookup"><span data-stu-id="859e4-189">Stateful service primary swaps</span></span>
<span data-ttu-id="859e4-190">Enquanto um serviço com estado é executado, somente as réplicas Primárias destes serviços com estado terão seus ouvintes de comunicação abertos e seu método RunAsync chamado.</span><span class="sxs-lookup"><span data-stu-id="859e4-190">While a stateful service is running, only the Primary replicas of that stateful services have their communication listeners opened and their RunAsync method called.</span></span> <span data-ttu-id="859e4-191">Secundárias são construídas, mas não recebem chamadas.</span><span class="sxs-lookup"><span data-stu-id="859e4-191">Secondary are constructed but see no further calls.</span></span> <span data-ttu-id="859e4-192">Contudo, enquanto um serviço com estado é executado, qual réplica é a Primária no momento pode mudar.</span><span class="sxs-lookup"><span data-stu-id="859e4-192">While a stateful service is running however, which replica is currently the Primary can change.</span></span> <span data-ttu-id="859e4-193">O que isso significa em termos dos eventos do ciclo de vida que uma réplica pode ver?</span><span class="sxs-lookup"><span data-stu-id="859e4-193">What does this mean in terms of the lifecycle events that a replica can see?</span></span> <span data-ttu-id="859e4-194">O comportamento que uma réplica com estado vê depende se ela é a réplica que está sendo rebaixada ou promovida durante a troca.</span><span class="sxs-lookup"><span data-stu-id="859e4-194">The behavior the stateful replica sees depends on whether it is the replica being demoted or promoted during the swap.</span></span>

### <a name="for-the-primary-being-demoted"></a><span data-ttu-id="859e4-195">Para a primária sendo rebaixada</span><span class="sxs-lookup"><span data-stu-id="859e4-195">For the primary being demoted</span></span>
<span data-ttu-id="859e4-196">O Service Fabric precisa que esta réplica interrompa o processamento de mensagens e feche todo o trabalho em segundo plano que estiver sendo realizado.</span><span class="sxs-lookup"><span data-stu-id="859e4-196">Service Fabric needs this replica to stop processing messages and quit any background work it is doing.</span></span> <span data-ttu-id="859e4-197">Por isso, essa etapa é semelhante a quando o serviço está sendo desligado.</span><span class="sxs-lookup"><span data-stu-id="859e4-197">As a result, this step looks similar to when the service is being shut down.</span></span> <span data-ttu-id="859e4-198">Uma diferença é que o Serviço não é destruído ou fechado, pois ele permanece como uma Secundária.</span><span class="sxs-lookup"><span data-stu-id="859e4-198">One difference is that the Service isn't destructed or closed since it remains as a Secondary.</span></span> <span data-ttu-id="859e4-199">As seguintes APIs são chamadas:</span><span class="sxs-lookup"><span data-stu-id="859e4-199">The following APIs are called:</span></span>

1. <span data-ttu-id="859e4-200">Em paralelo</span><span class="sxs-lookup"><span data-stu-id="859e4-200">In parallel</span></span>
    - <span data-ttu-id="859e4-201">Todos os ouvintes abertos são Fechados.</span><span class="sxs-lookup"><span data-stu-id="859e4-201">Any open listeners are Closed.</span></span> <span data-ttu-id="859e4-202">`ICommunicationListener.CloseAsync()` é chamado em cada ouvinte.</span><span class="sxs-lookup"><span data-stu-id="859e4-202">`ICommunicationListener.CloseAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="859e4-203">O token de cancelamento passado para `RunAsync()` é cancelado.</span><span class="sxs-lookup"><span data-stu-id="859e4-203">The cancellation token passed to `RunAsync()` is canceled.</span></span> <span data-ttu-id="859e4-204">A verificação da propriedade `IsCancellationRequested` do token de cancelamento retorna true e, se chamado, o método `ThrowIfCancellationRequested` do token vai lançar `OperationCanceledException`.</span><span class="sxs-lookup"><span data-stu-id="859e4-204">Checking the cancellation token's `IsCancellationRequested` property returns true, and if called the token's `ThrowIfCancellationRequested` method throws an `OperationCanceledException`.</span></span>
2. <span data-ttu-id="859e4-205">Uma vez que `CloseAsync()` é concluído em cada ouvinte e `RunAsync()` também é finalizado, o `StatefulServiceBase.OnChangeRoleAsync()` do serviço é chamado.</span><span class="sxs-lookup"><span data-stu-id="859e4-205">Once `CloseAsync()` completes on each listener and `RunAsync()` also completes, the service's `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="859e4-206">Isso raramente é substituído no serviço.</span><span class="sxs-lookup"><span data-stu-id="859e4-206">This is uncommonly overridden in the service.</span></span>

### <a name="for-the-secondary-being-promoted"></a><span data-ttu-id="859e4-207">Para a secundária que está sendo promovida</span><span class="sxs-lookup"><span data-stu-id="859e4-207">For the secondary being promoted</span></span>
<span data-ttu-id="859e4-208">Da mesma forma, o Service Fabric precisa que essa réplica comece a escutar as mensagens durante a transmissão e inicie as tarefas em segundo plano que são importantes.</span><span class="sxs-lookup"><span data-stu-id="859e4-208">Similarly, Service Fabric needs this replica to start listening for messages on the wire and start any background tasks it cares about.</span></span> <span data-ttu-id="859e4-209">Por isso, esse processo é similar à criação do serviço, exceto que a própria réplica já existe.</span><span class="sxs-lookup"><span data-stu-id="859e4-209">As a result, this process looks similar to when the service is created, except that the replica itself already exists.</span></span> <span data-ttu-id="859e4-210">As seguintes APIs são chamadas:</span><span class="sxs-lookup"><span data-stu-id="859e4-210">The following APIs are called:</span></span>

1. <span data-ttu-id="859e4-211">Em paralelo</span><span class="sxs-lookup"><span data-stu-id="859e4-211">In parallel</span></span>
    - <span data-ttu-id="859e4-212">`StatefulServiceBase.CreateServiceReplicaListeners()` é invocado e todos os ouvintes retornados são Abertos.</span><span class="sxs-lookup"><span data-stu-id="859e4-212">`StatefulServiceBase.CreateServiceReplicaListeners()` is invoked and any returned listeners are Opened.</span></span> <span data-ttu-id="859e4-213">`ICommunicationListener.OpenAsync()` é chamado em cada ouvinte.</span><span class="sxs-lookup"><span data-stu-id="859e4-213">`ICommunicationListener.OpenAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="859e4-214">O método `StatefulServiceBase.RunAsync()` do serviço é chamado</span><span class="sxs-lookup"><span data-stu-id="859e4-214">The service's `StatefulServiceBase.RunAsync()` method is called</span></span>
2. <span data-ttu-id="859e4-215">Depois que todas as chamadas a `OpenAsync()` do ouvinte da réplica forem concluídas e `RunAsync()` tiver sido chamado, `StatefulServiceBase.OnChangeRoleAsync()` será chamado.</span><span class="sxs-lookup"><span data-stu-id="859e4-215">Once all the replica listener's `OpenAsync()` calls complete and `RunAsync()` has been called,  `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="859e4-216">Isso raramente é substituído no serviço.</span><span class="sxs-lookup"><span data-stu-id="859e4-216">This is uncommonly overridden in the service.</span></span>

### <a name="common-issues-during-stateful-service-shutdown-and-primary-demotion"></a><span data-ttu-id="859e4-217">Problemas comuns durante o desligamento do serviço com estado e rebaixamento do primário</span><span class="sxs-lookup"><span data-stu-id="859e4-217">Common issues during stateful service shutdown and primary demotion</span></span>
<span data-ttu-id="859e4-218">O Service Fabric altera o Primário de um serviço com estado por vários motivos.</span><span class="sxs-lookup"><span data-stu-id="859e4-218">Service Fabric changes the Primary of a stateful service for a variety of reasons.</span></span> <span data-ttu-id="859e4-219">Os mais comuns são [rebalanceamento do cluster](service-fabric-cluster-resource-manager-balancing.md) e [upgrade de aplicativo](service-fabric-application-upgrade.md).</span><span class="sxs-lookup"><span data-stu-id="859e4-219">The most common are [cluster rebalancing](service-fabric-cluster-resource-manager-balancing.md) and [application upgrade](service-fabric-application-upgrade.md).</span></span> <span data-ttu-id="859e4-220">Durante essas operações (bem como durante o desligamento normal do serviço, como você veria se o serviço fosse excluído), é importante que o serviço respeite o `CancellationToken`.</span><span class="sxs-lookup"><span data-stu-id="859e4-220">During these operations (as well as during normal service shutdown, like you'd see if the service was deleted), it is important that the service respect the `CancellationToken`.</span></span> <span data-ttu-id="859e4-221">Os serviços que não tratarem o cancelamento corretamente enfrentarão vários problemas.</span><span class="sxs-lookup"><span data-stu-id="859e4-221">Services that do not handle cancellation cleanly will experience several issues.</span></span> <span data-ttu-id="859e4-222">Particularmente, essas operações ficarão lentas, uma vez que o Service Fabric espera que os serviços parem normalmente.</span><span class="sxs-lookup"><span data-stu-id="859e4-222">In particular, these operations will be slow since Service Fabric waits for the services to stop gracefully.</span></span> <span data-ttu-id="859e4-223">Em última instância, isso leva a falhas de upgrade que atingem um tempo limite e são revertidas.</span><span class="sxs-lookup"><span data-stu-id="859e4-223">This can ultimately lead to failed upgrades that time out and roll back.</span></span> <span data-ttu-id="859e4-224">Não respeitar o token de cancelamento também pode resultar em clusters desequilibrados, pois os nós são ativados, mas os serviços não podem ser rebalanceados, uma vez que é muito demorado movê-los para qualquer outro lugar.</span><span class="sxs-lookup"><span data-stu-id="859e4-224">Failure to honor the cancellation token can also cause imbalanced clusters because nodes get hot but the services can't be rebalanced since it takes too long to move them elsewhere.</span></span> 

<span data-ttu-id="859e4-225">Como os serviços têm estado, também é provável que eles estejam usando as [Coleções Confiáveis](service-fabric-reliable-services-reliable-collections.md).</span><span class="sxs-lookup"><span data-stu-id="859e4-225">Since the services are stateful, it is also likely that they are using the [Reliable Collections](service-fabric-reliable-services-reliable-collections.md).</span></span> <span data-ttu-id="859e4-226">No Service Fabric, quando um Primário é rebaixado, uma das primeiras coisas que acontece é que o acesso de gravação ao estado subjacente é revogado.</span><span class="sxs-lookup"><span data-stu-id="859e4-226">In Service Fabric, when a Primary is demoted, one of the first things that happens is that write access to the underlying state is revoked.</span></span> <span data-ttu-id="859e4-227">Isso leva a um segundo conjunto de problemas que pode afetar o ciclo de vida do serviço.</span><span class="sxs-lookup"><span data-stu-id="859e4-227">This leads to a second set of issues that can impact the service lifecycle.</span></span> <span data-ttu-id="859e4-228">As coleções retornam Exceções que se baseiam no tempo e se a réplica está sendo movida ou desligada.</span><span class="sxs-lookup"><span data-stu-id="859e4-228">The collections return Exceptions based on the timing and whether the replica is being moved or shut down.</span></span> <span data-ttu-id="859e4-229">Essas exceções devem ser tratadas corretamente.</span><span class="sxs-lookup"><span data-stu-id="859e4-229">These exceptions should be handled correctly.</span></span> <span data-ttu-id="859e4-230">As exceções geradas pelo Service Fabric se classificam nas categorias permanentes [(`FabricException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabricexception?view=azure-dotnet) e transitórias [(`FabricTransientException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabrictransientexception?view=azure-dotnet).</span><span class="sxs-lookup"><span data-stu-id="859e4-230">Exceptions thrown by Service Fabric fall into permanent [(`FabricException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabricexception?view=azure-dotnet) and transient [(`FabricTransientException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabrictransientexception?view=azure-dotnet) categories.</span></span> <span data-ttu-id="859e4-231">As exceções permanentes devem ser registradas e lançadas, enquanto as exceções transitórias podem ser recuperadas com base em alguma lógica de repetição.</span><span class="sxs-lookup"><span data-stu-id="859e4-231">Permanent exceptions should be logged and thrown, while the transient exceptions may be retried based on some retry logic.</span></span>

<span data-ttu-id="859e4-232">O tratamento das exceções que resultam do uso de `ReliableCollections` em conjunto com eventos de ciclo de vida do serviço é uma importante etapa do teste e da validação de um Serviço Confiável.</span><span class="sxs-lookup"><span data-stu-id="859e4-232">Handling the exceptions that come from use of the `ReliableCollections` in conjunction with service lifecycle events is an important part of testing and validating a Reliable Service.</span></span> <span data-ttu-id="859e4-233">A recomendação é sempre executar seu serviço sob carga durante a execução de upgrades e sempre [fazer o teste de caos](service-fabric-controlled-chaos.md) antes de implantar no ambiente de produção.</span><span class="sxs-lookup"><span data-stu-id="859e4-233">The recommendation is always to run your service under load while performing upgrades and [chaos testing](service-fabric-controlled-chaos.md) before ever deploying to production.</span></span> <span data-ttu-id="859e4-234">Essas etapas básicas ajudam a garantir que o serviço seja implementado corretamente, além de tratar os eventos do ciclo de vida corretamente.</span><span class="sxs-lookup"><span data-stu-id="859e4-234">These basic steps help ensure that your service is correctly implemented and handles lifecycle events correctly.</span></span>


## <a name="notes-on-service-lifecycle"></a><span data-ttu-id="859e4-235">Observações sobre o ciclo de vida do serviço</span><span class="sxs-lookup"><span data-stu-id="859e4-235">Notes on service lifecycle</span></span>
  - <span data-ttu-id="859e4-236">Tanto o método `RunAsync()` quanto as chamadas `CreateServiceReplicaListeners/CreateServiceInstanceListeners` são opcionais.</span><span class="sxs-lookup"><span data-stu-id="859e4-236">Both the `RunAsync()` method and the `CreateServiceReplicaListeners/CreateServiceInstanceListeners` calls are optional.</span></span> <span data-ttu-id="859e4-237">Um serviço pode ter um deles, ambos ou nenhum.</span><span class="sxs-lookup"><span data-stu-id="859e4-237">A service may have one of them, both, or neither.</span></span> <span data-ttu-id="859e4-238">Por exemplo, se o serviço fizer todo seu trabalho em resposta a chamadas do usuário, não será necessário implementar `RunAsync()`.</span><span class="sxs-lookup"><span data-stu-id="859e4-238">For example, if the service does all its work in response to user calls, there is no need for it to implement `RunAsync()`.</span></span> <span data-ttu-id="859e4-239">Apenas os ouvintes de comunicação e seu código associado são necessários.</span><span class="sxs-lookup"><span data-stu-id="859e4-239">Only the communication listeners and their associated code are necessary.</span></span> <span data-ttu-id="859e4-240">Da mesma forma, criar e retornar ouvintes de comunicação é opcional, pois o serviço pode ter apenas trabalho em segundo plano e só precisar implementar `RunAsync()`</span><span class="sxs-lookup"><span data-stu-id="859e4-240">Similarly, creating and returning communication listeners is optional, as the service may have only background work to do, and so only needs to implement `RunAsync()`</span></span>
  - <span data-ttu-id="859e4-241">Isso é válido para um serviço concluir `RunAsync()` com êxito e retornar dele.</span><span class="sxs-lookup"><span data-stu-id="859e4-241">It is valid for a service to complete `RunAsync()` successfully and return from it.</span></span> <span data-ttu-id="859e4-242">A conclusão não é uma condição de falha.</span><span class="sxs-lookup"><span data-stu-id="859e4-242">Completing is not a failure condition.</span></span> <span data-ttu-id="859e4-243">A conclusão de `RunAsync()` indica que o trabalho em segundo plano do serviço foi concluído.</span><span class="sxs-lookup"><span data-stu-id="859e4-243">Completing `RunAsync()` indicates that the background work of the service has completed.</span></span> <span data-ttu-id="859e4-244">Para serviços confiáveis com estado, `RunAsync()` será chamado novamente se a réplica tiver sido rebaixada de Primária para Secundária e promovida de volta para Primária.</span><span class="sxs-lookup"><span data-stu-id="859e4-244">For stateful reliable services, `RunAsync()` is called again if the replica were demoted from Primary to Secondary and then promoted back to Primary.</span></span>
  - <span data-ttu-id="859e4-245">Se um serviço sair de `RunAsync()` lançando uma exceção inesperada, isso constituirá uma falha.</span><span class="sxs-lookup"><span data-stu-id="859e4-245">If a service exits from `RunAsync()` by throwing some unexpected exception, this constitutes a failure.</span></span> <span data-ttu-id="859e4-246">O objeto de serviço será desligado e um erro de integridade reportado.</span><span class="sxs-lookup"><span data-stu-id="859e4-246">The service object is shut down and a health error reported.</span></span>
  - <span data-ttu-id="859e4-247">Embora não haja um limite de tempo para o retorno desses métodos, você perde imediatamente a capacidade de gravar em Reliable Collections e, portanto, não pode concluir qualquer trabalho real.</span><span class="sxs-lookup"><span data-stu-id="859e4-247">While there is no time limit on returning from these methods, you immediately lose the ability to write to Reliable Collections and therefore cannot complete any real work.</span></span> <span data-ttu-id="859e4-248">Recomendamos que você retorne o mais rápido possível após o recebimento da solicitação de cancelamento.</span><span class="sxs-lookup"><span data-stu-id="859e4-248">It is recommended that you return as quickly as possible upon receiving the cancellation request.</span></span> <span data-ttu-id="859e4-249">Se o serviço não responder a essas chamadas à API dentro de um período razoável, o Service Fabric poderá forçar o encerramento do serviço.</span><span class="sxs-lookup"><span data-stu-id="859e4-249">If your service does not respond to these API calls in a reasonable amount of time Service Fabric may forcibly terminate your service.</span></span> <span data-ttu-id="859e4-250">Geralmente isso ocorre apenas durante atualizações de aplicativo ou quando um serviço está sendo excluído.</span><span class="sxs-lookup"><span data-stu-id="859e4-250">Usually this only happens during application upgrades or when a service is being deleted.</span></span> <span data-ttu-id="859e4-251">Esse tempo limite é de 15 minutos por padrão.</span><span class="sxs-lookup"><span data-stu-id="859e4-251">This timeout is 15 minutes by default.</span></span>
  - <span data-ttu-id="859e4-252">Falhas no caminho de `OnCloseAsync()` resultam em uma chamada de `OnAbort()`, que é uma oportunidade de melhor esforço de última chance para o serviço ser limpo e liberar quaisquer recursos ocupados.</span><span class="sxs-lookup"><span data-stu-id="859e4-252">Failures in the `OnCloseAsync()` path result in `OnAbort()` being called which is a last-chance best-effort opportunity for the service to clean up and release any resources that they have claimed.</span></span>

## <a name="next-steps"></a><span data-ttu-id="859e4-253">Próximas etapas</span><span class="sxs-lookup"><span data-stu-id="859e4-253">Next steps</span></span>
- [<span data-ttu-id="859e4-254">Introdução ao Reliable Services</span><span class="sxs-lookup"><span data-stu-id="859e4-254">Introduction to Reliable Services</span></span>](service-fabric-reliable-services-introduction.md)
- [<span data-ttu-id="859e4-255">Início Rápido dos Serviços Confiáveis</span><span class="sxs-lookup"><span data-stu-id="859e4-255">Reliable Services quick start</span></span>](service-fabric-reliable-services-quick-start.md)
- [<span data-ttu-id="859e4-256">Uso avançado de Reliable Services</span><span class="sxs-lookup"><span data-stu-id="859e4-256">Reliable Services advanced usage</span></span>](service-fabric-reliable-services-advanced-usage.md)

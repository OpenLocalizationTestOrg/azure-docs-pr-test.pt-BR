---
title: "Visão Geral de Reliable Actors do Service Fabric | Microsoft Docs"
description: "Introdução ao modelo de programação dos Reliable Actors do Service Fabric."
services: service-fabric
documentationcenter: .net
author: vturecek
manager: timlt
editor: 
ms.assetid: 7fdad07f-f2d6-4c74-804d-e0d56131f060
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 06/29/2017
ms.author: vturecek
ms.openlocfilehash: e89be04a0d6fe90a89e293e67d42f0204eb7000a
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 07/11/2017
---
# <a name="introduction-to-service-fabric-reliable-actors"></a><span data-ttu-id="f805a-103">Introdução aos Reliable Actors do Service Fabric</span><span class="sxs-lookup"><span data-stu-id="f805a-103">Introduction to Service Fabric Reliable Actors</span></span>
<span data-ttu-id="f805a-104">Os Reliable Actors são uma estrutura do aplicativo do Service Fabric baseada no padrão de [Ator Virtual](http://research.microsoft.com/en-us/projects/orleans/).</span><span class="sxs-lookup"><span data-stu-id="f805a-104">Reliable Actors is a Service Fabric application framework based on the [Virtual Actor](http://research.microsoft.com/en-us/projects/orleans/) pattern.</span></span> <span data-ttu-id="f805a-105">A API dos Reliable Actors fornece um modelo de programação single-threaded fundamentado nas garantias de escalabilidade e confiabilidade fornecidas pelo Service Fabric.</span><span class="sxs-lookup"><span data-stu-id="f805a-105">The Reliable Actors API provides a single-threaded programming model built on the scalability and reliability guarantees provided by Service Fabric.</span></span>

## <a name="what-are-actors"></a><span data-ttu-id="f805a-106">O que são Atores?</span><span class="sxs-lookup"><span data-stu-id="f805a-106">What are Actors?</span></span>
<span data-ttu-id="f805a-107">Um ator é uma unidade isolada e independente de computação e de estado com execução single-threaded.</span><span class="sxs-lookup"><span data-stu-id="f805a-107">An actor is an isolated, independent unit of compute and state with single-threaded execution.</span></span> <span data-ttu-id="f805a-108">O [padrão de ator](https://en.wikipedia.org/wiki/Actor_model) é um modelo computacional para sistemas simultâneos ou distribuídos nos quais uma grande quantidade desses atores pode ser executada de modo simultâneo e independente entre si.</span><span class="sxs-lookup"><span data-stu-id="f805a-108">The [actor pattern](https://en.wikipedia.org/wiki/Actor_model) is a computational model for concurrent or distributed systems in which a large number of these actors can execute simultaneously and independently of each other.</span></span> <span data-ttu-id="f805a-109">Os atores podem se comunicar entre si e criar outros atores.</span><span class="sxs-lookup"><span data-stu-id="f805a-109">Actors can communicate with each other and they can create more actors.</span></span>

### <a name="when-to-use-reliable-actors"></a><span data-ttu-id="f805a-110">Quando usar os Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="f805a-110">When to use Reliable Actors</span></span>
<span data-ttu-id="f805a-111">Os Reliable Actors do Service Fabric são uma implementação do padrão de design de ator.</span><span class="sxs-lookup"><span data-stu-id="f805a-111">Service Fabric Reliable Actors is an implementation of the actor design pattern.</span></span> <span data-ttu-id="f805a-112">Assim como ocorre com qualquer padrão de design de software, a escolha de determinado padrão leva em conta se um problema relacionado ao design de software é adequado ao padrão ou não.</span><span class="sxs-lookup"><span data-stu-id="f805a-112">As with any software design pattern, the decision whether to use a specific pattern is made based on whether or not a software design problem fits the pattern.</span></span>

<span data-ttu-id="f805a-113">Embora o padrão de design de ator possa ser uma boa opção para diversos problemas e cenários de sistemas distribuídos, deve-se ter bastante cuidado no que diz respeito às restrições do padrão e à estrutura utilizada para a implementação.</span><span class="sxs-lookup"><span data-stu-id="f805a-113">Although the actor design pattern can be a good fit to a number of distributed systems problems and scenarios, careful consideration of the constraints of the pattern and the framework implementing it must be made.</span></span> <span data-ttu-id="f805a-114">Como diretriz geral, considere o padrão de ator para modelar seu problema ou cenário se:</span><span class="sxs-lookup"><span data-stu-id="f805a-114">As general guidance, consider the actor pattern to model your problem or scenario if:</span></span>

* <span data-ttu-id="f805a-115">Seu problema de espaço envolve um grande número (milhares ou milhões) de pequenas unidades de estado e lógica que, além de serem independentes, são isoladas.</span><span class="sxs-lookup"><span data-stu-id="f805a-115">Your problem space involves a large number (thousands or more) of small, independent, and isolated units of state and logic.</span></span>
* <span data-ttu-id="f805a-116">Você deseja trabalhar com objetos single-threaded que não exigem interação significativa de componentes externos, incluindo a consulta de estado em um conjunto de atores.</span><span class="sxs-lookup"><span data-stu-id="f805a-116">You want to work with single-threaded objects that do not require significant interaction from external components, including querying state across a set of actors.</span></span>
* <span data-ttu-id="f805a-117">Suas instâncias de ator não bloquearão chamadores com atrasos imprevisíveis emitindo operações de E/S.</span><span class="sxs-lookup"><span data-stu-id="f805a-117">Your actor instances won't block callers with unpredictable delays by issuing I/O operations.</span></span>

## <a name="actors-in-service-fabric"></a><span data-ttu-id="f805a-118">Atores no Service Fabric</span><span class="sxs-lookup"><span data-stu-id="f805a-118">Actors in Service Fabric</span></span>
<span data-ttu-id="f805a-119">No Service Fabric, os atores são implementados na estrutura dos Reliable Actors: uma estrutura do aplicativo baseada no padrão de ator criada nos [Reliable Services do Service Fabric](service-fabric-reliable-services-introduction.md).</span><span class="sxs-lookup"><span data-stu-id="f805a-119">In Service Fabric, actors are implemented in the Reliable Actors framework: An actor-pattern-based application framework built on top of [Service Fabric Reliable Services](service-fabric-reliable-services-introduction.md).</span></span> <span data-ttu-id="f805a-120">Cada serviço escrito do Reliable Actor é, de fato, um Reliable Service com estado particionado.</span><span class="sxs-lookup"><span data-stu-id="f805a-120">Each Reliable Actor service you write is actually a partitioned, stateful Reliable Service.</span></span>

<span data-ttu-id="f805a-121">Cada ator é definido como uma instância de um tipo de ator, da mesma forma que um objeto do .NET é uma instância de um tipo do .NET.</span><span class="sxs-lookup"><span data-stu-id="f805a-121">Every actor is defined as an instance of an actor type, identical to the way a .NET object is an instance of a .NET type.</span></span> <span data-ttu-id="f805a-122">Por exemplo, pode haver um tipo de ator que implementa a funcionalidade de uma calculadora e pode haver muitos atores desse tipo que são distribuídos em vários nós em um cluster.</span><span class="sxs-lookup"><span data-stu-id="f805a-122">For example, there may be an actor type that implements the functionality of a calculator and there could be many actors of that type that are distributed on various nodes across a cluster.</span></span> <span data-ttu-id="f805a-123">Cada ator desse é exclusivamente identificado por uma ID de ator.</span><span class="sxs-lookup"><span data-stu-id="f805a-123">Each such actor is uniquely identified by an actor ID.</span></span>

### <a name="actor-lifetime"></a><span data-ttu-id="f805a-124">Tempo de vida do ator</span><span class="sxs-lookup"><span data-stu-id="f805a-124">Actor Lifetime</span></span>
<span data-ttu-id="f805a-125">Os atores de Malha de Serviço são virtuais, o que significa que o tempo de vida não está associado à sua representação na memória.</span><span class="sxs-lookup"><span data-stu-id="f805a-125">Service Fabric actors are virtual, meaning that their lifetime is not tied to their in-memory representation.</span></span> <span data-ttu-id="f805a-126">Como resultado, eles não precisam ser explicitamente criados ou destruídos.</span><span class="sxs-lookup"><span data-stu-id="f805a-126">As a result, they do not need to be explicitly created or destroyed.</span></span> <span data-ttu-id="f805a-127">O tempo de execução dos Reliable Actors ativa automaticamente um ator na primeira vez que ele recebe uma solicitação para essa ID de ator.</span><span class="sxs-lookup"><span data-stu-id="f805a-127">The Reliable Actors runtime automatically activates an actor the first time it receives a request for that actor ID.</span></span> <span data-ttu-id="f805a-128">Caso um ator não seja usado por determinado período de tempo, o objeto na memória é coletado como lixo pelo tempo de execução dos Reliable Actors.</span><span class="sxs-lookup"><span data-stu-id="f805a-128">If an actor is not used for a period of time, the Reliable Actors runtime garbage-collects the in-memory object.</span></span> <span data-ttu-id="f805a-129">Ele também mantém a informação da existência do ator caso seja necessário reativá-lo mais tarde.</span><span class="sxs-lookup"><span data-stu-id="f805a-129">It will also maintain knowledge of the actor's existence should it need to be reactivated later.</span></span> <span data-ttu-id="f805a-130">Para obter mais detalhes, veja [Ciclo de vida do ator e coleta de lixo](service-fabric-reliable-actors-lifecycle.md).</span><span class="sxs-lookup"><span data-stu-id="f805a-130">For more details, see [Actor lifecycle and garbage collection](service-fabric-reliable-actors-lifecycle.md).</span></span>

<span data-ttu-id="f805a-131">Em virtude do modelo de ator virtual, há alguns alertas para a abstração do tempo de vida desse ator virtual. De fato, a implementação dos Reliable Actors, às vezes, desvia desse modelo.</span><span class="sxs-lookup"><span data-stu-id="f805a-131">This virtual actor lifetime abstraction carries some caveats as a result of the virtual actor model, and in fact the Reliable Actors implementation deviates at times from this model.</span></span>

* <span data-ttu-id="f805a-132">Um ator é ativado automaticamente (possibilitando a construção de um objeto de ator) na primeira vez que uma mensagem é enviada à sua ID de ator.</span><span class="sxs-lookup"><span data-stu-id="f805a-132">An actor is automatically activated (causing an actor object to be constructed) the first time a message is sent to its actor ID.</span></span> <span data-ttu-id="f805a-133">Após algum tempo, o objeto de ator é coletado como lixo.</span><span class="sxs-lookup"><span data-stu-id="f805a-133">After some period of time, the actor object is garbage collected.</span></span> <span data-ttu-id="f805a-134">No futuro, ao usar a ID de ator novamente, isso faz com que um novo objeto de ator seja construído.</span><span class="sxs-lookup"><span data-stu-id="f805a-134">In the future, using the actor ID again, causes a new actor object to be constructed.</span></span> <span data-ttu-id="f805a-135">O estado de um ator é maior que o tempo de vida do objeto quando ele é armazenado no gerenciador de estado.</span><span class="sxs-lookup"><span data-stu-id="f805a-135">An actor's state outlives the object's lifetime when stored in the state manager.</span></span>
* <span data-ttu-id="f805a-136">A chamada a qualquer método de ator para obter uma ID de ator ativa esse ator.</span><span class="sxs-lookup"><span data-stu-id="f805a-136">Calling any actor method for an actor ID activates that actor.</span></span> <span data-ttu-id="f805a-137">Por esse motivo, os tipos de ator têm seus construtores chamados implicitamente pelo tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="f805a-137">For this reason, actor types have their constructor called implicitly by the runtime.</span></span> <span data-ttu-id="f805a-138">Portanto, o código cliente não pode passar parâmetros ao construtor do tipo de ator, embora os parâmetros possam ser passados para o construtor do ator pelo próprio serviço.</span><span class="sxs-lookup"><span data-stu-id="f805a-138">Therefore, client code cannot pass parameters to the actor type's constructor, although parameters may be passed to the actor's constructor by the service itself.</span></span> <span data-ttu-id="f805a-139">O resultado é que os atores poderão ser construídos em um estado parcialmente inicializado quando os outros métodos forem chamados neles, caso os atores exijam parâmetros de inicialização do cliente.</span><span class="sxs-lookup"><span data-stu-id="f805a-139">The result is that actors may be constructed in a partially-initialized state by the time other methods are called on it, if the actor requires initialization parameters from the client.</span></span> <span data-ttu-id="f805a-140">Não há um ponto de entrada único para a ativação de um ator por meio do cliente.</span><span class="sxs-lookup"><span data-stu-id="f805a-140">There is no single entry point for the activation of an actor from the client.</span></span>
* <span data-ttu-id="f805a-141">Embora os Reliable Actors criem implicitamente objetos de ator, você tem a capacidade de excluir explicitamente um ator e seu estado.</span><span class="sxs-lookup"><span data-stu-id="f805a-141">Although Reliable Actors implicitly create actor objects; you do have the ability to explicitly delete an actor and its state.</span></span>

### <a name="distribution-and-failover"></a><span data-ttu-id="f805a-142">Distribuição e failover</span><span class="sxs-lookup"><span data-stu-id="f805a-142">Distribution and failover</span></span>
<span data-ttu-id="f805a-143">Para fornecer escalabilidade e confiabilidade, o Service Fabric distribui atores em todo o cluster e os migra automaticamente de nós com falha para nós íntegros conforme necessário.</span><span class="sxs-lookup"><span data-stu-id="f805a-143">To provide scalability and reliability, Service Fabric distributes actors throughout the cluster and automatically migrates them from failed nodes to healthy ones as required.</span></span> <span data-ttu-id="f805a-144">Essa é uma abstração de um [Reliable Service com estado particionado](service-fabric-concepts-partitioning.md).</span><span class="sxs-lookup"><span data-stu-id="f805a-144">This is an abstraction over a [partitioned, stateful Reliable Service](service-fabric-concepts-partitioning.md).</span></span> <span data-ttu-id="f805a-145">Distribuição, escalabilidade, confiabilidade e failover automático são todos fornecidos em virtude do fato de que os atores são executados em um Reliable Service com estado chamado *Serviço de Ator*.</span><span class="sxs-lookup"><span data-stu-id="f805a-145">Distribution, scalability, reliability, and automatic failover are all provided by virtue of the fact that actors are running inside a stateful Reliable Service called the *Actor Service*.</span></span>

<span data-ttu-id="f805a-146">Os atores são distribuídos entre as partições do Serviço de Ator que, por sua vez, são distribuídas entre os nós em um cluster do Service Fabric.</span><span class="sxs-lookup"><span data-stu-id="f805a-146">Actors are distributed across the partitions of the Actor Service, and those partitions are distributed across the nodes in a Service Fabric cluster.</span></span> <span data-ttu-id="f805a-147">Cada partição de serviço contém um conjunto de atores.</span><span class="sxs-lookup"><span data-stu-id="f805a-147">Each service partition contains a set of actors.</span></span> <span data-ttu-id="f805a-148">O Service Fabric gerencia a distribuição e o failover das partições de serviço.</span><span class="sxs-lookup"><span data-stu-id="f805a-148">Service Fabric manages distribution and failover of the service partitions.</span></span>

<span data-ttu-id="f805a-149">Por exemplo, um serviço de ator com nove partições implantadas em três nós usando o posicionamento padrão de partição de ator seria distribuído deste modo:</span><span class="sxs-lookup"><span data-stu-id="f805a-149">For example, an actor service with nine partitions deployed to three nodes using the default actor partition placement would be distributed thusly:</span></span>

![Distribuição dos Reliable Actors][2]

<span data-ttu-id="f805a-151">A Estrutura de Ator gerencia o esquema de partição e as configurações de intervalo de chaves para você.</span><span class="sxs-lookup"><span data-stu-id="f805a-151">The Actor Framework manages partition scheme and key range settings for you.</span></span> <span data-ttu-id="f805a-152">Isso simplifica algumas escolhas, mas também traz algumas considerações:</span><span class="sxs-lookup"><span data-stu-id="f805a-152">This simplifies some choices but also carries some consideration:</span></span>

* <span data-ttu-id="f805a-153">Os Reliable Services permitem escolher um esquema de particionamento, um intervalo de chaves (ao usar um esquema de particionamento de intervalos) e uma contagem de partições.</span><span class="sxs-lookup"><span data-stu-id="f805a-153">Reliable Services allows you to choose a partitioning scheme, key range (when using a range partitioning scheme), and partition count.</span></span> <span data-ttu-id="f805a-154">Os Reliable Actors são restritos ao esquema de particionamento de intervalos (o esquema Int64 uniforme) e exige o uso do intervalo de chaves Int64 completo.</span><span class="sxs-lookup"><span data-stu-id="f805a-154">Reliable Actors is restricted to the range partitioning scheme (the uniform Int64 scheme) and requires you use the full Int64 key range.</span></span>
* <span data-ttu-id="f805a-155">Por padrão, os atores são colocados aleatoriamente em partições, resultando em uma distribuição uniforme.</span><span class="sxs-lookup"><span data-stu-id="f805a-155">By default, actors are randomly placed into partitions resulting in uniform distribution.</span></span>
* <span data-ttu-id="f805a-156">Como os atores são colocados aleatoriamente, deve-se esperar que as operações de ator sempre exijam a comunicação de rede, incluindo a serialização e desserialização de dados de chamada de método, incorrendo em latência e sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="f805a-156">Because actors are randomly placed, it should be expected that actor operations will always require network communication, including serialization and deserialization of method call data, incurring latency and overhead.</span></span>
* <span data-ttu-id="f805a-157">Em cenários avançados, é possível controlar o posicionamento de partições de ator usando IDs de ator do tipo Int64 que são mapeadas para partições específicas.</span><span class="sxs-lookup"><span data-stu-id="f805a-157">In advanced scenarios, it is possible to control actor partition placement by using Int64 actor IDs that map to specific partitions.</span></span> <span data-ttu-id="f805a-158">No entanto, isso poderá resultar em uma distribuição desbalanceada de atores nas partições.</span><span class="sxs-lookup"><span data-stu-id="f805a-158">However, doing so can result in an unbalanced distribution of actors across partitions.</span></span>

<span data-ttu-id="f805a-159">Para obter mais informações sobre como os serviços de ator são particionados, veja [conceitos de particionamento para atores](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).</span><span class="sxs-lookup"><span data-stu-id="f805a-159">For more information on how actor services are partitioned, refer to [partitioning concepts for actors](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).</span></span>

### <a name="actor-communication"></a><span data-ttu-id="f805a-160">Comunicação do ator</span><span class="sxs-lookup"><span data-stu-id="f805a-160">Actor communication</span></span>
<span data-ttu-id="f805a-161">As interações de ator são definidas em uma interface compartilhada pelo ator que implementa a interface e pelo cliente que obtém um proxy para um ator pela mesma interface.</span><span class="sxs-lookup"><span data-stu-id="f805a-161">Actor interactions are defined in an interface that is shared by the actor that implements the interface, and the client that gets a proxy to an actor via the same interface.</span></span> <span data-ttu-id="f805a-162">Como essa interface é usada para invocar métodos de ator de forma assíncrona, cada método na interface deve ser do tipo Retorno de tarefas.</span><span class="sxs-lookup"><span data-stu-id="f805a-162">Because this interface is used to invoke actor methods asynchronously, every method on the interface must be Task-returning.</span></span>

<span data-ttu-id="f805a-163">As invocações de método e suas respostas resultam, em última análise, em solicitações de rede no cluster; portanto, os argumentos e os tipos de resultado das tarefas retornados por elas devem ser serializáveis pela plataforma.</span><span class="sxs-lookup"><span data-stu-id="f805a-163">Method invocations and their responses ultimately result in network requests across the cluster, so the arguments and the result types of the tasks that they return must be serializable by the platform.</span></span> <span data-ttu-id="f805a-164">Em particular, eles devem ser [contrato de dados serializáveis](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="f805a-164">In particular, they must be [data contract serializable](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span></span>

#### <a name="the-actor-proxy"></a><span data-ttu-id="f805a-165">O proxy de ator</span><span class="sxs-lookup"><span data-stu-id="f805a-165">The actor proxy</span></span>
<span data-ttu-id="f805a-166">A API do cliente Reliable Actors permite a comunicação entre uma instância do ator e um cliente do ator.</span><span class="sxs-lookup"><span data-stu-id="f805a-166">The Reliable Actors client API provides communication between an actor instance and an actor client.</span></span> <span data-ttu-id="f805a-167">Para se comunicar com um ator, um cliente cria um objeto proxy de ator que implementa a interface do ator.</span><span class="sxs-lookup"><span data-stu-id="f805a-167">To communicate with an actor, a client creates an actor proxy object that implements the actor interface.</span></span> <span data-ttu-id="f805a-168">O cliente interage com o ator invocando métodos no objeto proxy.</span><span class="sxs-lookup"><span data-stu-id="f805a-168">The client interacts with the actor by invoking methods on the proxy object.</span></span> <span data-ttu-id="f805a-169">O proxy de ator pode ser usado para a comunicação entre cliente e ator, bem como entre ator e ator.</span><span class="sxs-lookup"><span data-stu-id="f805a-169">The actor proxy can be used for client-to-actor and actor-to-actor communication.</span></span>

```csharp
// Create a randomly distributed actor ID
ActorId actorId = ActorId.CreateRandom();

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
IMyActor myActor = ActorProxy.Create<IMyActor>(actorId, new Uri("fabric:/MyApp/MyActorService"));

// This will invoke a method on the actor. If an actor with the given ID does not exist, it will be activated by this method call.
await myActor.DoWorkAsync();
```

```java
// Create actor ID with some name
ActorId actorId = new ActorId("Actor1");

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
MyActor myActor = ActorProxyBase.create(actorId, new URI("fabric:/MyApp/MyActorService"), MyActor.class);

// This will invoke a method on the actor. If an actor with the given ID does not exist, it will be activated by this method call.
myActor.DoWorkAsync().get();
```


<span data-ttu-id="f805a-170">Observe que os dois conjuntos de informações usadas para criar o objeto de proxy de ator são a ID do ator e o nome do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="f805a-170">Note that the two pieces of information used to create the actor proxy object are the actor ID and the application name.</span></span> <span data-ttu-id="f805a-171">A ID de ator é um identificador exclusivo do ator, enquanto o nome do aplicativo identifica o [aplicativo do Service Fabric](service-fabric-reliable-actors-platform.md#application-model) em que o ator foi implantado.</span><span class="sxs-lookup"><span data-stu-id="f805a-171">The actor ID uniquely identifies the actor, while the application name identifies the [Service Fabric application](service-fabric-reliable-actors-platform.md#application-model) where the actor is deployed.</span></span>

<span data-ttu-id="f805a-172">A classe `ActorProxy`(C#) / `ActorProxyBase`(Java) do lado do cliente executa a resolução necessária para localizar o ator por ID e abrir um canal de comunicação com ele.</span><span class="sxs-lookup"><span data-stu-id="f805a-172">The `ActorProxy`(C#) / `ActorProxyBase`(Java) class on the client side performs the necessary resolution to locate the actor by ID and open a communication channel with it.</span></span> <span data-ttu-id="f805a-173">Ela também tenta localizar novamente o ator no caso de falhas de comunicação e failovers.</span><span class="sxs-lookup"><span data-stu-id="f805a-173">It also retries to locate the actor in the cases of communication failures and failovers.</span></span> <span data-ttu-id="f805a-174">Como resultado, a entrega de mensagem tem as seguintes características:</span><span class="sxs-lookup"><span data-stu-id="f805a-174">As a result, message delivery has the following characteristics:</span></span>

* <span data-ttu-id="f805a-175">A entrega de mensagem é o melhor esforço.</span><span class="sxs-lookup"><span data-stu-id="f805a-175">Message delivery is best effort.</span></span>
* <span data-ttu-id="f805a-176">Os atores podem receber mensagens duplicadas do mesmo cliente.</span><span class="sxs-lookup"><span data-stu-id="f805a-176">Actors may receive duplicate messages from the same client.</span></span>

### <a name="concurrency"></a><span data-ttu-id="f805a-177">Simultaneidade</span><span class="sxs-lookup"><span data-stu-id="f805a-177">Concurrency</span></span>
<span data-ttu-id="f805a-178">O tempo de execução dos Reliable Actors fornece um modelo de acesso baseado em turno simples para acessar os métodos de ator.</span><span class="sxs-lookup"><span data-stu-id="f805a-178">The Reliable Actors runtime provides a simple turn-based access model for accessing actor methods.</span></span> <span data-ttu-id="f805a-179">Isso significa que não é permitido mais de um thread ativo no código do objeto de um ator a qualquer momento.</span><span class="sxs-lookup"><span data-stu-id="f805a-179">This means that no more than one thread can be active inside an actor object's code at any time.</span></span> <span data-ttu-id="f805a-180">O acesso baseado em turno simplifica consideravelmente os sistemas simultâneos, pois não há necessidade de mecanismos de sincronização para o acesso a dados.</span><span class="sxs-lookup"><span data-stu-id="f805a-180">Turn-based access greatly simplifies concurrent systems as there is no need for synchronization mechanisms for data access.</span></span> <span data-ttu-id="f805a-181">Isso também significa que os sistemas devem ser projetados com considerações especiais sobre a natureza do acesso single-threaded de cada instância de ator.</span><span class="sxs-lookup"><span data-stu-id="f805a-181">It also means systems must be designed with special considerations for the single-threaded access nature of each actor instance.</span></span>

* <span data-ttu-id="f805a-182">Uma única instância de ator não pode processar mais de uma solicitação por vez.</span><span class="sxs-lookup"><span data-stu-id="f805a-182">A single actor instance cannot process more than one request at a time.</span></span> <span data-ttu-id="f805a-183">Uma instância de ator poderá causar um afunilamento da taxa de transferência se tiver de manipular solicitações simultâneas.</span><span class="sxs-lookup"><span data-stu-id="f805a-183">An actor instance can cause a throughput bottleneck if it is expected to handle concurrent requests.</span></span>
* <span data-ttu-id="f805a-184">Os atores poderão causar um deadlock mútuo se houver uma solicitação circular entre dois atores enquanto uma solicitação externa é feita para um dos atores simultaneamente.</span><span class="sxs-lookup"><span data-stu-id="f805a-184">Actors can deadlock on each other if there is a circular request between two actors while an external request is made to one of the actors simultaneously.</span></span> <span data-ttu-id="f805a-185">O tempo de execução do ator atingirá automaticamente o tempo limite nas chamadas de ator e gerará uma exceção ao chamador para que este interrompa as possíveis situações de deadlock.</span><span class="sxs-lookup"><span data-stu-id="f805a-185">The actor runtime will automatically time out on actor calls and throw an exception to the caller to interrupt possible deadlock situations.</span></span>

![Comunicação dos Reliable Actors][3]

#### <a name="turn-based-access"></a><span data-ttu-id="f805a-187">Acesso com base em vez</span><span class="sxs-lookup"><span data-stu-id="f805a-187">Turn-based access</span></span>
<span data-ttu-id="f805a-188">Um turno consiste na execução completa de um método de ator em resposta a uma solicitação de outros atores ou clientes, ou na execução completa de um retorno de chamada de [temporizador/lembrete](service-fabric-reliable-actors-timers-reminders.md) .</span><span class="sxs-lookup"><span data-stu-id="f805a-188">A turn consists of the complete execution of an actor method in response to a request from other actors or clients, or the complete execution of a [timer/reminder](service-fabric-reliable-actors-timers-reminders.md) callback.</span></span> <span data-ttu-id="f805a-189">Mesmo que esses métodos e retornos de chamada sejam assíncronos, o tempo de execução dos Atores não os intercala.</span><span class="sxs-lookup"><span data-stu-id="f805a-189">Even though these methods and callbacks are asynchronous, the Actors runtime does not interleave them.</span></span> <span data-ttu-id="f805a-190">Um turno deve ser totalmente concluído antes que um novo turno seja permitido.</span><span class="sxs-lookup"><span data-stu-id="f805a-190">A turn must be fully finished before a new turn is allowed.</span></span> <span data-ttu-id="f805a-191">Em outras palavras, um método de ator ou retorno de chamada de temporizador/lembrete que está em execução no momento deve ser concluído totalmente antes que uma nova chamada a um método ou um retorno de chamada seja permitido.</span><span class="sxs-lookup"><span data-stu-id="f805a-191">In other words, an actor method or timer/reminder callback that is currently executing must be fully finished before a new call to a method or callback is allowed.</span></span> <span data-ttu-id="f805a-192">Um método ou retorno de chamada será considerado concluído se a execução tiver sido retornada do método ou retorno de chamada, e a Tarefa retornada pelo método ou retorno de chamada tiver sido concluída.</span><span class="sxs-lookup"><span data-stu-id="f805a-192">A method or callback is considered to have finished if the execution has returned from the method or callback and the task returned by the method or callback has finished.</span></span> <span data-ttu-id="f805a-193">Vale enfatizar que a simultaneidade baseada em turno é respeitada mesmo entre métodos, temporizadores e retornos de chamada diferentes.</span><span class="sxs-lookup"><span data-stu-id="f805a-193">It is worth emphasizing that turn-based concurrency is respected even across different methods, timers, and callbacks.</span></span>

<span data-ttu-id="f805a-194">O tempo de execução dos Atores impõe simultaneidade baseada em turno adquirindo um bloqueio por ator no início de um turno e liberando o bloqueio no fim do turno.</span><span class="sxs-lookup"><span data-stu-id="f805a-194">The Actors runtime enforces turn-based concurrency by acquiring a per-actor lock at the beginning of a turn and releasing the lock at the end of the turn.</span></span> <span data-ttu-id="f805a-195">Desse modo, a simultaneidade baseada em turno é imposta por ator e não entre atores.</span><span class="sxs-lookup"><span data-stu-id="f805a-195">Thus, turn-based concurrency is enforced on a per-actor basis and not across actors.</span></span> <span data-ttu-id="f805a-196">Os métodos de ator e retornos de chamada de temporizador/lembrete podem ser executados simultaneamente em nome de diferentes atores.</span><span class="sxs-lookup"><span data-stu-id="f805a-196">Actor methods and timer/reminder callbacks can execute simultaneously on behalf of different actors.</span></span>

<span data-ttu-id="f805a-197">O exemplo a seguir ilustra os conceitos acima.</span><span class="sxs-lookup"><span data-stu-id="f805a-197">The following example illustrates the above concepts.</span></span> <span data-ttu-id="f805a-198">Considere um tipo de ator que implementa dois métodos assíncronos (digamos, *Method1* e *Method2*), um temporizador e um lembrete.</span><span class="sxs-lookup"><span data-stu-id="f805a-198">Consider an actor type that implements two asynchronous methods (say, *Method1* and *Method2*), a timer, and a reminder.</span></span> <span data-ttu-id="f805a-199">O diagrama abaixo mostra um exemplo de uma linha do tempo para a execução desses métodos e retornos de chamada em nome de dois atores (*ActorId1* e *ActorId2*) que pertencem a esse tipo de ator.</span><span class="sxs-lookup"><span data-stu-id="f805a-199">The diagram below shows an example of a timeline for the execution of these methods and callbacks on behalf of two actors (*ActorId1* and *ActorId2*) that belong to this actor type.</span></span>

![Simultaneidade e acesso com base em turno do Reliable Actors][1]

<span data-ttu-id="f805a-201">O diagrama segue as seguintes convenções:</span><span class="sxs-lookup"><span data-stu-id="f805a-201">This diagram follows these conventions:</span></span>

* <span data-ttu-id="f805a-202">Cada linha vertical mostra o fluxo lógico de execução de um método ou um retorno de chamada em nome de um ator específico.</span><span class="sxs-lookup"><span data-stu-id="f805a-202">Each vertical line shows the logical flow of execution of a method or a callback on behalf of a particular actor.</span></span>
* <span data-ttu-id="f805a-203">Os eventos marcados em cada linha vertical ocorrem em ordem cronológica com os eventos mais recentes ocorrendo abaixo dos mais antigos.</span><span class="sxs-lookup"><span data-stu-id="f805a-203">The events marked on each vertical line occur in chronological order, with newer events occurring below older ones.</span></span>
* <span data-ttu-id="f805a-204">As diferentes cores são usadas para linhas do tempo que correspondem a diferentes atores.</span><span class="sxs-lookup"><span data-stu-id="f805a-204">Different colors are used for timelines corresponding to different actors.</span></span>
* <span data-ttu-id="f805a-205">O realce é usado para indicar por quanto tempo o bloqueio por ator é mantido em nome de um método ou retorno de chamada.</span><span class="sxs-lookup"><span data-stu-id="f805a-205">Highlighting is used to indicate the duration for which the per-actor lock is held on behalf of a method or callback.</span></span>

<span data-ttu-id="f805a-206">Alguns pontos importantes a considerar:</span><span class="sxs-lookup"><span data-stu-id="f805a-206">Some important points to consider:</span></span>

* <span data-ttu-id="f805a-207">Enquanto *Method1* está sendo executado em nome de *ActorId2* em resposta à solicitação do cliente *xyz789*, outra solicitação de cliente (*abc123*) chega e também exige que *Method1* seja executado por *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="f805a-207">While *Method1* is executing on behalf of *ActorId2* in response to client request *xyz789*, another client request (*abc123*) arrives that also requires *Method1* to be executed by *ActorId2*.</span></span> <span data-ttu-id="f805a-208">No entanto, a segunda execução de *Method1* não é iniciada até que a execução anterior seja concluída.</span><span class="sxs-lookup"><span data-stu-id="f805a-208">However, the second execution of *Method1* does not begin until the prior execution has finished.</span></span> <span data-ttu-id="f805a-209">Da mesma forma, um lembrete registrado por *ActorId2* é acionado enquanto *Method1* está sendo executado em resposta à solicitação do cliente *xyz789*.</span><span class="sxs-lookup"><span data-stu-id="f805a-209">Similarly, a reminder registered by *ActorId2* fires while *Method1* is being executed in response to client request *xyz789*.</span></span> <span data-ttu-id="f805a-210">O retorno de chamada de lembrete é executado somente depois que ambas as execuções de *Method1* são concluídas.</span><span class="sxs-lookup"><span data-stu-id="f805a-210">The reminder callback is executed only after both executions of *Method1* are complete.</span></span> <span data-ttu-id="f805a-211">Tudo isso se deve à simultaneidade baseada em turno que está sendo imposta para *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="f805a-211">All of this is due to turn-based concurrency being enforced for *ActorId2*.</span></span>
* <span data-ttu-id="f805a-212">Da mesma forma, a simultaneidade baseada em turno também é imposta para *ActorId1*, como demonstrado pela execução de *Method1*, *Method2* e do retorno de chamada do temporizador em nome de *ActorId1* que ocorre de maneira serial.</span><span class="sxs-lookup"><span data-stu-id="f805a-212">Similarly, turn-based concurrency is also enforced for *ActorId1*, as demonstrated by the execution of *Method1*, *Method2*, and the timer callback on behalf of *ActorId1* happening in a serial fashion.</span></span>
* <span data-ttu-id="f805a-213">A execução de *Method1* em nome de *ActorId1* é sobreposta por sua execução em nome de *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="f805a-213">Execution of *Method1* on behalf of *ActorId1* overlaps with its execution on behalf of *ActorId2*.</span></span> <span data-ttu-id="f805a-214">Isso porque a simultaneidade baseada em turno é imposta apenas em um ator, e não entre atores.</span><span class="sxs-lookup"><span data-stu-id="f805a-214">This is because turn-based concurrency is enforced only within an actor and not across actors.</span></span>
* <span data-ttu-id="f805a-215">Em algumas das execuções de método/retorno de chamada, a `Task`(C#) / `CompletableFuture`(Java) retornada pelo método/retorno de chamada é concluída após o retorno do método.</span><span class="sxs-lookup"><span data-stu-id="f805a-215">In some of the method/callback executions, the `Task`(C#) / `CompletableFuture`(Java) returned by the method/callback finishes after the method returns.</span></span> <span data-ttu-id="f805a-216">Em outras, a operação assíncrona já terá sido concluída quando o método/retorno de chamada for retornado.</span><span class="sxs-lookup"><span data-stu-id="f805a-216">In some others, the asynchronous operation has already finished by the time the method/callback returns.</span></span> <span data-ttu-id="f805a-217">Em ambos os casos, o bloqueio por ator será liberado apenas depois que o método e o retorno de chamada forem retornados e a operação assíncrona for concluída.</span><span class="sxs-lookup"><span data-stu-id="f805a-217">In both cases, the per-actor lock is released only after both the method/callback returns and the asynchronous operation finishes.</span></span>

#### <a name="reentrancy"></a><span data-ttu-id="f805a-218">Reentrada</span><span class="sxs-lookup"><span data-stu-id="f805a-218">Reentrancy</span></span>
<span data-ttu-id="f805a-219">O tempo de execução dos Atores permite reentrância por padrão.</span><span class="sxs-lookup"><span data-stu-id="f805a-219">The Actors runtime allows reentrancy by default.</span></span> <span data-ttu-id="f805a-220">Isso significa que, se um método de ator do *Ator A* chamar um método no *Ator B*, que, por sua vez, chamar outro método no *Ator A*, esse método terá permissão para ser executado.</span><span class="sxs-lookup"><span data-stu-id="f805a-220">This means that if an actor method of *Actor A* calls a method on *Actor B*, which in turn calls another method on *Actor A*, that method is allowed to run.</span></span> <span data-ttu-id="f805a-221">Isso ocorre porque ele faz parte do mesmo contexto lógico da cadeia de chamadas.</span><span class="sxs-lookup"><span data-stu-id="f805a-221">This is because it is part of the same logical call-chain context.</span></span> <span data-ttu-id="f805a-222">Todas as chamadas de temporizador e lembrete começam com o novo contexto lógico de chamada.</span><span class="sxs-lookup"><span data-stu-id="f805a-222">All timer and reminder calls start with the new logical call context.</span></span> <span data-ttu-id="f805a-223">Veja [Reentrância dos Reliable Actors](service-fabric-reliable-actors-reentrancy.md) para obter mais detalhes.</span><span class="sxs-lookup"><span data-stu-id="f805a-223">See the [Reliable Actors reentrancy](service-fabric-reliable-actors-reentrancy.md) for more details.</span></span>

#### <a name="scope-of-concurrency-guarantees"></a><span data-ttu-id="f805a-224">Escopo de garantias de simultaneidade</span><span class="sxs-lookup"><span data-stu-id="f805a-224">Scope of concurrency guarantees</span></span>
<span data-ttu-id="f805a-225">O tempo de execução dos Atores fornece essas garantias de simultaneidade em situações em que ele controla a invocação desses métodos.</span><span class="sxs-lookup"><span data-stu-id="f805a-225">The Actors runtime provides these concurrency guarantees in situations where it controls the invocation of these methods.</span></span> <span data-ttu-id="f805a-226">Por exemplo, ele fornece essas garantias para as invocações de método que são feitas em resposta à solicitação de cliente, bem como para retornos de chamada de temporizador e lembrete.</span><span class="sxs-lookup"><span data-stu-id="f805a-226">For example, it provides these guarantees for the method invocations that are done in response to a client request, as well as for timer and reminder callbacks.</span></span> <span data-ttu-id="f805a-227">No entanto, se o código de ator envolver diretamente esses métodos fora dos mecanismos fornecidos pelo tempo de execução dos Atores, o tempo de execução não poderá fornecer nenhuma garantia de simultaneidade.</span><span class="sxs-lookup"><span data-stu-id="f805a-227">However, if the actor code directly invokes these methods outside of the mechanisms provided by the Actors runtime, then the runtime cannot provide any concurrency guarantees.</span></span> <span data-ttu-id="f805a-228">Por exemplo, se o método for invocado no contexto de alguma tarefa que não está associada à tarefa retornada pelos métodos de ator, o tempo de execução não poderá fornecer garantias de simultaneidade.</span><span class="sxs-lookup"><span data-stu-id="f805a-228">For example, if the method is invoked in the context of some task that is not associated with the task returned by the actor methods, then the runtime cannot provide concurrency guarantees.</span></span> <span data-ttu-id="f805a-229">Se o método for chamado de um thread criado pelo ator por conta própria, o tempo de execução também não poderá fornecer garantias de simultaneidade.</span><span class="sxs-lookup"><span data-stu-id="f805a-229">If the method is invoked from a thread that the actor creates on its own, then the runtime also cannot provide concurrency guarantees.</span></span> <span data-ttu-id="f805a-230">Portanto, para executar operações em segundo plano, os atores devem usar [temporizadores e lembretes de ator](service-fabric-reliable-actors-timers-reminders.md) que respeitam a simultaneidade baseada em turno.</span><span class="sxs-lookup"><span data-stu-id="f805a-230">Therefore, to perform background operations, actors should use [actor timers and actor reminders](service-fabric-reliable-actors-timers-reminders.md) that respect turn-based concurrency.</span></span>

## <a name="next-steps"></a><span data-ttu-id="f805a-231">Próximas etapas</span><span class="sxs-lookup"><span data-stu-id="f805a-231">Next steps</span></span>
* <span data-ttu-id="f805a-232">Comece criando seu primeiro serviço de Reliable Actors:</span><span class="sxs-lookup"><span data-stu-id="f805a-232">Get started by building your first Reliable Actors service:</span></span>
   * [<span data-ttu-id="f805a-233">Introdução aos Reliable Actors no .NET</span><span class="sxs-lookup"><span data-stu-id="f805a-233">Getting started with Reliable Actors on .NET</span></span>](service-fabric-reliable-actors-get-started.md)
   * [<span data-ttu-id="f805a-234">Introdução aos Reliable Actors em Java</span><span class="sxs-lookup"><span data-stu-id="f805a-234">Getting started with Reliable Actors on Java</span></span>](service-fabric-reliable-actors-get-started-java.md)

<!--Image references-->
[1]: ./media/service-fabric-reliable-actors-introduction/concurrency.png
[2]: ./media/service-fabric-reliable-actors-introduction/distribution.png
[3]: ./media/service-fabric-reliable-actors-introduction/actor-communication.png

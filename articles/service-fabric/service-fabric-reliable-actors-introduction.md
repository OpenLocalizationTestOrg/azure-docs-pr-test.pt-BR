---
title: "aaaService visão geral de atores confiável malha | Microsoft Docs"
description: "Introdução toohello Service Fabric Reliable Actors modelo de programação."
services: service-fabric
documentationcenter: .net
author: vturecek
manager: timlt
editor: 
ms.assetid: 7fdad07f-f2d6-4c74-804d-e0d56131f060
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 06/29/2017
ms.author: vturecek
ms.openlocfilehash: ab010cbf936c6cf723b3d453ef95a9bf51f76c95
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 10/06/2017
---
# <a name="introduction-tooservice-fabric-reliable-actors"></a><span data-ttu-id="4b6d8-103">Introdução tooService malha Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="4b6d8-103">Introduction tooService Fabric Reliable Actors</span></span>
<span data-ttu-id="4b6d8-104">Atores confiáveis é uma estrutura de aplicativo de malha do serviço com base em Olá [ator Virtual](http://research.microsoft.com/en-us/projects/orleans/) padrão.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-104">Reliable Actors is a Service Fabric application framework based on hello [Virtual Actor](http://research.microsoft.com/en-us/projects/orleans/) pattern.</span></span> <span data-ttu-id="4b6d8-105">Olá confiável API de atores fornece um modelo de programação thread único, criado em garantias de escalabilidade e confiabilidade de saudação fornecidas pela malha do serviço.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-105">hello Reliable Actors API provides a single-threaded programming model built on hello scalability and reliability guarantees provided by Service Fabric.</span></span>

## <a name="what-are-actors"></a><span data-ttu-id="4b6d8-106">O que são Atores?</span><span class="sxs-lookup"><span data-stu-id="4b6d8-106">What are Actors?</span></span>
<span data-ttu-id="4b6d8-107">Um ator é uma unidade isolada e independente de computação e de estado com execução single-threaded.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-107">An actor is an isolated, independent unit of compute and state with single-threaded execution.</span></span> <span data-ttu-id="4b6d8-108">Olá [padrão ator](https://en.wikipedia.org/wiki/Actor_model) é um modelo de computação para sistemas simultâneos ou distribuídos em que um grande número desses atores pode ser executadas simultaneamente e independentemente uns dos outros.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-108">hello [actor pattern](https://en.wikipedia.org/wiki/Actor_model) is a computational model for concurrent or distributed systems in which a large number of these actors can execute simultaneously and independently of each other.</span></span> <span data-ttu-id="4b6d8-109">Os atores podem se comunicar entre si e criar outros atores.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-109">Actors can communicate with each other and they can create more actors.</span></span>

### <a name="when-toouse-reliable-actors"></a><span data-ttu-id="4b6d8-110">Quando toouse Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="4b6d8-110">When toouse Reliable Actors</span></span>
<span data-ttu-id="4b6d8-111">Atores confiável do serviço de malha é uma implementação do padrão de design de ator hello.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-111">Service Fabric Reliable Actors is an implementation of hello actor design pattern.</span></span> <span data-ttu-id="4b6d8-112">Assim como acontece com qualquer padrão de design de software, decisão Olá se toouse um padrão específico é feito com base em se um software criar problema correspondam padrão de saudação.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-112">As with any software design pattern, hello decision whether toouse a specific pattern is made based on whether or not a software design problem fits hello pattern.</span></span>

<span data-ttu-id="4b6d8-113">Embora o design de ator Olá padrão pode ser que uma boa opção tooa número de problemas de sistemas distribuídos e cenários de cuidadosos consideração das restrições de saudação do padrão de saudação e framework Olá implementá-lo deve ser feita.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-113">Although hello actor design pattern can be a good fit tooa number of distributed systems problems and scenarios, careful consideration of hello constraints of hello pattern and hello framework implementing it must be made.</span></span> <span data-ttu-id="4b6d8-114">Como orientação geral, considere Olá ator padrão toomodel seu problema ou cenário se:</span><span class="sxs-lookup"><span data-stu-id="4b6d8-114">As general guidance, consider hello actor pattern toomodel your problem or scenario if:</span></span>

* <span data-ttu-id="4b6d8-115">Seu problema de espaço envolve um grande número (milhares ou milhões) de pequenas unidades de estado e lógica que, além de serem independentes, são isoladas.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-115">Your problem space involves a large number (thousands or more) of small, independent, and isolated units of state and logic.</span></span>
* <span data-ttu-id="4b6d8-116">Você deseja toowork com objetos de thread único que não exigem interação significativa de componentes externos, incluindo consultando o estado em um conjunto de atores.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-116">You want toowork with single-threaded objects that do not require significant interaction from external components, including querying state across a set of actors.</span></span>
* <span data-ttu-id="4b6d8-117">Suas instâncias de ator não bloquearão chamadores com atrasos imprevisíveis emitindo operações de E/S.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-117">Your actor instances won't block callers with unpredictable delays by issuing I/O operations.</span></span>

## <a name="actors-in-service-fabric"></a><span data-ttu-id="4b6d8-118">Atores no Service Fabric</span><span class="sxs-lookup"><span data-stu-id="4b6d8-118">Actors in Service Fabric</span></span>
<span data-ttu-id="4b6d8-119">No Service Fabric atores são implementados no framework de Reliable Actors Olá: uma estrutura de aplicativo com base no padrão de ator criada na parte superior do [serviços confiável do serviço do Fabric](service-fabric-reliable-services-introduction.md).</span><span class="sxs-lookup"><span data-stu-id="4b6d8-119">In Service Fabric, actors are implemented in hello Reliable Actors framework: An actor-pattern-based application framework built on top of [Service Fabric Reliable Services](service-fabric-reliable-services-introduction.md).</span></span> <span data-ttu-id="4b6d8-120">Cada serviço escrito do Reliable Actor é, de fato, um Reliable Service com estado particionado.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-120">Each Reliable Actor service you write is actually a partitioned, stateful Reliable Service.</span></span>

<span data-ttu-id="4b6d8-121">Cada ator é definido como uma instância de um tipo de ator, toohello idênticos maneira um objeto .NET é uma instância de um tipo .NET.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-121">Every actor is defined as an instance of an actor type, identical toohello way a .NET object is an instance of a .NET type.</span></span> <span data-ttu-id="4b6d8-122">Por exemplo, pode haver um tipo de ator que implementa a funcionalidade de saudação de uma calculadora e pode haver muitos atores desse tipo que são distribuídos em vários nós em um cluster.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-122">For example, there may be an actor type that implements hello functionality of a calculator and there could be many actors of that type that are distributed on various nodes across a cluster.</span></span> <span data-ttu-id="4b6d8-123">Cada ator desse é exclusivamente identificado por uma ID de ator.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-123">Each such actor is uniquely identified by an actor ID.</span></span>

### <a name="actor-lifetime"></a><span data-ttu-id="4b6d8-124">Tempo de vida do ator</span><span class="sxs-lookup"><span data-stu-id="4b6d8-124">Actor Lifetime</span></span>
<span data-ttu-id="4b6d8-125">Atores Service Fabric são virtuais, o que significa que seu tempo de vida não é a representação em memória tootheir associado.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-125">Service Fabric actors are virtual, meaning that their lifetime is not tied tootheir in-memory representation.</span></span> <span data-ttu-id="4b6d8-126">Como resultado, eles não precisarem toobe explicitamente criado ou destruído.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-126">As a result, they do not need toobe explicitly created or destroyed.</span></span> <span data-ttu-id="4b6d8-127">tempo de execução do Hello Reliable Actors ativa automaticamente Olá um ator primeira vez que ele receber uma solicitação para esse ID de ator.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-127">hello Reliable Actors runtime automatically activates an actor hello first time it receives a request for that actor ID.</span></span> <span data-ttu-id="4b6d8-128">Se um ator não for usado por um período de tempo, o tempo de execução do hello Reliable Actors lixo-coleta objetos em memória de saudação.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-128">If an actor is not used for a period of time, hello Reliable Actors runtime garbage-collects hello in-memory object.</span></span> <span data-ttu-id="4b6d8-129">Ele também mantêm Conhecimento da existência do ator Olá caso seja necessário toobe reativado mais tarde.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-129">It will also maintain knowledge of hello actor's existence should it need toobe reactivated later.</span></span> <span data-ttu-id="4b6d8-130">Para obter mais detalhes, veja [Ciclo de vida do ator e coleta de lixo](service-fabric-reliable-actors-lifecycle.md).</span><span class="sxs-lookup"><span data-stu-id="4b6d8-130">For more details, see [Actor lifecycle and garbage collection](service-fabric-reliable-actors-lifecycle.md).</span></span>

<span data-ttu-id="4b6d8-131">Essa abstração de tempo de vida de ator virtual executa algumas restrições como resultado do modelo de ator virtual hello e, em seguida, na verdade Olá implementação Reliable Actors às vezes desvia deste modelo.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-131">This virtual actor lifetime abstraction carries some caveats as a result of hello virtual actor model, and in fact hello Reliable Actors implementation deviates at times from this model.</span></span>

* <span data-ttu-id="4b6d8-132">Um ator é ativado automaticamente (fazendo com que um ator toobe objeto construído) Olá a primeira vez que uma mensagem é enviada a ID de ator tooits.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-132">An actor is automatically activated (causing an actor object toobe constructed) hello first time a message is sent tooits actor ID.</span></span> <span data-ttu-id="4b6d8-133">Após um período de tempo, o objeto de ator de saudação é coletado como lixo.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-133">After some period of time, hello actor object is garbage collected.</span></span> <span data-ttu-id="4b6d8-134">Em Olá futuro, usando uma ID de ator Olá novamente, faz com que um novo ator toobe objeto construído.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-134">In hello future, using hello actor ID again, causes a new actor object toobe constructed.</span></span> <span data-ttu-id="4b6d8-135">Estado de um ator superam o tempo de vida do objeto hello quando armazenado no Gerenciador de estado de saudação.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-135">An actor's state outlives hello object's lifetime when stored in hello state manager.</span></span>
* <span data-ttu-id="4b6d8-136">A chamada a qualquer método de ator para obter uma ID de ator ativa esse ator.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-136">Calling any actor method for an actor ID activates that actor.</span></span> <span data-ttu-id="4b6d8-137">Por esse motivo, os tipos de ator têm seu construtor chamado implicitamente pelo tempo de execução de saudação.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-137">For this reason, actor types have their constructor called implicitly by hello runtime.</span></span> <span data-ttu-id="4b6d8-138">Portanto, o código do cliente não pode passar construtor do tipo de ator toohello parâmetros, embora parâmetros podem ser passados construtor toohello ator pelo serviço de saudação em si.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-138">Therefore, client code cannot pass parameters toohello actor type's constructor, although parameters may be passed toohello actor's constructor by hello service itself.</span></span> <span data-ttu-id="4b6d8-139">resultado de saudação é que os atores podem ser construídos em um estado parcialmente inicializado pelo tempo de saudação que outros métodos são chamados, se ator Olá requer parâmetros de inicialização do cliente de saudação.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-139">hello result is that actors may be constructed in a partially-initialized state by hello time other methods are called on it, if hello actor requires initialization parameters from hello client.</span></span> <span data-ttu-id="4b6d8-140">Não há nenhum ponto de entrada único para a ativação de saudação de um ator do cliente hello.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-140">There is no single entry point for hello activation of an actor from hello client.</span></span>
* <span data-ttu-id="4b6d8-141">Embora Reliable Actors implicitamente criar objetos de ator. Você tem Olá capacidade tooexplicitly excluir um ator e seu estado.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-141">Although Reliable Actors implicitly create actor objects; you do have hello ability tooexplicitly delete an actor and its state.</span></span>

### <a name="distribution-and-failover"></a><span data-ttu-id="4b6d8-142">Distribuição e failover</span><span class="sxs-lookup"><span data-stu-id="4b6d8-142">Distribution and failover</span></span>
<span data-ttu-id="4b6d8-143">tooprovide escalabilidade e confiabilidade, o Service Fabric distribui atores em todo o cluster hello e automaticamente migra de nós com falhas toohealthy aqueles conforme necessário.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-143">tooprovide scalability and reliability, Service Fabric distributes actors throughout hello cluster and automatically migrates them from failed nodes toohealthy ones as required.</span></span> <span data-ttu-id="4b6d8-144">Essa é uma abstração de um [Reliable Service com estado particionado](service-fabric-concepts-partitioning.md).</span><span class="sxs-lookup"><span data-stu-id="4b6d8-144">This is an abstraction over a [partitioned, stateful Reliable Service](service-fabric-concepts-partitioning.md).</span></span> <span data-ttu-id="4b6d8-145">Distribuição, escalabilidade, confiabilidade e o failover automático são fornecidos por meio de fatos Olá que atores são executados dentro de um serviço confiável com monitoração de estado chamado hello *serviço de ator*.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-145">Distribution, scalability, reliability, and automatic failover are all provided by virtue of hello fact that actors are running inside a stateful Reliable Service called hello *Actor Service*.</span></span>

<span data-ttu-id="4b6d8-146">Atores são distribuídos em partições Olá Olá serviço ator, e essas partições são distribuídas entre os nós de saudação em um cluster do Service Fabric.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-146">Actors are distributed across hello partitions of hello Actor Service, and those partitions are distributed across hello nodes in a Service Fabric cluster.</span></span> <span data-ttu-id="4b6d8-147">Cada partição de serviço contém um conjunto de atores.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-147">Each service partition contains a set of actors.</span></span> <span data-ttu-id="4b6d8-148">Service Fabric gerencia a distribuição e o failover de partições de serviço hello.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-148">Service Fabric manages distribution and failover of hello service partitions.</span></span>

<span data-ttu-id="4b6d8-149">Por exemplo, um serviço de ator com nove partições implantado toothree nós usando a colocação de partição de ator saudação padrão serão distribuídos, deste modo:</span><span class="sxs-lookup"><span data-stu-id="4b6d8-149">For example, an actor service with nine partitions deployed toothree nodes using hello default actor partition placement would be distributed thusly:</span></span>

![Distribuição dos Reliable Actors][2]

<span data-ttu-id="4b6d8-151">Olá ator Framework gerencia configurações de intervalo esquema e a chave de partição para você.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-151">hello Actor Framework manages partition scheme and key range settings for you.</span></span> <span data-ttu-id="4b6d8-152">Isso simplifica algumas escolhas, mas também traz algumas considerações:</span><span class="sxs-lookup"><span data-stu-id="4b6d8-152">This simplifies some choices but also carries some consideration:</span></span>

* <span data-ttu-id="4b6d8-153">Serviços confiáveis permite que você toochoose um esquema de particionamento, intervalo de chave (ao usar um esquema de particionamento de intervalo) e a contagem de partição.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-153">Reliable Services allows you toochoose a partitioning scheme, key range (when using a range partitioning scheme), and partition count.</span></span> <span data-ttu-id="4b6d8-154">Atores confiáveis é o esquema de particionamento toohello restrito intervalo (esquema uniforme Int64 Olá) e requer que você usar a gama completa de chave de Int64 hello.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-154">Reliable Actors is restricted toohello range partitioning scheme (hello uniform Int64 scheme) and requires you use hello full Int64 key range.</span></span>
* <span data-ttu-id="4b6d8-155">Por padrão, os atores são colocados aleatoriamente em partições, resultando em uma distribuição uniforme.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-155">By default, actors are randomly placed into partitions resulting in uniform distribution.</span></span>
* <span data-ttu-id="4b6d8-156">Como os atores são colocados aleatoriamente, deve-se esperar que as operações de ator sempre exijam a comunicação de rede, incluindo a serialização e desserialização de dados de chamada de método, incorrendo em latência e sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-156">Because actors are randomly placed, it should be expected that actor operations will always require network communication, including serialization and deserialization of method call data, incurring latency and overhead.</span></span>
* <span data-ttu-id="4b6d8-157">Em cenários avançados, é possível toocontrol posicionamento de partição de ator usando Int64 ator IDs que mapear partições toospecific.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-157">In advanced scenarios, it is possible toocontrol actor partition placement by using Int64 actor IDs that map toospecific partitions.</span></span> <span data-ttu-id="4b6d8-158">No entanto, isso poderá resultar em uma distribuição desbalanceada de atores nas partições.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-158">However, doing so can result in an unbalanced distribution of actors across partitions.</span></span>

<span data-ttu-id="4b6d8-159">Para obter mais informações sobre como os serviços de ator são particionados, consulte muito[particionamento conceitos para atores](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).</span><span class="sxs-lookup"><span data-stu-id="4b6d8-159">For more information on how actor services are partitioned, refer too[partitioning concepts for actors](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).</span></span>

### <a name="actor-communication"></a><span data-ttu-id="4b6d8-160">Comunicação do ator</span><span class="sxs-lookup"><span data-stu-id="4b6d8-160">Actor communication</span></span>
<span data-ttu-id="4b6d8-161">Interações de ator são definidas em uma interface que é compartilhada por ator Olá que implementa a interface hello e cliente Olá que obtém um proxy ator tooan via Olá mesma interface.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-161">Actor interactions are defined in an interface that is shared by hello actor that implements hello interface, and hello client that gets a proxy tooan actor via hello same interface.</span></span> <span data-ttu-id="4b6d8-162">Como essa interface é usada tooinvoke ator métodos assincronamente, cada método na interface de saudação deve ser de retorno.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-162">Because this interface is used tooinvoke actor methods asynchronously, every method on hello interface must be Task-returning.</span></span>

<span data-ttu-id="4b6d8-163">Chamadas de método e suas respostas finalmente resultam em solicitações de rede em cluster hello, portanto argumentos de saudação e tipos de resultados de saudação de tarefas de saudação que elas retornam devem ser serializadas por plataforma de saudação.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-163">Method invocations and their responses ultimately result in network requests across hello cluster, so hello arguments and hello result types of hello tasks that they return must be serializable by hello platform.</span></span> <span data-ttu-id="4b6d8-164">Em particular, eles devem ser [contrato de dados serializáveis](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="4b6d8-164">In particular, they must be [data contract serializable](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span></span>

#### <a name="hello-actor-proxy"></a><span data-ttu-id="4b6d8-165">proxy de ator Olá</span><span class="sxs-lookup"><span data-stu-id="4b6d8-165">hello actor proxy</span></span>
<span data-ttu-id="4b6d8-166">API de cliente Reliable Actors Olá fornece comunicação entre uma instância de ator e um cliente de ator.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-166">hello Reliable Actors client API provides communication between an actor instance and an actor client.</span></span> <span data-ttu-id="4b6d8-167">toocommunicate com um ator, um cliente cria um objeto de proxy de ator que implementa a interface de ator hello.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-167">toocommunicate with an actor, a client creates an actor proxy object that implements hello actor interface.</span></span> <span data-ttu-id="4b6d8-168">cliente Olá interage com o ator hello, chamar métodos no objeto de proxy de saudação.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-168">hello client interacts with hello actor by invoking methods on hello proxy object.</span></span> <span data-ttu-id="4b6d8-169">proxy de ator Olá pode ser usado para comunicação de cliente para ator e ator de ator.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-169">hello actor proxy can be used for client-to-actor and actor-to-actor communication.</span></span>

```csharp
// Create a randomly distributed actor ID
ActorId actorId = ActorId.CreateRandom();

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
IMyActor myActor = ActorProxy.Create<IMyActor>(actorId, new Uri("fabric:/MyApp/MyActorService"));

// This will invoke a method on hello actor. If an actor with hello given ID does not exist, it will be activated by this method call.
await myActor.DoWorkAsync();
```

```java
// Create actor ID with some name
ActorId actorId = new ActorId("Actor1");

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
MyActor myActor = ActorProxyBase.create(actorId, new URI("fabric:/MyApp/MyActorService"), MyActor.class);

// This will invoke a method on hello actor. If an actor with hello given ID does not exist, it will be activated by this method call.
myActor.DoWorkAsync().get();
```


<span data-ttu-id="4b6d8-170">Observe que informações Olá dois usadas objeto de proxy de ator toocreate Olá são Olá ator ID e nome do aplicativo hello.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-170">Note that hello two pieces of information used toocreate hello actor proxy object are hello actor ID and hello application name.</span></span> <span data-ttu-id="4b6d8-171">ID de ator Olá identifica exclusivamente ator hello, enquanto o nome do aplicativo hello identifica Olá [aplicativo do Service Fabric](service-fabric-reliable-actors-platform.md#application-model) onde ator Olá é implantado.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-171">hello actor ID uniquely identifies hello actor, while hello application name identifies hello [Service Fabric application](service-fabric-reliable-actors-platform.md#application-model) where hello actor is deployed.</span></span>

<span data-ttu-id="4b6d8-172">Olá `ActorProxy`(c#) / `ActorProxyBase`classe (Java) no lado do cliente Olá executa ator do hello resolução necessário toolocate Olá por ID e abrir um canal de comunicação com ele.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-172">hello `ActorProxy`(C#) / `ActorProxyBase`(Java) class on hello client side performs hello necessary resolution toolocate hello actor by ID and open a communication channel with it.</span></span> <span data-ttu-id="4b6d8-173">Ele também tenta novamente toolocate ator de saudação em casos de saudação de failovers e falhas de comunicação.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-173">It also retries toolocate hello actor in hello cases of communication failures and failovers.</span></span> <span data-ttu-id="4b6d8-174">Como resultado, a entrega de mensagens tem Olá características a seguir:</span><span class="sxs-lookup"><span data-stu-id="4b6d8-174">As a result, message delivery has hello following characteristics:</span></span>

* <span data-ttu-id="4b6d8-175">A entrega de mensagem é o melhor esforço.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-175">Message delivery is best effort.</span></span>
* <span data-ttu-id="4b6d8-176">Atores podem receber mensagens duplicadas de saudação mesmo cliente.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-176">Actors may receive duplicate messages from hello same client.</span></span>

### <a name="concurrency"></a><span data-ttu-id="4b6d8-177">Simultaneidade</span><span class="sxs-lookup"><span data-stu-id="4b6d8-177">Concurrency</span></span>
<span data-ttu-id="4b6d8-178">Olá Reliable Actors em tempo de execução fornece um modelo de acesso simples com base em Ativar para acessar os métodos de ator.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-178">hello Reliable Actors runtime provides a simple turn-based access model for accessing actor methods.</span></span> <span data-ttu-id="4b6d8-179">Isso significa que não é permitido mais de um thread ativo no código do objeto de um ator a qualquer momento.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-179">This means that no more than one thread can be active inside an actor object's code at any time.</span></span> <span data-ttu-id="4b6d8-180">O acesso baseado em turno simplifica consideravelmente os sistemas simultâneos, pois não há necessidade de mecanismos de sincronização para o acesso a dados.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-180">Turn-based access greatly simplifies concurrent systems as there is no need for synchronization mechanisms for data access.</span></span> <span data-ttu-id="4b6d8-181">Isso também significa que os sistemas devem ser criados com considerações especiais sobre a natureza do acesso de thread único saudação de cada instância de ator.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-181">It also means systems must be designed with special considerations for hello single-threaded access nature of each actor instance.</span></span>

* <span data-ttu-id="4b6d8-182">Uma única instância de ator não pode processar mais de uma solicitação por vez.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-182">A single actor instance cannot process more than one request at a time.</span></span> <span data-ttu-id="4b6d8-183">Uma instância de ator pode causar um gargalo se trata de solicitações simultâneas toohandle esperado.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-183">An actor instance can cause a throughput bottleneck if it is expected toohandle concurrent requests.</span></span>
* <span data-ttu-id="4b6d8-184">Atores podem acarretar deadlock em si, se houver uma solicitação circular entre dois atores enquanto uma solicitação externa é feita tooone de atores Olá simultaneamente.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-184">Actors can deadlock on each other if there is a circular request between two actors while an external request is made tooone of hello actors simultaneously.</span></span> <span data-ttu-id="4b6d8-185">Olá ator tempo de execução será automaticamente uma vez no ator chama e lançar um toointerrupt de chamador exceção toohello possíveis situações de deadlock.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-185">hello actor runtime will automatically time out on actor calls and throw an exception toohello caller toointerrupt possible deadlock situations.</span></span>

![Comunicação dos Reliable Actors][3]

#### <a name="turn-based-access"></a><span data-ttu-id="4b6d8-187">Acesso com base em vez</span><span class="sxs-lookup"><span data-stu-id="4b6d8-187">Turn-based access</span></span>
<span data-ttu-id="4b6d8-188">Uma vez consiste em concluir a execução de um método de ator na solicitação de tooa de resposta de outros clientes ou atores hello, ou concluir a execução da saudação um [timer/lembrete](service-fabric-reliable-actors-timers-reminders.md) retorno de chamada.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-188">A turn consists of hello complete execution of an actor method in response tooa request from other actors or clients, or hello complete execution of a [timer/reminder](service-fabric-reliable-actors-timers-reminders.md) callback.</span></span> <span data-ttu-id="4b6d8-189">Mesmo que esses métodos e retornos de chamada assíncronos, o tempo de execução do hello atores não intercalá-los.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-189">Even though these methods and callbacks are asynchronous, hello Actors runtime does not interleave them.</span></span> <span data-ttu-id="4b6d8-190">Um turno deve ser totalmente concluído antes que um novo turno seja permitido.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-190">A turn must be fully finished before a new turn is allowed.</span></span> <span data-ttu-id="4b6d8-191">Em outras palavras, um ator timer/lembrete ou método retorno de chamada que está sendo executado deve ser totalmente concluído antes de um novo método tooa chamada ou retorno de chamada é permitido.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-191">In other words, an actor method or timer/reminder callback that is currently executing must be fully finished before a new call tooa method or callback is allowed.</span></span> <span data-ttu-id="4b6d8-192">Um método ou o retorno de chamada é considerado toohave concluído se execução Olá foi retornado de método hello ou tarefa de retorno de chamada e hello retornada pelo método hello ou retorno de chamada é concluída.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-192">A method or callback is considered toohave finished if hello execution has returned from hello method or callback and hello task returned by hello method or callback has finished.</span></span> <span data-ttu-id="4b6d8-193">Vale enfatizar que a simultaneidade baseada em turno é respeitada mesmo entre métodos, temporizadores e retornos de chamada diferentes.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-193">It is worth emphasizing that turn-based concurrency is respected even across different methods, timers, and callbacks.</span></span>

<span data-ttu-id="4b6d8-194">tempo de execução de atores Olá impõe simultaneidade baseada em vez ao adquirir um bloqueio por ator no início de uma curva hello e liberar bloqueio Olá final Olá Olá ativar.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-194">hello Actors runtime enforces turn-based concurrency by acquiring a per-actor lock at hello beginning of a turn and releasing hello lock at hello end of hello turn.</span></span> <span data-ttu-id="4b6d8-195">Desse modo, a simultaneidade baseada em turno é imposta por ator e não entre atores.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-195">Thus, turn-based concurrency is enforced on a per-actor basis and not across actors.</span></span> <span data-ttu-id="4b6d8-196">Os métodos de ator e retornos de chamada de temporizador/lembrete podem ser executados simultaneamente em nome de diferentes atores.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-196">Actor methods and timer/reminder callbacks can execute simultaneously on behalf of different actors.</span></span>

<span data-ttu-id="4b6d8-197">saudação de exemplo a seguir ilustra Olá acima conceitos.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-197">hello following example illustrates hello above concepts.</span></span> <span data-ttu-id="4b6d8-198">Considere um tipo de ator que implementa dois métodos assíncronos (digamos, *Method1* e *Method2*), um temporizador e um lembrete.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-198">Consider an actor type that implements two asynchronous methods (say, *Method1* and *Method2*), a timer, and a reminder.</span></span> <span data-ttu-id="4b6d8-199">Olá diagrama a seguir mostra um exemplo de uma linha do tempo de execução Olá desses métodos e retornos de chamada em nome de duas atores (*ActorId1* e *ActorId2*) que pertencem a tipo de ator toothis.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-199">hello diagram below shows an example of a timeline for hello execution of these methods and callbacks on behalf of two actors (*ActorId1* and *ActorId2*) that belong toothis actor type.</span></span>

![Simultaneidade e acesso com base em turno do Reliable Actors][1]

<span data-ttu-id="4b6d8-201">O diagrama segue as seguintes convenções:</span><span class="sxs-lookup"><span data-stu-id="4b6d8-201">This diagram follows these conventions:</span></span>

* <span data-ttu-id="4b6d8-202">Cada linha vertical mostra o fluxo lógico de saudação da execução de um método ou um retorno de chamada em nome de um ator específico.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-202">Each vertical line shows hello logical flow of execution of a method or a callback on behalf of a particular actor.</span></span>
* <span data-ttu-id="4b6d8-203">eventos de saudação marcados em cada linha vertical ocorrem em ordem cronológica, com os eventos mais recentes ocorre abaixo os mais antigos.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-203">hello events marked on each vertical line occur in chronological order, with newer events occurring below older ones.</span></span>
* <span data-ttu-id="4b6d8-204">Cores diferentes são usadas para linhas de tempo correspondente toodifferent atores.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-204">Different colors are used for timelines corresponding toodifferent actors.</span></span>
* <span data-ttu-id="4b6d8-205">Realce é a duração de saudação do tooindicate usado para qual Olá bloqueio por ator é mantido em nome de um método ou o retorno de chamada.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-205">Highlighting is used tooindicate hello duration for which hello per-actor lock is held on behalf of a method or callback.</span></span>

<span data-ttu-id="4b6d8-206">Tooconsider alguns pontos importantes:</span><span class="sxs-lookup"><span data-stu-id="4b6d8-206">Some important points tooconsider:</span></span>

* <span data-ttu-id="4b6d8-207">Enquanto *Method1* está em execução em nome de *ActorId2* na solicitação de tooclient resposta *xyz789*, outra solicitação de cliente (*abc123*) chega que também requer *Method1* toobe executado por *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-207">While *Method1* is executing on behalf of *ActorId2* in response tooclient request *xyz789*, another client request (*abc123*) arrives that also requires *Method1* toobe executed by *ActorId2*.</span></span> <span data-ttu-id="4b6d8-208">No entanto, Olá segunda execução da *Method1* não começa até concluir a execução anterior hello.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-208">However, hello second execution of *Method1* does not begin until hello prior execution has finished.</span></span> <span data-ttu-id="4b6d8-209">Da mesma forma, um lembrete registrados por *ActorId2* é acionado ao *Method1* está sendo executado na solicitação de tooclient resposta *xyz789*.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-209">Similarly, a reminder registered by *ActorId2* fires while *Method1* is being executed in response tooclient request *xyz789*.</span></span> <span data-ttu-id="4b6d8-210">Olá retorno de chamada de lembrete é executado somente depois de ambas as execuções de *Method1* forem concluídas.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-210">hello reminder callback is executed only after both executions of *Method1* are complete.</span></span> <span data-ttu-id="4b6d8-211">Tudo isso é devido a simultaneidade baseada em tooturn que está sendo imposta para *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-211">All of this is due tooturn-based concurrency being enforced for *ActorId2*.</span></span>
* <span data-ttu-id="4b6d8-212">Da mesma forma, também for aplicada a simultaneidade baseada em vez de *ActorId1*, conforme demonstrado pela execução de saudação do *Method1*, *Method2*, e Olá chamada timer em nome de *ActorId1* acontece de maneira serial.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-212">Similarly, turn-based concurrency is also enforced for *ActorId1*, as demonstrated by hello execution of *Method1*, *Method2*, and hello timer callback on behalf of *ActorId1* happening in a serial fashion.</span></span>
* <span data-ttu-id="4b6d8-213">A execução de *Method1* em nome de *ActorId1* é sobreposta por sua execução em nome de *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-213">Execution of *Method1* on behalf of *ActorId1* overlaps with its execution on behalf of *ActorId2*.</span></span> <span data-ttu-id="4b6d8-214">Isso porque a simultaneidade baseada em turno é imposta apenas em um ator, e não entre atores.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-214">This is because turn-based concurrency is enforced only within an actor and not across actors.</span></span>
* <span data-ttu-id="4b6d8-215">Em algumas das execuções de retorno de chamada/método hello, Olá `Task`(c#) / `CompletableFuture`(Java) retornado pela conclusão de retorno de chamada/método hello depois que o método hello retorna.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-215">In some of hello method/callback executions, hello `Task`(C#) / `CompletableFuture`(Java) returned by hello method/callback finishes after hello method returns.</span></span> <span data-ttu-id="4b6d8-216">Em alguns outros, operação assíncrona Olá já foi concluída por tempo Olá Olá método/retorno.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-216">In some others, hello asynchronous operation has already finished by hello time hello method/callback returns.</span></span> <span data-ttu-id="4b6d8-217">Em ambos os casos, do bloqueio por ator Olá é liberado somente depois que ambos os Olá método/retorno e conclusão da operação assíncrona hello.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-217">In both cases, hello per-actor lock is released only after both hello method/callback returns and hello asynchronous operation finishes.</span></span>

#### <a name="reentrancy"></a><span data-ttu-id="4b6d8-218">Reentrada</span><span class="sxs-lookup"><span data-stu-id="4b6d8-218">Reentrancy</span></span>
<span data-ttu-id="4b6d8-219">tempo de execução de atores Olá permite reentrada por padrão.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-219">hello Actors runtime allows reentrancy by default.</span></span> <span data-ttu-id="4b6d8-220">Isso significa que, se um método de ator *ator A* chama um método em *ator B*, que por sua vez chama outro método em *ator A*, que o método é permitido toorun.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-220">This means that if an actor method of *Actor A* calls a method on *Actor B*, which in turn calls another method on *Actor A*, that method is allowed toorun.</span></span> <span data-ttu-id="4b6d8-221">Isso ocorre porque ele faz parte da saudação mesmo contexto de lógica de cadeia de chamadas.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-221">This is because it is part of hello same logical call-chain context.</span></span> <span data-ttu-id="4b6d8-222">Todas as chamadas de timer e lembrete iniciar com novo contexto de chamada lógico hello.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-222">All timer and reminder calls start with hello new logical call context.</span></span> <span data-ttu-id="4b6d8-223">Consulte Olá [reentrada Reliable Actors](service-fabric-reliable-actors-reentrancy.md) para obter mais detalhes.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-223">See hello [Reliable Actors reentrancy](service-fabric-reliable-actors-reentrancy.md) for more details.</span></span>

#### <a name="scope-of-concurrency-guarantees"></a><span data-ttu-id="4b6d8-224">Escopo de garantias de simultaneidade</span><span class="sxs-lookup"><span data-stu-id="4b6d8-224">Scope of concurrency guarantees</span></span>
<span data-ttu-id="4b6d8-225">tempo de execução de atores Olá fornece essas garantias de simultaneidade em situações em que ele controla invocação Olá desses métodos.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-225">hello Actors runtime provides these concurrency guarantees in situations where it controls hello invocation of these methods.</span></span> <span data-ttu-id="4b6d8-226">Por exemplo, ele fornece essas garantias para invocações de método hello que são feitas na solicitação do cliente tooa resposta, bem como para retornos de chamada timer e lembretes.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-226">For example, it provides these guarantees for hello method invocations that are done in response tooa client request, as well as for timer and reminder callbacks.</span></span> <span data-ttu-id="4b6d8-227">No entanto, se o código de ator Olá invoca diretamente esses métodos fora de mecanismos de Olá fornecidos pelo tempo de execução de atores hello, Olá runtime não pode fornecer qualquer garantia de simultaneidade.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-227">However, if hello actor code directly invokes these methods outside of hello mechanisms provided by hello Actors runtime, then hello runtime cannot provide any concurrency guarantees.</span></span> <span data-ttu-id="4b6d8-228">Por exemplo, se o método hello é invocado no contexto de saudação de alguma tarefa que não está associado à tarefa Olá retornada pelos métodos de ator Olá, Olá runtime não pode fornecer garantias de simultaneidade.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-228">For example, if hello method is invoked in hello context of some task that is not associated with hello task returned by hello actor methods, then hello runtime cannot provide concurrency guarantees.</span></span> <span data-ttu-id="4b6d8-229">Se Olá método é chamado de um thread que ator Olá cria por conta própria, Olá runtime não pode fornecer garantia de simultaneidade.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-229">If hello method is invoked from a thread that hello actor creates on its own, then hello runtime also cannot provide concurrency guarantees.</span></span> <span data-ttu-id="4b6d8-230">Portanto, as operações do plano de fundo tooperform, atores devem usar [temporizadores de ator e lembretes de ator](service-fabric-reliable-actors-timers-reminders.md) que respeita simultaneidade baseada em Ativar.</span><span class="sxs-lookup"><span data-stu-id="4b6d8-230">Therefore, tooperform background operations, actors should use [actor timers and actor reminders](service-fabric-reliable-actors-timers-reminders.md) that respect turn-based concurrency.</span></span>

## <a name="next-steps"></a><span data-ttu-id="4b6d8-231">Próximas etapas</span><span class="sxs-lookup"><span data-stu-id="4b6d8-231">Next steps</span></span>
* <span data-ttu-id="4b6d8-232">Comece criando seu primeiro serviço de Reliable Actors:</span><span class="sxs-lookup"><span data-stu-id="4b6d8-232">Get started by building your first Reliable Actors service:</span></span>
   * [<span data-ttu-id="4b6d8-233">Introdução aos Reliable Actors no .NET</span><span class="sxs-lookup"><span data-stu-id="4b6d8-233">Getting started with Reliable Actors on .NET</span></span>](service-fabric-reliable-actors-get-started.md)
   * [<span data-ttu-id="4b6d8-234">Introdução aos Reliable Actors em Java</span><span class="sxs-lookup"><span data-stu-id="4b6d8-234">Getting started with Reliable Actors on Java</span></span>](service-fabric-reliable-actors-get-started-java.md)

<!--Image references-->
[1]: ./media/service-fabric-reliable-actors-introduction/concurrency.png
[2]: ./media/service-fabric-reliable-actors-introduction/distribution.png
[3]: ./media/service-fabric-reliable-actors-introduction/actor-communication.png
